===== FILE: .env =====
# Note: values redacted for safety
AUTH0_SECRET=REDACTED
APP_BASE_URL=REDACTED
AUTH0_DOMAIN=REDACTED
AUTH0_CLIENT_ID=REDACTED
AUTH0_CLIENT_SECRET=REDACTED
# 'If your application is API authorized add the variables AUTH0_AUDIENCE and AUTH0_SCOPE'
# AUTH0_AUDIENCE='your_auth_api_identifier'
AUTH0_SCOPE=REDACTED

# Recommended for most uses
DATABASE_URL=REDACTED=require

# For uses requiring a connection without pgbouncer
DATABASE_URL_UNPOOLED=REDACTED=require

# Parameters for constructing your own connection string
PGHOST=REDACTED
PGHOST_UNPOOLED=REDACTED
PGUSER=REDACTED
PGDATABASE=REDACTED
PGPASSWORD=REDACTED

# Parameters for Vercel Postgres Templates
POSTGRES_URL=REDACTED=require
POSTGRES_URL_NON_POOLING=REDACTED=require
POSTGRES_USER=REDACTED
POSTGRES_HOST=REDACTED
POSTGRES_PASSWORD=REDACTED
POSTGRES_DATABASE=REDACTED
POSTGRES_URL_NO_SSL=REDACTED
POSTGRES_PRISMA_URL=REDACTED=15&sslmode=require

# Public Mapbox token for client-side usage (must be pk.*)
NEXT_PUBLIC_MAPBOX_TOKEN=REDACTED

# Server-side only secret token (do not expose to client)
# Not used by the map page, but available for server actions if needed
MAPBOX_SECRET_TOKEN=REDACTED
FIRMS_MAP_KEY=REDACTED

# --- AWS S3 (generated by setup) ---
# Region selected to match EU resources for lower latency
AWS_REGION=REDACTED
AWS_S3_BUCKET=REDACTED
# Public base URL for reading uploaded files
AWS_S3_PUBLIC_URL=REDACTED
# App IAM user credentials (least-privilege for the bucket above)
AWS_ACCESS_KEY_ID=REDACTED
AWS_SECRET_ACCESS_KEY=REDACTED

# --- Sendbird ---
# Public app ID for client SDK init
NEXT_PUBLIC_SENDBIRD_APP_ID=REDACTED
# Platform API base URL for this application (region: Frankfurt)
SENDBIRD_API_BASE_URL=REDACTED
# Master API token for server-to-server requests
SENDBIRD_API_TOKEN=REDACTED

# --- Notifications ---
# Resend API (for transactional emails)
RESEND_API_KEY=REDACTED
NOTIFY_EMAIL_FROM=REDACTED

# QuadraMM SMS
QUADRA_SMS_GATEWAY_URL=REDACTED
QUADRA_SMS_USER=REDACTED
QUADRA_SMS_PASS=REDACTED
QUADRA_SMS_ROUTE=REDACTED
CRON_SECRET=REDACTED
\n===== END FILE: .env =====\n
===== FILE: README.md =====
This is a [Next.js](https://nextjs.org) project bootstrapped with [`create-next-app`](https://nextjs.org/docs/app/api-reference/cli/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/app/building-your-application/optimizing/fonts) to automatically optimize and load [Geist](https://vercel.com/font), a new font family for Vercel.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/app/building-your-application/deploying) for more details.

## Database: Drizzle ORM + Neon Postgres

This project uses Drizzle ORM with Neon Postgres via the HTTP driver, which is ideal for serverless and Edge runtimes in Next.js. The setup follows current Drizzle guidance and Neon best practices.

### 1) Install dependencies

Already added to this repo. For reference:

```
npm i drizzle-orm @neondatabase/serverless
npm i -D drizzle-kit
```

### 2) Environment variables

- Set `DATABASE_URL` in `.env` to your Neon pooled connection string (pgBouncer). This repo already includes the variable for local dev.
- If you need unpooled connections (long transactions, LISTEN/NOTIFY), use `DATABASE_URL_UNPOOLED` and a compatible driver (e.g., Neon websockets or node-postgres). The default setup here uses HTTP + pooling.

Never expose `DATABASE_URL` to the client; only use it in server code.

### 3) Drizzle config and schema

- Config: `drizzle.config.ts` uses the `postgresql` dialect and reads `DATABASE_URL` from `.env`. Migration SQL is output to `./drizzle`.
- Schema: define tables in `lib/db/schema.ts`. Example tables included: `users` and `sessions`.

### 4) DB client

The Neon HTTP driver is initialized once and exported from `lib/db/index.ts`.

```
import { db } from '@/lib/db';
import { users } from '@/lib/db/schema';

export async function createUser(email: string, name?: string) {
  await db.insert(users).values({ email, name });
}
```

Use `db` only in server code (server components, route handlers, server actions, or `app` API routes).

### 5) Migrations and tools

Common scripts are available:

```
# Generate SQL migration files from your schema
npm run db:generate

# Apply migrations to the database
npm run db:migrate

# (Optional) Push schema directly without files (quick dev only)
npm run db:push

# Visualize your schema and data
npm run db:studio
```

Typical flow:

1. Edit tables in `lib/db/schema.ts`.
2. Run `npm run db:generate` to produce SQL under `./drizzle`.
3. Run `npm run db:migrate` to apply changes to the Neon database.

### 6) Notes and best practices

- For most Next.js serverless/Edge workloads, the Neon HTTP driver (`drizzle-orm/neon-http`) is recommended.
- Keep migrations in Git; avoid editing generated SQL by hand.
- Use pooled connection strings in prod for better scalability.
- For long-lived transactions or features like `LISTEN/NOTIFY`, prefer unpooled connections with websockets or node `pg`.
- Avoid `defaultRandom()` UUIDs unless you’ve enabled the required Postgres extension; this schema defaults to serial IDs to stay portable.
\n===== END FILE: README.md =====\n
===== FILE: app/actions/fires.ts =====
"use server";

import { revalidatePath } from "next/cache";
import { db } from "@/lib/db";
import { fires, users, fireVolunteers, fireJoinTokens, fireJoinTokenUses, fireDeactivationVotes, type Fire } from "@/lib/db/schema";
import { and, desc, eq, gt, isNull, sql } from "drizzle-orm";
import { auth0 } from "@/lib/auth0";
import crypto from "crypto";
import { ensureSbUser, getOrCreateFireChannel, joinUserToChannel } from "@/lib/sendbird";

// ---------- helpers ----------
async function ensureLocalUser() {
  const session = await auth0.getSession();
  const u = session?.user;
  if (!u) throw new Error("Unauthorized");

  const email = u.email!;
  const name = u.name ?? null;

  const existing = await db.select().from(users).where(eq(users.email, email)).limit(1);
  if (existing.length > 0) {
    const row = existing[0];
    if (name && row.name !== name) {
      await db.update(users).set({ name, updatedAt: new Date() }).where(eq(users.id, row.id));
    }
    return { session: u, local: row };
  }

  const [created] = await db.insert(users).values({ email, name }).returning();
  return { session: u, local: created };
}

async function requireConfirmedVolunteer(fireId: number, userId: number) {
  const row = await db
    .select()
    .from(fireVolunteers)
    .where(and(eq(fireVolunteers.fireId, fireId), eq(fireVolunteers.userId, userId), eq(fireVolunteers.status, "confirmed")))
    .limit(1);
  if (row.length === 0) throw new Error("Forbidden");
}

async function ensureSendbirdJoined(fireId: number, userId: number) {
  try {
    const u = (await db.select().from(users).where(eq(users.id, userId)).limit(1))[0];
    if (!u) return;
    const sbUid = `user-${u.id}`;
    await ensureSbUser(sbUid, u.name || u.email);
    const channelUrl = await getOrCreateFireChannel(fireId);
    await joinUserToChannel(channelUrl, sbUid);
  } catch (e: any) {
    console.warn("[sendbird] auto-join failed", fireId, userId, e?.message);
  }
}

// ----- Activity helpers -----
function inactivityDays() {
  const d = Number(process.env.FIRE_INACTIVITY_DAYS || 3);
  return Number.isFinite(d) && d > 0 ? d : 3;
}

async function reactivateFireIfNeeded(fireId: number) {
  try {
    // Reactivate if currently inactive; clear previous votes
    await db.update(fires).set({ status: 'active', deactivatedAt: null, updatedAt: new Date() }).where(and(eq(fires.id, fireId), eq(fires.status, 'inactive')));
    await db.delete(fireDeactivationVotes).where(eq(fireDeactivationVotes.fireId, fireId));
  } catch {}
}

async function touchFireActivity(fireId: number) {
  try {
    await db.update(fires).set({ lastActivityAt: new Date(), updatedAt: new Date() }).where(eq(fires.id, fireId));
    await reactivateFireIfNeeded(fireId);
  } catch {}
}

export async function autoDeactivateStaleFires() {
  const days = inactivityDays();
  // Refresh last_activity_at from related tables (best-effort)
  try {
    await db.execute(sql`
      UPDATE "fires" f
      SET "last_activity_at" = GREATEST(
        f."updated_at",
        COALESCE((SELECT MAX(u."created_at") FROM "zone_updates" u JOIN "zones" z ON z."id" = u."zone_id" WHERE z."fire_id" = f."id"), to_timestamp(0)),
        COALESCE((SELECT MAX(m."created_at") FROM "chat_messages" m WHERE m."fire_id" = f."id" AND m."deleted_at" IS NULL), to_timestamp(0)),
        COALESCE((SELECT MAX(v."updated_at") FROM "fire_volunteers" v WHERE v."fire_id" = f."id"), to_timestamp(0)),
        COALESCE((SELECT MAX(m."created_at") FROM "zone_members" m WHERE m."fire_id" = f."id"), to_timestamp(0)),
        COALESCE((SELECT MAX(u."used_at") FROM "fire_join_token_uses" u JOIN "fire_join_tokens" t ON t."id" = u."token_id" WHERE t."fire_id" = f."id"), to_timestamp(0)),
        f."last_activity_at"
      )
      WHERE f."status" = 'active';
    `);
  } catch {}

  // Deactivate fires with no activity for N days
  try {
    await db.execute(sql`
      UPDATE "fires"
      SET "status" = 'inactive', "deactivated_at" = now(), "updated_at" = now()
      WHERE "status" = 'active' AND "last_activity_at" < now() - (${days}::text || ' days')::interval;
    `);
  } catch {}
}

export async function listFires(limit = 500) {
  const max = Math.min(Math.max(limit, 1), 2000);
  async function run() {
    // best-effort maintenance pass
    await autoDeactivateStaleFires();

    const rows = await db
      .select()
      .from(fires)
      .where(eq(fires.status, "active"))
      .orderBy(desc(fires.createdAt))
      .limit(max);
    // attach volunteer counts per fire
    const counts = await db
      .select({
        fireId: fireVolunteers.fireId,
        confirmed: sql<number>`sum(case when ${fireVolunteers.status} = 'confirmed' then 1 else 0 end)`,
        requested: sql<number>`sum(case when ${fireVolunteers.status} = 'requested' then 1 else 0 end)`,
      })
      .from(fireVolunteers)
      .groupBy(fireVolunteers.fireId);
    const byId = new Map<number, { confirmed: number; requested: number }>();
    for (const c of counts) byId.set(c.fireId, { confirmed: Number(c.confirmed ?? 0), requested: Number(c.requested ?? 0) });
    return rows.map((r) => ({
      ...r,
      volunteersConfirmed: byId.get(r.id)?.confirmed ?? 0,
      volunteersRequested: byId.get(r.id)?.requested ?? 0,
    }));
  }
  try {
    return await run();
  } catch {
    await new Promise((r) => setTimeout(r, 300));
    return await run();
  }
}

export async function getFireById(id: number) {
  const rows = await db.select().from(fires).where(eq(fires.id, id)).limit(1);
  return rows[0] ?? null;
}

// ----- Volunteers listing -----
export async function volunteersForFire(fireId: number) {
  const rows = await db
    .select({
      id: fireVolunteers.id,
      userId: fireVolunteers.userId,
      status: fireVolunteers.status,
      createdAt: fireVolunteers.createdAt,
      name: users.name,
      email: users.email,
    })
    .from(fireVolunteers)
    .leftJoin(users, eq(fireVolunteers.userId, users.id))
    .where(eq(fireVolunteers.fireId, fireId))
    .orderBy(desc(fireVolunteers.createdAt));

  const confirmed = rows.filter((r) => r.status === "confirmed");
  const requested = rows.filter((r) => r.status === "requested");
  return { confirmed, requested };
}

export async function myVolunteerStatus(fireId: number): Promise<"none" | "requested" | "confirmed"> {
  const session = await auth0.getSession();
  const u = session?.user;
  if (!u?.email) return "none";
  const local = (await db.select().from(users).where(eq(users.email, u.email)).limit(1))[0];
  if (!local) return "none";
  const row = await db
    .select({ status: fireVolunteers.status })
    .from(fireVolunteers)
    .where(and(eq(fireVolunteers.fireId, fireId), eq(fireVolunteers.userId, local.id)))
    .limit(1);
  if (!row[0]) return "none";
  return row[0].status as any;
}

// ----- Create Fire (creator -> confirmed volunteer) -----
export async function createFire(form: FormData) {
  const { local } = await ensureLocalUser();

  const lat = Number(form.get("lat"));
  const lng = Number(form.get("lng"));
  const radiusM = Math.round(Number(form.get("radiusM")));

  if (
    Number.isNaN(lat) ||
    Number.isNaN(lng) ||
    Number.isNaN(radiusM) ||
    lat < -90 ||
    lat > 90 ||
    lng < -180 ||
    lng > 180 ||
    radiusM < 50 ||
    radiusM > 20000
  ) {
    throw new Error("Invalid payload");
  }

  const [created] = await db
    .insert(fires)
    .values({
      lat,
      lng,
      radiusM,
      status: "active",
      createdBy: local.id,
      lastActivityAt: new Date(),
    })
    .returning();

  // creator becomes confirmed volunteer
  await db
    .insert(fireVolunteers)
    .values({
      fireId: created.id,
      userId: local.id,
      status: "confirmed",
    })
    .onConflictDoUpdate({
      target: [fireVolunteers.fireId, fireVolunteers.userId],
      set: { status: "confirmed", updatedAt: new Date() },
    });

  // Auto-join creator into Sendbird channel
  await ensureSendbirdJoined(created.id, local.id);

  revalidatePath("/fires");
  revalidatePath(`/fires/${created.id}`);
}

// ----- Claim volunteer (requested) -----
export async function claimVolunteer(form: FormData) {
  const { local } = await ensureLocalUser();
  const fireId = Number(form.get("fireId"));
  if (!Number.isFinite(fireId)) throw new Error("Invalid fireId");

  const existing = await db
    .select()
    .from(fireVolunteers)
    .where(and(eq(fireVolunteers.fireId, fireId), eq(fireVolunteers.userId, local.id)))
    .limit(1);

  if (existing.length === 0) {
    await db.insert(fireVolunteers).values({ fireId, userId: local.id, status: "requested" });
  } else if (existing[0].status !== "confirmed") {
    // keep requested; if already confirmed, no change
  }

  await touchFireActivity(fireId);

  revalidatePath(`/fires/${fireId}`);
  return { ok: true };
}

// ----- Approve another user (make confirmed) -----
export async function approveVolunteer(form: FormData) {
  const { local } = await ensureLocalUser();
  const fireId = Number(form.get("fireId"));
  const userId = Number(form.get("userId"));
  if (!Number.isFinite(fireId) || !Number.isFinite(userId)) throw new Error("Invalid payload");

  // Only confirmed volunteers can approve
  await requireConfirmedVolunteer(fireId, local.id);

  // Upsert -> confirmed
  await db
    .insert(fireVolunteers)
    .values({
      fireId,
      userId,
      status: "confirmed",
    })
    .onConflictDoUpdate({
      target: [fireVolunteers.fireId, fireVolunteers.userId],
      set: { status: "confirmed", updatedAt: new Date() },
    });

  // Auto-unblock if previously blocked in general chat
  const { chatBlocks } = await import("@/lib/db/schema");
  const { and, eq } = await import("drizzle-orm");
  await db.delete(chatBlocks).where(and(eq(chatBlocks.fireId, fireId), eq(chatBlocks.blockedUserId, userId)));

  // Auto-join approved user into Sendbird channel
  await ensureSendbirdJoined(fireId, userId);

  await touchFireActivity(fireId);
  revalidatePath(`/fires/${fireId}`);
  return { ok: true };
}

// ----- Generate join token (for QR) -----
export async function generateJoinToken(form: FormData) {
  const { local } = await ensureLocalUser();
  const fireId = Number(form.get("fireId"));
  if (!Number.isFinite(fireId)) throw new Error("Invalid fireId");

  await requireConfirmedVolunteer(fireId, local.id);

  const token = crypto.randomBytes(16).toString("base64url");
  const expiresAt = new Date(Date.now() + 1000 * 60 * 60 * 48); // 48h

  await db.insert(fireJoinTokens).values({
    fireId,
    token,
    createdBy: local.id,
    expiresAt,
  });

  return { ok: true, token, expiresAt: expiresAt.toISOString() };
}

// ----- Join with token (QR scan flow) -----
export async function joinWithToken(fireId: number, token: string) {
  if (!token || !Number.isFinite(fireId)) return { ok: false, error: "Invalid token." };

  const { local } = await ensureLocalUser();

  const now = new Date();
  const rows = await db
    .select()
    .from(fireJoinTokens)
    .where(
      and(
        eq(fireJoinTokens.fireId, fireId),
        eq(fireJoinTokens.token, token),
        isNull(fireJoinTokens.revokedAt),
        gt(fireJoinTokens.expiresAt, now),
      ),
    )
    .limit(1);

  if (rows.length === 0) {
    return { ok: false, error: "Невалиден или изтекъл токен." };
  }

  await db
    .insert(fireVolunteers)
    .values({
      fireId,
      userId: local.id,
      status: "confirmed",
    })
    .onConflictDoUpdate({
      target: [fireVolunteers.fireId, fireVolunteers.userId],
      set: { status: "confirmed", updatedAt: new Date() },
    });
  // record token use (best-effort)
  try {
    const tokenRow = rows[0];
    await db.insert(fireJoinTokenUses).values({ tokenId: tokenRow.id, userId: local.id });
  } catch {}

  // Auto-unblock in general chat upon becoming confirmed (best-effort)
  try {
    const { chatBlocks } = await import("@/lib/db/schema");
    const { and, eq } = await import("drizzle-orm");
    await db.delete(chatBlocks).where(and(eq(chatBlocks.fireId, fireId), eq(chatBlocks.blockedUserId, local.id)));
  } catch {}
  // Auto-join into Sendbird channel
  await ensureSendbirdJoined(fireId, local.id);
  await touchFireActivity(fireId);
  return { ok: true };
}

// ----- My inactive fires -----
export async function listMyInactiveFires() {
  const session = await auth0.getSession();
  const u = session?.user;
  if (!u?.email) return [] as any[];
  const [local] = await db.select().from(users).where(eq(users.email, u.email)).limit(1);
  if (!local) return [] as any[];
  const rows = await db
    .select()
    .from(fires)
    .where(eq(fires.status, 'inactive'))
    .orderBy(desc(fires.deactivatedAt), desc(fires.createdAt));
  // filter by confirmed membership
  const mine = await db
    .select({ fireId: fireVolunteers.fireId })
    .from(fireVolunteers)
    .where(and(eq(fireVolunteers.userId, local.id), eq(fireVolunteers.status, 'confirmed')));
  const mySet = new Set(mine.map((m) => m.fireId));
  return rows.filter((r) => mySet.has(r.id));
}
\n===== END FILE: app/actions/fires.ts =====\n
===== FILE: app/api/cron/route.ts =====
import { NextResponse } from 'next/server';
import { runNotificationsJob } from '@/lib/notifications/job';

export const runtime = 'nodejs';

export async function GET(req: Request) {
  const auth = req.headers.get('authorization');
  const expected = process.env.CRON_SECRET ? `Bearer ${process.env.CRON_SECRET}` : '';
  if (!process.env.CRON_SECRET || auth !== expected) {
    return new NextResponse('Unauthorized', { status: 401 });
  }

  const url = new URL(req.url);
  const onlyIdParam = url.searchParams.get('subscriptionId') || url.searchParams.get('id');
  const limitPerSourceParam = url.searchParams.get('limitPerSource');
  const onlySubscriptionId = onlyIdParam ? Number(onlyIdParam) : undefined;
  const limitPerSource = limitPerSourceParam ? Number(limitPerSourceParam) : undefined;

  const result = await runNotificationsJob({
    onlySubscriptionId,
    limitPerSource,
  });
  return NextResponse.json(result);
}
\n===== END FILE: app/api/cron/route.ts =====\n
===== FILE: app/api/fires/[id]/blocks/route.ts =====
import { NextResponse } from "next/server";
import { db } from "@/lib/db";
import { chatBlocks, fireVolunteers, users } from "@/lib/db/schema";
import { auth0 } from "@/lib/auth0";
import { and, eq } from "drizzle-orm";

export const runtime = "nodejs";

async function getLocalUser() {
  const session = await auth0.getSession();
  if (!session?.user?.email) return null;
  const email = session.user.email;
  const rows = await db.select().from(users).where(eq(users.email, email)).limit(1);
  if (rows.length) return rows[0];
  const [created] = await db.insert(users).values({ email, name: session.user.name ?? null }).returning();
  return created;
}

async function requireConfirmedVolunteer(fireId: number, userId: number) {
  const rows = await db
    .select()
    .from(fireVolunteers)
    .where(and(eq(fireVolunteers.fireId, fireId), eq(fireVolunteers.userId, userId), eq(fireVolunteers.status, "confirmed")))
    .limit(1);
  if (!rows.length) throw new Error("Forbidden");
}

export async function GET(_req: Request, { params }: { params: Promise<{ id: string }> }) {
  const { id } = await params;
  const fireId = Number(id);
  const list = await db.select().from(chatBlocks).where(eq(chatBlocks.fireId, fireId));
  return NextResponse.json({ ok: true, blocks: list });
}

export async function POST(req: Request, { params }: { params: Promise<{ id: string }> }) {
  try {
    const { id } = await params;
    const fireId = Number(id);
    const me = await getLocalUser();
    if (!me) return NextResponse.json({ ok: false, error: "Unauthorized" }, { status: 401 });

    await requireConfirmedVolunteer(fireId, me.id);

    const { blockedUserId } = (await req.json().catch(() => ({}))) as { blockedUserId?: number };
    if (!Number.isFinite(blockedUserId))
      return NextResponse.json({ ok: false, error: "Invalid payload" }, { status: 400 });

    // Do not allow blocking confirmed volunteers
    const alreadyConfirmed = await db
      .select()
      .from(fireVolunteers)
      .where(and(eq(fireVolunteers.fireId, fireId), eq(fireVolunteers.userId, Number(blockedUserId)), eq(fireVolunteers.status, "confirmed")))
      .limit(1);
    if (alreadyConfirmed.length) {
      return NextResponse.json({ ok: false, error: "Cannot block confirmed volunteer" }, { status: 400 });
    }

    await db
      .insert(chatBlocks)
      .values({ fireId, blockedUserId: Number(blockedUserId), blockedByUserId: me.id })
      .onConflictDoNothing();

    return NextResponse.json({ ok: true });
  } catch (e: any) {
    const msg = e?.message || "Error";
    const status = msg === "Forbidden" ? 403 : 500;
    return NextResponse.json({ ok: false, error: msg }, { status });
  }
}

export async function DELETE(req: Request, { params }: { params: Promise<{ id: string }> }) {
  try {
    const { searchParams } = new URL(req.url);
    const uid = Number(searchParams.get("userId"));
    const { id } = await params;
    const fireId = Number(id);
    const me = await getLocalUser();
    if (!me) return NextResponse.json({ ok: false, error: "Unauthorized" }, { status: 401 });
    await requireConfirmedVolunteer(fireId, me.id);

    await db.delete(chatBlocks).where(and(eq(chatBlocks.fireId, fireId), eq(chatBlocks.blockedUserId, uid)));
    return NextResponse.json({ ok: true });
  } catch (e: any) {
    const msg = e?.message || "Error";
    const status = msg === "Forbidden" ? 403 : 500;
    return NextResponse.json({ ok: false, error: msg }, { status });
  }
}
\n===== END FILE: app/api/fires/[id]/blocks/route.ts =====\n
===== FILE: app/api/fires/[id]/chat/connect/route.ts =====
import { NextResponse } from "next/server";
import { auth0 } from "@/lib/auth0";
import { db } from "@/lib/db";
import { users } from "@/lib/db/schema";
import { eq } from "drizzle-orm";
import { ensureSbUser, fireChannelUrl, getOrCreateFireChannel, inviteUserToChannel, joinUserToChannel } from "@/lib/sendbird";

export const runtime = "nodejs";

async function getLocalUser() {
  const session = await auth0.getSession();
  const email = session?.user?.email;
  if (!email) return null;
  const [row] = await db.select().from(users).where(eq(users.email, email)).limit(1);
  if (row) return row;
  const [created] = await db.insert(users).values({ email, name: session?.user?.name ?? null }).returning();
  return created;
}

export async function GET(_req: Request, { params }: { params: Promise<{ id: string }> }) {
  try {
    const { id } = await params;
    const fireId = Number(id);
    if (!Number.isFinite(fireId)) return NextResponse.json({ ok: false, error: "Invalid fire id" }, { status: 400 });

    const me = await getLocalUser();
    if (!me) return NextResponse.json({ ok: false, error: "Unauthorized" }, { status: 401 });

    const sbUserId = `user-${me.id}`;
    const sbUser = await ensureSbUser(sbUserId, me.name || me.email);
    const channelUrl = await getOrCreateFireChannel(fireId);
    // Invite to keep the original flow, then auto-join
    await inviteUserToChannel(channelUrl, sbUserId);
    await joinUserToChannel(channelUrl, sbUserId);

    return NextResponse.json({
      ok: true,
      appId: process.env.NEXT_PUBLIC_SENDBIRD_APP_ID,
      userId: sbUser.user_id,
      nickname: me.name || me.email,
      accessToken: sbUser.access_token || null,
      channelUrl,
    });
  } catch (e: any) {
    console.error("[sendbird/connect]", e);
    return NextResponse.json({ ok: false, error: e?.message || "Server error" }, { status: 500 });
  }
}
\n===== END FILE: app/api/fires/[id]/chat/connect/route.ts =====\n
===== FILE: app/api/fires/[id]/chat/route.ts =====
import { NextResponse } from "next/server";
import { db } from "@/lib/db";
import { chatBlocks, chatMessages, users, fireVolunteers } from "@/lib/db/schema";
import { auth0 } from "@/lib/auth0";
import { and, desc, eq, isNull, notInArray, sql } from "drizzle-orm";

export const runtime = "nodejs";

async function ensureUser() {
  const session = await auth0.getSession();
  if (!session?.user?.email) return null;
  const email = session.user.email;
  const rows = await db.select().from(users).where(eq(users.email, email)).limit(1);
  if (rows.length) return rows[0];
  const [created] = await db.insert(users).values({ email, name: session.user.name ?? null }).returning();
  return created;
}

export async function GET(_req: Request, { params }: { params: Promise<{ id: string }> }) {
  const { id } = await params;
  const fireId = Number(id);
  const limit = 150;

  const blockedUsers = await db
    .select({ uid: chatBlocks.blockedUserId })
    .from(chatBlocks)
    .leftJoin(
      fireVolunteers,
      and(
        eq(fireVolunteers.fireId, fireId),
        eq(fireVolunteers.userId, chatBlocks.blockedUserId),
        eq(fireVolunteers.status, "confirmed"),
      ),
    )
    .where(and(eq(chatBlocks.fireId, fireId), isNull(fireVolunteers.id)) as any);

  const exclude = blockedUsers.map((b) => b.uid);
  const rows = await db
    .select({
      id: chatMessages.id,
      userId: chatMessages.userId,
      message: chatMessages.message,
      createdAt: chatMessages.createdAt,
      name: users.name,
      email: users.email,
    })
    .from(chatMessages)
    .leftJoin(users, eq(users.id, chatMessages.userId))
    .where(
      and(
        eq(chatMessages.fireId, fireId),
        isNull(chatMessages.zoneId),
        isNull(chatMessages.deletedAt),
        exclude.length ? notInArray(chatMessages.userId, exclude) : sql`true`,
      ),
    )
    .orderBy(desc(chatMessages.createdAt))
    .limit(limit);

  return NextResponse.json({ ok: true, messages: rows.reverse() });
}

export async function POST(req: Request, { params }: { params: Promise<{ id: string }> }) {
  const { id } = await params;
  const fireId = Number(id);
  const me = await ensureUser();
  if (!me) return NextResponse.json({ ok: false, error: "Unauthorized" }, { status: 401 });

  const stillBlocked = await db
    .select()
    .from(chatBlocks)
    .leftJoin(
      fireVolunteers,
      and(
        eq(fireVolunteers.fireId, fireId),
        eq(fireVolunteers.userId, chatBlocks.blockedUserId),
        eq(fireVolunteers.status, "confirmed"),
      ),
    )
    .where(and(eq(chatBlocks.fireId, fireId), eq(chatBlocks.blockedUserId, me.id), isNull(fireVolunteers.id)) as any)
    .limit(1);
  if (stillBlocked.length) return NextResponse.json({ ok: false, error: "Blocked in this chat" }, { status: 403 });

  const { message } = (await req.json().catch(() => ({}))) as { message?: string };
  const body = String(message || "").trim().slice(0, 4000);
  if (!body) return NextResponse.json({ ok: false, error: "Empty message" }, { status: 400 });

  const [created] = await db.insert(chatMessages).values({ fireId, userId: me.id, message: body }).returning();

  return NextResponse.json({ ok: true, message: { id: created.id } });
}
\n===== END FILE: app/api/fires/[id]/chat/route.ts =====\n
===== FILE: app/api/fires/[id]/deactivate/route.ts =====
import { NextResponse } from "next/server";
import { auth0 } from "@/lib/auth0";
import { db } from "@/lib/db";
import { users, fires, fireVolunteers, fireDeactivationVotes } from "@/lib/db/schema";
import { and, count, desc, eq, sql } from "drizzle-orm";

export const runtime = "nodejs";

async function getLocalUser() {
  const session = await auth0.getSession();
  const email = session?.user?.email;
  if (!email) return null;
  const [row] = await db.select().from(users).where(eq(users.email, email)).limit(1);
  if (row) return row;
  const [created] = await db.insert(users).values({ email, name: session?.user?.name ?? null }).returning();
  return created;
}

function percentThreshold(total: number) {
  const pct = Number(process.env.FIRE_DEACTIVATION_PERCENT || 0.5);
  const minVotes = Number(process.env.FIRE_DEACTIVATION_MIN_VOTES || 2);
  const required = Math.max(minVotes, Math.ceil(total * (Number.isFinite(pct) ? pct : 0.5)));
  return required;
}

export async function GET(_req: Request, { params }: { params: Promise<{ id: string }> }) {
  try {
    const { id } = await params;
    const fireId = Number(id);
    if (!Number.isFinite(fireId)) return NextResponse.json({ ok: false, error: "Invalid id" }, { status: 400 });

    const [fire] = await db.select().from(fires).where(eq(fires.id, fireId)).limit(1);
    if (!fire) return NextResponse.json({ ok: false, error: "Not found" }, { status: 404 });

    const me = await getLocalUser();

    const totalConfirmedRow = await db
      .select({ c: sql<number>`count(*)::int` })
      .from(fireVolunteers)
      .where(and(eq(fireVolunteers.fireId, fireId), eq(fireVolunteers.status, 'confirmed')))
      .limit(1);
    const totalConfirmed = totalConfirmedRow[0]?.c ?? 0;

    const votesRow = await db
      .select({ c: sql<number>`count(*)::int` })
      .from(fireDeactivationVotes)
      .where(eq(fireDeactivationVotes.fireId, fireId))
      .limit(1);
    const votes = votesRow[0]?.c ?? 0;

    let hasVoted = false;
    if (me) {
      const hv = await db
        .select({ c: sql<number>`count(*)::int` })
        .from(fireDeactivationVotes)
        .where(and(eq(fireDeactivationVotes.fireId, fireId), eq(fireDeactivationVotes.userId, me.id)))
        .limit(1);
      hasVoted = (hv[0]?.c ?? 0) > 0;
    }

    const required = percentThreshold(totalConfirmed);
    return NextResponse.json({ ok: true, status: fire.status, votes, required, totalConfirmed, hasVoted });
  } catch (e: any) {
    return NextResponse.json({ ok: false, error: e?.message || "Error" }, { status: 500 });
  }
}

export async function POST(_req: Request, { params }: { params: Promise<{ id: string }> }) {
  try {
    const { id } = await params;
    const fireId = Number(id);
    if (!Number.isFinite(fireId)) return NextResponse.json({ ok: false, error: "Invalid id" }, { status: 400 });

    const me = await getLocalUser();
    if (!me) return NextResponse.json({ ok: false, error: "Unauthorized" }, { status: 401 });

    const [fire] = await db.select().from(fires).where(eq(fires.id, fireId)).limit(1);
    if (!fire) return NextResponse.json({ ok: false, error: "Not found" }, { status: 404 });
    if (fire.status !== 'active') return NextResponse.json({ ok: true, status: fire.status, votes: 0, required: 0 });

    // Must be confirmed volunteer to vote
    const v = await db
      .select()
      .from(fireVolunteers)
      .where(and(eq(fireVolunteers.fireId, fireId), eq(fireVolunteers.userId, me.id), eq(fireVolunteers.status, 'confirmed')))
      .limit(1);
    if (!v.length) return NextResponse.json({ ok: false, error: "Forbidden" }, { status: 403 });

    // Upsert vote
    await db
      .insert(fireDeactivationVotes)
      .values({ fireId, userId: me.id })
      .onConflictDoNothing();

    // Count votes and total confirmed
    const totalConfirmedRow = await db
      .select({ c: sql<number>`count(*)::int` })
      .from(fireVolunteers)
      .where(and(eq(fireVolunteers.fireId, fireId), eq(fireVolunteers.status, 'confirmed')))
      .limit(1);
    const totalConfirmed = totalConfirmedRow[0]?.c ?? 0;

    const votesRow = await db
      .select({ c: sql<number>`count(*)::int` })
      .from(fireDeactivationVotes)
      .where(eq(fireDeactivationVotes.fireId, fireId))
      .limit(1);
    const votes = votesRow[0]?.c ?? 0;

    const required = percentThreshold(totalConfirmed);

    if (votes >= required && totalConfirmed > 0) {
      await db.update(fires).set({ status: 'inactive', deactivatedAt: new Date(), updatedAt: new Date() }).where(eq(fires.id, fireId));
    }

    return NextResponse.json({ ok: true, votes, required });
  } catch (e: any) {
    return NextResponse.json({ ok: false, error: e?.message || "Error" }, { status: 500 });
  }
}

\n===== END FILE: app/api/fires/[id]/deactivate/route.ts =====\n
===== FILE: app/api/fires/[id]/stats/route.ts =====
import { NextResponse } from "next/server";
import { db } from "@/lib/db";
import { fireVolunteers, zones, zoneMembers, chatMessages, fireJoinTokens, fireJoinTokenUses } from "@/lib/db/schema";
import { and, eq, sql, gte } from "drizzle-orm";

export const runtime = "nodejs";

export async function GET(_req: Request, { params }: { params: Promise<{ id: string }> }) {
  const { id } = await params;
  const fireId = Number(id);

  const counts = await db
    .select({
      confirmed: sql<number>`sum(case when ${fireVolunteers.status} = 'confirmed' then 1 else 0 end)`,
      requested: sql<number>`sum(case when ${fireVolunteers.status} = 'requested' then 1 else 0 end)`,
    })
    .from(fireVolunteers)
    .where(eq(fireVolunteers.fireId, fireId));

  const zonesCount = await db.select({ n: sql<number>`count(*)` }).from(zones).where(eq(zones.fireId, fireId));

  const perZone = await db
    .select({ zoneId: zoneMembers.zoneId, members: sql<number>`count(*)` })
    .from(zoneMembers)
    .where(eq(zoneMembers.fireId, fireId))
    .groupBy(zoneMembers.zoneId);

  const now = new Date();
  const hourAgo = new Date(now.getTime() - 60 * 60 * 1000);
  const dayAgo = new Date(now.getTime() - 24 * 60 * 60 * 1000);

  const totalMessages = await db
    .select({ n: sql<number>`count(*)` })
    .from(chatMessages)
    .where(eq(chatMessages.fireId, fireId));

  const lastHour = await db
    .select({ n: sql<number>`count(*)` })
    .from(chatMessages)
    .where(and(eq(chatMessages.fireId, fireId), gte(chatMessages.createdAt, hourAgo)));

  const lastDay = await db
    .select({ n: sql<number>`count(*)` })
    .from(chatMessages)
    .where(and(eq(chatMessages.fireId, fireId), gte(chatMessages.createdAt, dayAgo)));

  const qrIssued = await db
    .select({ n: sql<number>`count(*)` })
    .from(fireJoinTokens)
    .where(eq(fireJoinTokens.fireId, fireId));
  const qrUsed = await db
    .select({ n: sql<number>`count(*)` })
    .from(fireJoinTokenUses)
    .where(eq(fireJoinTokenUses.tokenId, sql<number>`any(SELECT id FROM fire_join_tokens WHERE fire_id = ${fireId})` as any));

  return NextResponse.json({
    ok: true,
    stats: {
      volunteers: {
        confirmed: Number(counts[0]?.confirmed || 0),
        requested: Number(counts[0]?.requested || 0),
      },
      zones: {
        count: Number(zonesCount[0]?.n || 0),
        membersPerZone: perZone.map((r) => ({ zoneId: r.zoneId, members: Number(r.members || 0) })),
      },
      chat: {
        total: Number(totalMessages[0]?.n || 0),
        lastHour: Number(lastHour[0]?.n || 0),
        lastDay: Number(lastDay[0]?.n || 0),
      },
      qr: {
        issued: Number(qrIssued[0]?.n || 0),
        used: Number(qrUsed[0]?.n || 0),
      },
    },
  });
}

\n===== END FILE: app/api/fires/[id]/stats/route.ts =====\n
===== FILE: app/api/fires/[id]/zones/[zoneId]/chat/connect/route.ts =====
import { NextResponse } from "next/server";
import { auth0 } from "@/lib/auth0";
import { db } from "@/lib/db";
import { users, zoneMembers, zones } from "@/lib/db/schema";
import { and, eq } from "drizzle-orm";
import { ensureSbUser, getOrCreateZoneChannel, joinUserToChannel } from "@/lib/sendbird";

export const runtime = "nodejs";

async function getLocalUser() {
  const session = await auth0.getSession();
  if (!session?.user?.email) return null;
  const email = session.user.email;
  const rows = await db.select().from(users).where(eq(users.email, email)).limit(1);
  if (rows.length) return rows[0];
  const [created] = await db.insert(users).values({ email, name: session.user.name ?? null }).returning();
  return created;
}

export async function GET(_req: Request, { params }: { params: Promise<{ id: string; zoneId: string }> }) {
  try {
    const { id, zoneId } = await params;
    const fireId = Number(id);
    const z = Number(zoneId);

    const me = await getLocalUser();
    if (!me) return NextResponse.json({ ok: false, error: "Unauthorized" }, { status: 401 });

    // Require that user is a member of some zone in this fire and that it matches z
    const membership = await db.select().from(zoneMembers).where(and(eq(zoneMembers.fireId, fireId), eq(zoneMembers.userId, me.id))).limit(1);
    if (!membership.length || membership[0].zoneId !== z) {
      return NextResponse.json({ ok: false, error: "Not a member of this zone" }, { status: 403 });
    }

    // Resolve zone title
    const zr = await db.select().from(zones).where(and(eq(zones.id, z), eq(zones.fireId, fireId))).limit(1);
    const zoneTitle = zr[0]?.title ?? null;

    const sbUserId = `user-${me.id}`;
    const sbUser = await ensureSbUser(sbUserId, me.name || me.email);
    const channelUrl = await getOrCreateZoneChannel(fireId, z, zoneTitle);
    await joinUserToChannel(channelUrl, sbUserId);

    return NextResponse.json({
      ok: true,
      appId: process.env.NEXT_PUBLIC_SENDBIRD_APP_ID,
      userId: sbUser.user_id,
      nickname: me.name || me.email,
      accessToken: sbUser.access_token || null,
      channelUrl,
    });
  } catch (e: any) {
    console.error("[sendbird/zone-connect]", e);
    return NextResponse.json({ ok: false, error: e?.message || "Server error" }, { status: 500 });
  }
}

\n===== END FILE: app/api/fires/[id]/zones/[zoneId]/chat/connect/route.ts =====\n
===== FILE: app/api/fires/[id]/zones/[zoneId]/chat/route.ts =====
import { NextResponse } from "next/server";
import { db } from "@/lib/db";
import { chatMessages, users, zoneMembers, fires, fireDeactivationVotes } from "@/lib/db/schema";
import { auth0 } from "@/lib/auth0";
import { and, desc, eq, isNull } from "drizzle-orm";

export const runtime = "nodejs";

async function ensureUser() {
  const session = await auth0.getSession();
  if (!session?.user?.email) return null;
  const email = session.user.email;
  const rows = await db.select().from(users).where(eq(users.email, email)).limit(1);
  if (rows.length) return rows[0];
  const [created] = await db.insert(users).values({ email, name: session.user.name ?? null }).returning();
  return created;
}

async function requireZoneMember(fireId: number, zoneId: number, userId: number) {
  const rows = await db
    .select()
    .from(zoneMembers)
    .where(and(eq(zoneMembers.fireId, fireId), eq(zoneMembers.zoneId, zoneId), eq(zoneMembers.userId, userId)))
    .limit(1);
  if (!rows.length) throw new Error("Forbidden");
}

export async function GET(_req: Request, { params }: { params: Promise<{ id: string; zoneId: string }> }) {
  const { id, zoneId } = await params;
  const fireId = Number(id);
  const z = Number(zoneId);
  const limit = 150;

  const me = await ensureUser();
  if (!me) return NextResponse.json({ ok: false, error: "Unauthorized" }, { status: 401 });
  await requireZoneMember(fireId, z, me.id);

  const rows = await db
    .select({
      id: chatMessages.id,
      userId: chatMessages.userId,
      message: chatMessages.message,
      createdAt: chatMessages.createdAt,
      name: users.name,
      email: users.email,
    })
    .from(chatMessages)
    .leftJoin(users, eq(users.id, chatMessages.userId))
    .where(and(eq(chatMessages.fireId, fireId), eq(chatMessages.zoneId, z), isNull(chatMessages.deletedAt)))
    .orderBy(desc(chatMessages.createdAt))
    .limit(limit);

  return NextResponse.json({ ok: true, messages: rows.reverse() });
}

export async function POST(req: Request, { params }: { params: Promise<{ id: string; zoneId: string }> }) {
  const { id, zoneId } = await params;
  const fireId = Number(id);
  const z = Number(zoneId);

  const me = await ensureUser();
  if (!me) return NextResponse.json({ ok: false, error: "Unauthorized" }, { status: 401 });
  try {
    await requireZoneMember(fireId, z, me.id);
  } catch {
    return NextResponse.json({ ok: false, error: "Forbidden" }, { status: 403 });
  }

  const { message } = (await req.json().catch(() => ({}))) as { message?: string };
  const body = String(message || "").trim().slice(0, 4000);
  if (!body) return NextResponse.json({ ok: false, error: "Empty message" }, { status: 400 });

  const [created] = await db.insert(chatMessages).values({ fireId, zoneId: z, userId: me.id, message: body }).returning();
  try {
    await db.update(fires).set({ lastActivityAt: new Date(), updatedAt: new Date(), status: 'active', deactivatedAt: null }).where(eq(fires.id, fireId));
    await db.delete(fireDeactivationVotes).where(eq(fireDeactivationVotes.fireId, fireId));
  } catch {}
  return NextResponse.json({ ok: true, message: { id: created.id } });
}
\n===== END FILE: app/api/fires/[id]/zones/[zoneId]/chat/route.ts =====\n
===== FILE: app/api/fires/[id]/zones/[zoneId]/join/route.ts =====
import { NextResponse } from "next/server";
import { db } from "@/lib/db";
import { zones, zoneMembers, users, fireVolunteers, fires, fireDeactivationVotes } from "@/lib/db/schema";
import { ensureSbUser, getOrCreateZoneChannel, joinUserToChannel } from "@/lib/sendbird";
import { auth0 } from "@/lib/auth0";
import { and, eq } from "drizzle-orm";

export const runtime = "nodejs";

async function getLocalUser() {
  const session = await auth0.getSession();
  if (!session?.user?.email) return null;
  const email = session.user.email;
  const rows = await db.select().from(users).where(eq(users.email, email)).limit(1);
  if (rows.length) return rows[0];
  const [created] = await db.insert(users).values({ email, name: session.user.name ?? null }).returning();
  return created;
}
async function requireConfirmedVolunteer(fireId: number, userId: number) {
  const rows = await db
    .select()
    .from(fireVolunteers)
    .where(and(eq(fireVolunteers.fireId, fireId), eq(fireVolunteers.userId, userId), eq(fireVolunteers.status, "confirmed")))
    .limit(1);
  if (!rows.length) throw new Error("Forbidden");
}

export async function POST(req: Request, { params }: { params: Promise<{ id: string; zoneId: string }> }) {
  try {
    const { id, zoneId } = await params;
    const fireId = Number(id);
    const z = Number(zoneId);
    const { action } = (await req.json().catch(() => ({}))) as { action?: "join" | "leave" };

    const me = await getLocalUser();
    if (!me) return NextResponse.json({ ok: false, error: "Unauthorized" }, { status: 401 });

    await requireConfirmedVolunteer(fireId, me.id);

    const exists = await db.select().from(zones).where(and(eq(zones.id, z), eq(zones.fireId, fireId))).limit(1);
    if (!exists.length && action !== "leave")
      return NextResponse.json({ ok: false, error: "Zone not found" }, { status: 404 });

    if (action === "leave") {
      await db.delete(zoneMembers).where(and(eq(zoneMembers.fireId, fireId), eq(zoneMembers.userId, me.id)));
      return NextResponse.json({ ok: true });
    }

    await db
      .insert(zoneMembers)
      .values({ zoneId: z, fireId, userId: me.id })
      .onConflictDoUpdate({
        target: [zoneMembers.fireId, zoneMembers.userId],
        set: { zoneId: z },
      });

    try {
      await db.update(fires).set({ lastActivityAt: new Date(), updatedAt: new Date(), status: 'active', deactivatedAt: null }).where(eq(fires.id, fireId));
      await db.delete(fireDeactivationVotes).where(eq(fireDeactivationVotes.fireId, fireId));
    } catch {}

    // Auto-join Sendbird zone channel (best-effort)
    try {
      const sbUid = `user-${me.id}`;
      await ensureSbUser(sbUid, me.name || me.email);
      const channelUrl = await getOrCreateZoneChannel(fireId, z, exists[0]?.title ?? null);
      await joinUserToChannel(channelUrl, sbUid);
    } catch (e) {
      console.warn("[sendbird] auto-join zone failed", (e as any)?.message);
    }

    return NextResponse.json({ ok: true });
  } catch (e: any) {
    const msg = e?.message || "Error";
    const status = msg === "Forbidden" ? 403 : 500;
    return NextResponse.json({ ok: false, error: msg }, { status });
  }
}
\n===== END FILE: app/api/fires/[id]/zones/[zoneId]/join/route.ts =====\n
===== FILE: app/api/fires/[id]/zones/[zoneId]/route.ts =====
import { NextResponse } from "next/server";
import { db } from "@/lib/db";
import {
  zones,
  zoneMembers,
  zoneGalleryImages,
  zoneUpdates,
  zoneUpdateImages,
  users,
  fireVolunteers,
} from "@/lib/db/schema";
import { and, desc, eq, inArray } from "drizzle-orm";
import { auth0 } from "@/lib/auth0";

export const runtime = "nodejs";

export async function GET(_req: Request, { params }: { params: Promise<{ id: string; zoneId: string }> }) {
  const { id, zoneId } = await params;
  const fireId = Number(id);
  const z = Number(zoneId);

  const zone = await db.select().from(zones).where(and(eq(zones.id, z), eq(zones.fireId, fireId))).limit(1);
  if (!zone.length) return NextResponse.json({ ok: false, error: "Zone not found" }, { status: 404 });

  const members = await db
    .select({
      userId: zoneMembers.userId,
      name: users.name,
      email: users.email,
      joinedAt: zoneMembers.createdAt,
    })
    .from(zoneMembers)
    .leftJoin(users, eq(users.id, zoneMembers.userId))
    .where(and(eq(zoneMembers.zoneId, z)));

  // Single cover image (most recent uploaded)
  const coverRow = await db
    .select({ url: zoneGalleryImages.url })
    .from(zoneGalleryImages)
    .where(eq(zoneGalleryImages.zoneId, z))
    .orderBy(desc(zoneGalleryImages.createdAt))
    .limit(1);

  const updates = await db
    .select({
      id: zoneUpdates.id,
      text: zoneUpdates.text,
      createdAt: zoneUpdates.createdAt,
      userId: zoneUpdates.userId,
      name: users.name,
      email: users.email,
    })
    .from(zoneUpdates)
    .leftJoin(users, eq(users.id, zoneUpdates.userId))
    .where(eq(zoneUpdates.zoneId, z))
    .orderBy(desc(zoneUpdates.createdAt))
    .limit(50);

  const updIds = updates.map((u) => u.id);
  const imagesMap: Record<number, any[]> = {};
  if (updIds.length) {
    const rows = await db.select().from(zoneUpdateImages).where(inArray(zoneUpdateImages.updateId, updIds));
    for (const r of rows) {
      (imagesMap[(r as any).updateId] ||= []).push(r);
    }
  }

  // Determine viewer's membership for this fire (if logged in)
  let myZoneId: number | null = null;
  let viewerUserId: number | null = null;
  try {
    const session = await auth0.getSession();
    const email = session?.user?.email;
    if (email) {
      const u = await db.select().from(users).where(eq(users.email, email)).limit(1);
      const me = u[0];
      if (me) {
        viewerUserId = me.id;
        const row = await db
          .select({ zoneId: zoneMembers.zoneId })
          .from(zoneMembers)
          .where(and(eq(zoneMembers.fireId, fireId), eq(zoneMembers.userId, me.id)))
          .limit(1);
        myZoneId = row[0]?.zoneId ?? null;
      }
    }
  } catch {}

  return NextResponse.json({
    ok: true,
    zone: zone[0],
    members,
    coverUrl: coverRow[0]?.url || null,
    updates: updates.map((u) => ({ ...u, images: imagesMap[u.id] || [] })),
    myZoneId,
    isMember: myZoneId != null && myZoneId === z,
    viewerUserId,
  });
}

export async function PATCH(req: Request, { params }: { params: Promise<{ id: string; zoneId: string }> }) {
  const { id, zoneId } = await params;
  const fireId = Number(id);
  const z = Number(zoneId);

  const body = (await req.json().catch(() => ({}))) as any;
  const { addGalleryImage, setCoverImage, title, description } = body || {};

  // Update zone metadata (title/description)
  if (title !== undefined || description !== undefined) {
    const session = await auth0.getSession();
    const email = session?.user?.email;
    if (!email) return NextResponse.json({ ok: false, error: "Unauthorized" }, { status: 401 });
    const u = await db.select().from(users).where(eq(users.email, email)).limit(1);
    const me = u[0];
    if (!me) return NextResponse.json({ ok: false, error: "Unauthorized" }, { status: 401 });
    const row = await db
      .select()
      .from(fireVolunteers)
      .where(and(eq(fireVolunteers.fireId, fireId), eq(fireVolunteers.userId, me.id), eq(fireVolunteers.status, "confirmed")))
      .limit(1);
    if (!row.length) return NextResponse.json({ ok: false, error: "Forbidden" }, { status: 403 });

    const newTitle = (title ?? "").toString().trim().slice(0, 120) || null;
    const newDesc = (description ?? "").toString().trim().slice(0, 4000) || null;
    await db
      .update(zones)
      .set({ title: newTitle, description: newDesc, updatedAt: new Date() })
      .where(and(eq(zones.id, z), eq(zones.fireId, fireId)));
    return NextResponse.json({ ok: true });
  }

  // Add gallery image
  if (setCoverImage?.url && setCoverImage?.key) {
    const session = await auth0.getSession();
    const email = session?.user?.email;
    if (!email) return NextResponse.json({ ok: false, error: "Unauthorized" }, { status: 401 });
    const u = await db.select().from(users).where(eq(users.email, email)).limit(1);
    const me = u[0];
    if (!me) return NextResponse.json({ ok: false, error: "Unauthorized" }, { status: 401 });
    const row = await db
      .select()
      .from(fireVolunteers)
      .where(and(eq(fireVolunteers.fireId, fireId), eq(fireVolunteers.userId, me.id), eq(fireVolunteers.status, "confirmed")))
      .limit(1);
    if (!row.length) return NextResponse.json({ ok: false, error: "Forbidden" }, { status: 403 });
    // Insert new cover image record (most recent is used as cover)
    await db
      .insert(zoneGalleryImages)
      .values({ zoneId: z, userId: me.id, s3Key: setCoverImage.key, url: setCoverImage.url });
    return NextResponse.json({ ok: true });
  }

  // Backward compatibility: treat addGalleryImage as setting cover
  if (addGalleryImage?.url && addGalleryImage?.key) {
    const session = await auth0.getSession();
    const email = session?.user?.email;
    if (!email) return NextResponse.json({ ok: false, error: "Unauthorized" }, { status: 401 });
    const u = await db.select().from(users).where(eq(users.email, email)).limit(1);
    const me = u[0];
    if (!me) return NextResponse.json({ ok: false, error: "Unauthorized" }, { status: 401 });
    const row = await db
      .select()
      .from(fireVolunteers)
      .where(and(eq(fireVolunteers.fireId, fireId), eq(fireVolunteers.userId, me.id), eq(fireVolunteers.status, "confirmed")))
      .limit(1);
    if (!row.length) return NextResponse.json({ ok: false, error: "Forbidden" }, { status: 403 });
    await db
      .insert(zoneGalleryImages)
      .values({ zoneId: z, userId: me.id, s3Key: addGalleryImage.key, url: addGalleryImage.url });
    return NextResponse.json({ ok: true });
  }

  return NextResponse.json({ ok: false, error: "No-op" }, { status: 400 });
}
\n===== END FILE: app/api/fires/[id]/zones/[zoneId]/route.ts =====\n
===== FILE: app/api/fires/[id]/zones/[zoneId]/updates/[updateId]/route.ts =====
import { NextResponse } from "next/server";
import { db } from "@/lib/db";
import { users, zoneUpdates, zoneUpdateImages } from "@/lib/db/schema";
import { and, eq, inArray } from "drizzle-orm";
import { auth0 } from "@/lib/auth0";

export const runtime = "nodejs";

async function getMe() {
  const session = await auth0.getSession();
  const email = session?.user?.email;
  if (!email) return null;
  const u = await db.select().from(users).where(eq(users.email, email)).limit(1);
  return u[0] ?? null;
}

export async function PATCH(req: Request, { params }: { params: Promise<{ id: string; zoneId: string; updateId: string }> }) {
  try {
    const { id, zoneId, updateId } = await params;
    const fireId = Number(id); // not used directly but part of path
    const z = Number(zoneId);
    const uId = Number(updateId);
    if (!Number.isFinite(fireId) || !Number.isFinite(z) || !Number.isFinite(uId)) {
      return NextResponse.json({ ok: false, error: "Invalid params" }, { status: 400 });
    }

    const me = await getMe();
    if (!me) return NextResponse.json({ ok: false, error: "Unauthorized" }, { status: 401 });

    const row = await db.select().from(zoneUpdates).where(and(eq(zoneUpdates.id, uId), eq(zoneUpdates.zoneId, z))).limit(1);
    if (!row.length) return NextResponse.json({ ok: false, error: "Not found" }, { status: 404 });
    if (row[0].userId !== me.id) return NextResponse.json({ ok: false, error: "Forbidden" }, { status: 403 });

    const body = (await req.json().catch(() => ({}))) as {
      text?: string | null;
      addImages?: { key: string; url: string; width?: number; height?: number }[];
      removeImageIds?: number[];
    };

    if (typeof body.text === "string") {
      await db.update(zoneUpdates).set({ text: body.text.trim() }).where(eq(zoneUpdates.id, uId));
    }

    if (Array.isArray(body.removeImageIds) && body.removeImageIds.length) {
      await db.delete(zoneUpdateImages).where(and(eq(zoneUpdateImages.updateId, uId), inArray(zoneUpdateImages.id, body.removeImageIds.slice(0, 100))));
    }

    if (Array.isArray(body.addImages) && body.addImages.length) {
      await db.insert(zoneUpdateImages).values(
        body.addImages.slice(0, 12).map((im) => ({ updateId: uId, s3Key: im.key, url: im.url, width: im.width ?? null, height: im.height ?? null }))
      );
    }

    return NextResponse.json({ ok: true });
  } catch (e: any) {
    const msg = e?.message || "Error";
    const status = msg === "Forbidden" ? 403 : 500;
    return NextResponse.json({ ok: false, error: msg }, { status });
  }
}

\n===== END FILE: app/api/fires/[id]/zones/[zoneId]/updates/[updateId]/route.ts =====\n
===== FILE: app/api/fires/[id]/zones/[zoneId]/updates/route.ts =====
import { NextResponse } from "next/server";
import { db } from "@/lib/db";
import { users, fireVolunteers, zoneMembers, zones, zoneUpdates, zoneUpdateImages, fires, fireDeactivationVotes } from "@/lib/db/schema";
import { and, eq } from "drizzle-orm";
import { auth0 } from "@/lib/auth0";

export const runtime = "nodejs";

async function getMe() {
  const session = await auth0.getSession();
  const email = session?.user?.email;
  if (!email) return null;
  const u = await db.select().from(users).where(eq(users.email, email)).limit(1);
  return u[0] ?? null;
}

async function ensureConfirmedVolunteerInZone(fireId: number, zoneId: number, userId: number) {
  const v = await db
    .select()
    .from(fireVolunteers)
    .where(and(eq(fireVolunteers.fireId, fireId), eq(fireVolunteers.userId, userId), eq(fireVolunteers.status, "confirmed")))
    .limit(1);
  if (!v.length) throw new Error("Forbidden");
  // must also be a member of this specific zone
  const m = await db
    .select()
    .from(zoneMembers)
    .where(and(eq(zoneMembers.fireId, fireId), eq(zoneMembers.zoneId, zoneId), eq(zoneMembers.userId, userId)))
    .limit(1);
  if (!m.length) throw new Error("Forbidden");
}

export async function POST(req: Request, { params }: { params: Promise<{ id: string; zoneId: string }> }) {
  try {
    const { id, zoneId } = await params;
    const fireId = Number(id);
    const z = Number(zoneId);
    if (!Number.isFinite(fireId) || !Number.isFinite(z)) return NextResponse.json({ ok: false, error: "Invalid params" }, { status: 400 });

    // validate zone belongs to fire
    const zrow = await db.select().from(zones).where(and(eq(zones.id, z), eq(zones.fireId, fireId))).limit(1);
    if (!zrow.length) return NextResponse.json({ ok: false, error: "Zone not found" }, { status: 404 });

    const me = await getMe();
    if (!me) return NextResponse.json({ ok: false, error: "Unauthorized" }, { status: 401 });
    await ensureConfirmedVolunteerInZone(fireId, z, me.id);

    const body = (await req.json().catch(() => ({}))) as { text?: string | null; images?: { key: string; url: string; width?: number; height?: number }[] };
    const text = typeof body.text === "string" ? body.text.trim() : null;
    const imgs = Array.isArray(body.images) ? body.images : [];
    if ((!text || text.length === 0) && imgs.length === 0) {
      return NextResponse.json({ ok: false, error: "Празно обновление" }, { status: 400 });
    }

    const [upd] = await db
      .insert(zoneUpdates)
      .values({ zoneId: z, userId: me.id, text })
      .returning();

    if (imgs.length) {
      await db.insert(zoneUpdateImages).values(
        imgs.slice(0, 12).map((im) => ({ updateId: upd.id, s3Key: im.key, url: im.url, width: im.width ?? null, height: im.height ?? null }))
      );
    }

    // Touch fire activity
    try {
      await db.update(fires).set({ lastActivityAt: new Date(), updatedAt: new Date(), status: 'active', deactivatedAt: null }).where(eq(fires.id, fireId));
      await db.delete(fireDeactivationVotes).where(eq(fireDeactivationVotes.fireId, fireId));
    } catch {}

    return NextResponse.json({ ok: true, id: upd.id });
  } catch (e: any) {
    const msg = e?.message || "Error";
    const status = msg === "Forbidden" ? 403 : 500;
    return NextResponse.json({ ok: false, error: msg }, { status });
  }
}
\n===== END FILE: app/api/fires/[id]/zones/[zoneId]/updates/route.ts =====\n
===== FILE: app/api/fires/[id]/zones/route.ts =====
import { NextResponse } from "next/server";
import { db } from "@/lib/db";
import { zones, users, fireVolunteers, zoneMembers, zoneGalleryImages, fires, fireDeactivationVotes } from "@/lib/db/schema";
import { auth0 } from "@/lib/auth0";
import { and, desc, eq, sql } from "drizzle-orm";

export const runtime = "nodejs";

async function getLocalUser() {
  const session = await auth0.getSession();
  if (!session?.user?.email) return null;
  const email = session.user.email;
  const rows = await db.select().from(users).where(eq(users.email, email)).limit(1);
  if (rows.length) return rows[0];
  const [created] = await db.insert(users).values({ email, name: session.user.name ?? null }).returning();
  return created;
}

async function requireConfirmedVolunteer(fireId: number, userId: number) {
  const rows = await db
    .select()
    .from(fireVolunteers)
    .where(and(eq(fireVolunteers.fireId, fireId), eq(fireVolunteers.userId, userId), eq(fireVolunteers.status, "confirmed")))
    .limit(1);
  if (!rows.length) throw new Error("Forbidden");
}

export async function GET(_req: Request, { params }: { params: Promise<{ id: string }> }) {
  const { id } = await params;
  const fireId = Number(id);
  
  // Определяме в коя зона (ако има) е текущият потребител
  const me = await getLocalUser().catch(() => null);
  let myZoneId: number | null = null;
  if (me) {
    const row = await db
      .select({ zoneId: zoneMembers.zoneId })
      .from(zoneMembers)
      .where(and(eq(zoneMembers.fireId, fireId), eq(zoneMembers.userId, (me as any).id)))
      .limit(1);
    myZoneId = row[0]?.zoneId ?? null;
  }

  const list = await db
    .select({
      id: zones.id,
      fireId: zones.fireId,
      title: zones.title,
      description: zones.description,
      geomType: zones.geomType,
      centerLat: zones.centerLat,
      centerLng: zones.centerLng,
      radiusM: zones.radiusM,
      polygon: zones.polygon,
      createdAt: zones.createdAt,
      members: sql<number>`count(${zoneMembers.id})::int`.as("members"),
      // NEW: последната снимка от галерията като cover
      coverUrl: sql<string | null>`
        (
          select ${zoneGalleryImages.url}
          from ${zoneGalleryImages}
          where ${zoneGalleryImages.zoneId} = ${zones.id}
          order by ${zoneGalleryImages.createdAt} desc
          limit 1
        )
      `.as("cover_url"),
    })
    .from(zones)
    .leftJoin(zoneMembers, eq(zoneMembers.zoneId, zones.id))
    .where(eq(zones.fireId, fireId))
    .groupBy(
      zones.id,
      zones.fireId,
      zones.title,
      zones.description,
      zones.geomType,
      zones.centerLat,
      zones.centerLng,
      zones.radiusM,
      zones.polygon,
      zones.createdAt,
    )
    .orderBy(desc(zones.createdAt));

  // Маркираме isMember и връщаме
  const enriched = list.map((z) => ({ ...z, isMember: myZoneId != null && z.id === myZoneId }));

  return NextResponse.json({ ok: true, zones: enriched });
}

export async function POST(req: Request, { params }: { params: Promise<{ id: string }> }) {
  try {
    const { id } = await params;
    const fireId = Number(id);
    const me = await getLocalUser();
    if (!me) return NextResponse.json({ ok: false, error: "Unauthorized" }, { status: 401 });

    await requireConfirmedVolunteer(fireId, me.id);

    const body = (await req.json().catch(() => ({}))) as any;
    const { title, description, geomType, centerLat, centerLng, radiusM, polygon } = body || {};
    if (geomType !== "circle" && geomType !== "polygon") {
      return NextResponse.json({ ok: false, error: "Invalid geomType" }, { status: 400 });
    }
    if (geomType === "circle") {
      if (![centerLat, centerLng, radiusM].every((x: any) => Number.isFinite(x))) {
        return NextResponse.json({ ok: false, error: "Invalid circle payload" }, { status: 400 });
      }
    } else {
      if (!Array.isArray(polygon) || polygon.length < 3) {
        return NextResponse.json({ ok: false, error: "Polygon needs >= 3 points" }, { status: 400 });
      }
    }

    const [created] = await db
      .insert(zones)
      .values({
        fireId,
        title: (title ?? "").slice(0, 120) || null,
        description: (description ?? "").slice(0, 4000) || null,
        geomType,
        centerLat: geomType === "circle" ? Number(centerLat) : null,
        centerLng: geomType === "circle" ? Number(centerLng) : null,
        radiusM: geomType === "circle" ? Math.max(20, Math.min(20000, Math.round(Number(radiusM)))) : null,
        polygon: geomType === "polygon" ? polygon : null,
        createdBy: me.id,
      })
      .returning();

    try {
      await db.update(fires).set({ lastActivityAt: new Date(), updatedAt: new Date(), status: 'active', deactivatedAt: null }).where(eq(fires.id, fireId));
      await db.delete(fireDeactivationVotes).where(eq(fireDeactivationVotes.fireId, fireId));
    } catch {}

    return NextResponse.json({ ok: true, zone: created });
  } catch (e: any) {
    const msg = e?.message || "Error";
    const status = msg === "Forbidden" ? 403 : 500;
    return NextResponse.json({ ok: false, error: msg }, { status });
  }
}
\n===== END FILE: app/api/fires/[id]/zones/route.ts =====\n
===== FILE: app/api/fires/route.ts =====
import { NextResponse } from "next/server";
import { db } from "@/lib/db";
import { fires, type Fire, users, fireVolunteers } from "@/lib/db/schema";
import { auth0 } from "@/lib/auth0";
import { eq, desc } from "drizzle-orm";
import { haversineMeters } from "@/lib/geo";
import { ensureSbUser, getOrCreateFireChannel, joinUserToChannel } from "@/lib/sendbird";

type FireDTO = Fire & { distanceM?: number };

export async function GET(req: Request) {
  try {
    const { searchParams } = new URL(req.url);
    const lat = searchParams.get("lat");
    const lng = searchParams.get("lng");
    const limitParam = searchParams.get("limit");

    const limit = Math.min(Math.max(Number(limitParam) || 500, 1), 2000);

    // Взимаме последните (по създаване) до limit
    const rows = (await db
      .select()
      .from(fires)
      .where(eq(fires.status, 'active'))
      .orderBy(desc(fires.createdAt))
      .limit(limit)) as Fire[];

    let data: FireDTO[] = rows;

    if (lat && lng && !Number.isNaN(Number(lat)) && !Number.isNaN(Number(lng))) {
      const origin = { lat: Number(lat), lng: Number(lng) };
      data = rows
        .map((f) => ({
          ...f,
          distanceM: haversineMeters(origin, { lat: f.lat, lng: f.lng }),
        }))
        .sort((a, b) => (a.distanceM! - b.distanceM!));
    }

    return NextResponse.json({ ok: true, fires: data });
  } catch (e: any) {
    console.error(e);
    return NextResponse.json({ ok: false, error: e?.message || "Server error" }, { status: 500 });
  }
}

export async function POST(req: Request) {
  try {
    const session = await auth0.getSession();
    const user = session?.user;
    if (!user?.email) {
      return NextResponse.json({ ok: false, error: "Unauthorized" }, { status: 401 });
    }

    const body = await req.json().catch(() => ({}));
    const lat = Number(body?.lat);
    const lng = Number(body?.lng);
    const radiusM = Math.round(Number(body?.radiusM));

    if (
      Number.isNaN(lat) || Number.isNaN(lng) || Number.isNaN(radiusM) ||
      lat < -90 || lat > 90 || lng < -180 || lng > 180 ||
      radiusM < 50 || radiusM > 20000
    ) {
      return NextResponse.json({ ok: false, error: "Invalid payload" }, { status: 400 });
    }

    // ensure local user
    let [local] = await db.select().from(users).where(eq(users.email, user.email)).limit(1);
    if (!local) {
      [local] = await db.insert(users).values({ email: user.email, name: user.name ?? null }).returning();
    }

    const [created] = await db
      .insert(fires)
      .values({ lat, lng, radiusM, status: "active", createdBy: local.id })
      .returning();

    // creator -> confirmed volunteer
    await db
      .insert(fireVolunteers)
      .values({ fireId: created.id, userId: local.id, status: "confirmed" })
      .onConflictDoUpdate({
        target: [fireVolunteers.fireId, fireVolunteers.userId],
        set: { status: "confirmed", updatedAt: new Date() },
      });

    // Auto-join creator into Sendbird channel (best-effort)
    try {
      const sbUid = `user-${local.id}`;
      await ensureSbUser(sbUid, local.name || local.email);
      const channelUrl = await getOrCreateFireChannel(created.id);
      await joinUserToChannel(channelUrl, sbUid);
    } catch (e) {
      console.warn("[sendbird] auto-join failed on fire create", (e as any)?.message);
    }

    return NextResponse.json({ ok: true, fire: created });
  } catch (e: any) {
    console.error(e);
    return NextResponse.json({ ok: false, error: e?.message || "Server error" }, { status: 500 });
  }
}
\n===== END FILE: app/api/fires/route.ts =====\n
===== FILE: app/api/firms/route.ts =====
import { NextResponse } from "next/server";
import { db } from "@/lib/db";
import { fires } from "@/lib/db/schema";
import { and, gte, lte, eq } from "drizzle-orm";
import { haversineMeters } from "@/lib/geo";

export type Hotspot = {
  id: string;
  lat: number;
  lng: number;
  source: string;
  satellite?: string;
  instrument?: string;
  brightness?: number;
  frp?: number;
  confidence?: number;        // normalized 0..100 where possible
  confidenceRaw?: string;     // original (e.g., "l/m/h" or numeric as string)
  daynight?: string;          // "D"|"N"
  acquiredAt?: string;        // ISO string in UTC (best effort from acq_date+acq_time)
  radiusM: number;
  // --- нови (за клъстеризация) ---
  count?: number;             // брой точки в кластер
  sources?: string[];         // уникални източници в клъстера
  firstSeenAt?: string;       // най-ранен acquiredAt в клъстера
  lastSeenAt?: string;        // най-късен acquiredAt в клъстера
  frpTotal?: number;          // Σ FRP за клъстера
};

// Force Node.js runtime to avoid Edge limitations for external fetch
export const runtime = "nodejs";

const DEFAULT_SOURCES = [
  "VIIRS_NOAA21_NRT",
  "VIIRS_NOAA20_NRT",
  "VIIRS_SNPP_NRT",
];

const MAX_DAYS = 3;
const DEFAULT_DAYS = 2;

// === CSV helpers ===
function splitCsvLine(line: string): string[] {
  const out: string[] = [];
  let cur = "";
  let inQuotes = false;

  for (let i = 0; i < line.length; i++) {
    const ch = line[i];
    if (ch === '"') {
      inQuotes = !inQuotes;
      continue;
    }
    if (ch === "," && !inQuotes) {
      out.push(cur);
      cur = "";
    } else {
      cur += ch;
    }
  }
  out.push(cur);
  return out.map((s) => s.trim());
}

function parseCsv(text: string): Record<string, string>[] {
  const lines = text.trim().split(/\r?\n/);
  if (lines.length <= 1) return [];
  const headers = splitCsvLine(lines[0]).map((h) => h.trim().toLowerCase());
  const rows = lines.slice(1).filter((l) => l.trim().length > 0);

  return rows.map((line) => {
    const cols = splitCsvLine(line);
    const obj: Record<string, string> = {};
    headers.forEach((h, idx) => {
      obj[h] = (cols[idx] ?? "").trim();
    });
    return obj;
  });
}

function toNumber(x?: string) {
  if (!x) return undefined;
  const n = Number(x);
  return Number.isFinite(n) ? n : undefined;
}

function normalizeConfidence(raw?: string) {
  if (!raw) return { num: undefined, raw: undefined } as const;
  const v = raw.trim().toLowerCase();
  const asNum = Number(v);
  if (Number.isFinite(asNum)) return { num: asNum, raw } as const;
  if (v === "l" || v === "low") return { num: 15, raw } as const;
  if (v === "n" || v === "nominal") return { num: 50, raw } as const;
  if (v === "h" || v === "high") return { num: 85, raw } as const;
  return { num: undefined, raw } as const;
}

function estimateRadiusM(frp?: number, brightness?: number) {
  const base = 200;
  const frpBoost = frp ? 18 * Math.sqrt(Math.max(0, frp)) : 0;
  const bBoost = brightness ? 0.6 * Math.max(0, brightness - 300) : 0;
  return Math.max(150, Math.min(1200, Math.round(base + frpBoost + bBoost)));
}

function toIsoFromDateTime(date?: string, time?: string) {
  if (!date) return undefined;
  const t = (time ?? "").padStart(4, "0");
  const hh = t.slice(0, 2);
  const mm = t.slice(2, 4);
  return `${date}T${hh || "00"}:${mm || "00"}:00Z`;
}

async function fetchWithTimeout(url: string, opts: RequestInit & { timeoutMs?: number } = {}) {
  const { timeoutMs = 12000, ...init } = opts;
  const ac = new AbortController();
  const id = setTimeout(() => ac.abort(), timeoutMs);
  try {
    const res = await fetch(url, {
      ...init,
      headers: {
        "Accept": "text/csv",
        "User-Agent": "ignis-app/1.0 (+https://example.com)",
        ...(init.headers || {}),
      },
      signal: ac.signal,
      cache: "no-store",
    });
    return res;
  } finally {
    clearTimeout(id);
  }
}

// === Клъстеризация по близост (жаден, FRP‑теглов центроид) ===
function clusterHotspots(
  points: Hotspot[],
  clusterRadiusM: number,
  centerLat: number
): Hotspot[] {
  if (points.length <= 1) return points.slice();

  const clusters: {
    lat: number;
    lng: number;
    sumW: number;
    sumLatW: number;
    sumLngW: number;
    items: Hotspot[];
  }[] = [];

  for (const p of points) {
    const w = 1 + (p.frp ?? 0); // FRP да влияе, но да не доминира изцяло
    let best = -1;
    let bestD = Infinity;

    for (let i = 0; i < clusters.length; i++) {
      const c = clusters[i];
      const d = haversineMeters({ lat: c.lat, lng: c.lng }, { lat: p.lat, lng: p.lng });
      if (d <= clusterRadiusM && d < bestD) {
        best = i;
        bestD = d;
      }
    }

    if (best >= 0) {
      const c = clusters[best];
      c.items.push(p);
      c.sumW += w;
      c.sumLatW += p.lat * w;
      c.sumLngW += p.lng * w;
      c.lat = c.sumLatW / c.sumW;
      c.lng = c.sumLngW / c.sumW;
    } else {
      clusters.push({
        lat: p.lat,
        lng: p.lng,
        sumW: w,
        sumLatW: p.lat * w,
        sumLngW: p.lng * w,
        items: [p],
      });
    }
  }

  // Финализиране: изчисляваме радиус и обобщени атрибути
  const out: Hotspot[] = clusters.map((c, idx) => {
    const lat = c.lat;
    const lng = c.lng;

    let maxItemRadius = 0;
    let dMax = 0;
    let frpTotal = 0;
    let brightnessSum = 0;
    let brightnessCount = 0;
    let confSum = 0;
    let confCount = 0;
    const sourcesSet = new Set<string>();
    let firstSeen: string | undefined;
    let lastSeen: string | undefined;

    for (const it of c.items) {
      maxItemRadius = Math.max(maxItemRadius, it.radiusM || 0);
      const d = haversineMeters({ lat, lng }, { lat: it.lat, lng: it.lng });
      if (d > dMax) dMax = d;

      if (typeof it.frp === "number") frpTotal += it.frp;
      if (typeof it.brightness === "number") {
        brightnessSum += it.brightness;
        brightnessCount++;
      }
      if (typeof it.confidence === "number") {
        confSum += it.confidence;
        confCount++;
      }
      if (it.source) sourcesSet.add(it.source);

      const t = it.acquiredAt ? new Date(it.acquiredAt).getTime() : undefined;
      if (typeof t === "number" && Number.isFinite(t)) {
        if (!firstSeen || t < new Date(firstSeen).getTime()) firstSeen = it.acquiredAt!;
        if (!lastSeen || t > new Date(lastSeen).getTime()) lastSeen = it.acquiredAt!;
      }
    }

    const coverRadius = Math.max(maxItemRadius, Math.round(dMax + 180));
    const radiusM = Math.max(200, Math.min(2000, coverRadius));
    const brightnessAvg = brightnessCount ? brightnessSum / brightnessCount : undefined;
    const confidenceAvg = confCount ? confSum / confCount : undefined;

    // Стабилен, но кратък ID (епемерален е достатъчно)
    const id = `cluster:${lat.toFixed(4)},${lng.toFixed(4)}:${c.items.length}`;

    return {
      id,
      lat,
      lng,
      source: "FIRMS_CLUSTER",
      sources: Array.from(sourcesSet),
      satellite: undefined,
      instrument: undefined,
      brightness: brightnessAvg,
      frp: frpTotal || undefined,      // за удобство пазим Σ във frp
      frpTotal: frpTotal || undefined, // и явно поле Σ FRP
      confidence: confidenceAvg,
      confidenceRaw: undefined,
      daynight: undefined,
      acquiredAt: lastSeen,             // показваме най-късното като "основно" време
      firstSeenAt: firstSeen,
      lastSeenAt: lastSeen,
      radiusM,
      count: c.items.length,
    };
  });

  return out;
}

export async function GET(req: Request) {
  try {
    const url = new URL(req.url);
    const bboxStr = url.searchParams.get("bbox"); // west,south,east,north

    const dedupRadiusM = Math.min(Math.max(Number(url.searchParams.get("dedupRadiusM")) || 500, 100), 2000);
    const minConfidence = Math.max(0, Math.min(100, Number(url.searchParams.get("minConfidence")) || 0));
    const daysParam = Number(url.searchParams.get("days"));
    const days = Math.max(1, Math.min(MAX_DAYS, Number.isFinite(daysParam) ? daysParam : DEFAULT_DAYS));

    // ново: радиус за клъстер
    const clusterRadiusM = Math.min(Math.max(Number(url.searchParams.get("clusterRadiusM")) || 650, 200), 2000);

    const sourcesParam = url.searchParams.get("sources");
    const sources = (sourcesParam
      ? sourcesParam.split(",").map((s) => s.trim()).filter(Boolean)
      : DEFAULT_SOURCES.slice()) as string[];

    const MAP_KEY =
      process.env.FIRMS_MAP_KEY ||
      process.env.FIRMS_API_KEY ||
      process.env.NASA_FIRMS_MAP_KEY;

    if (!MAP_KEY) {
      return NextResponse.json(
        { ok: false, error: "Missing FIRMS_MAP_KEY in environment." },
        { status: 500 }
      );
    }

    let area = "-180,-90,180,90";
    let centerLat = 0;

    if (bboxStr) {
      const parts = bboxStr.split(",").map((v) => Number(v.trim()));
      if (parts.length !== 4 || parts.some((n) => !Number.isFinite(n))) {
        return NextResponse.json(
          { ok: false, error: "Invalid bbox parameter. Expected 'west,south,east,north'." },
          { status: 400 }
        );
      }
      const [w, s, e, n] = parts;
      area = `${w},${s},${e},${n}`;
      centerLat = (s + n) / 2;
    }

    // 1) Вземаме FIRMS CSV за всяка source
    const base = "https://firms.modaps.eosdis.nasa.gov/api/area/csv";
    const fetches = sources.map(async (source) => {
      const u = `${base}/${MAP_KEY}/${source}/${area}/${days}`;
      let lastErr: any = null;
      for (let attempt = 0; attempt < 2; attempt++) {
        try {
          const r = await fetchWithTimeout(u, { timeoutMs: 12000 });
          if (!r.ok) {
            const txt = await r.text().catch(() => "");
            throw new Error(`FIRMS ${source} ${r.status} ${r.statusText} ${txt?.slice(0, 220)}`);
          }
          const text = await r.text();
          const rows = parseCsv(text);

          const list: Hotspot[] = rows.map((row, idx) => {
            const lat = toNumber(row["latitude"]);
            const lng = toNumber(row["longitude"]);

            const brightness = toNumber(row["bright_ti4"] ?? row["brightness"] ?? row["brightness_ti4"]);
            const frp = toNumber(row["frp"]);
            const sat = row["satellite"] || row["sat"] || undefined;
            const instr = row["instrument"] || undefined;
            const { num: confNum, raw: confRaw } = normalizeConfidence(row["confidence"] || row["confidence_text"]);
            const daynight = row["daynight"] || row["day_night"] || undefined;
            const acquiredAt = toIsoFromDateTime(row["acq_date"], row["acq_time"]);

            const radiusM = estimateRadiusM(frp, brightness);
            const id = `${source}:${lat?.toFixed(4)},${lng?.toFixed(4)}:${row["acq_date"] ?? ""}:${row["acq_time"] ?? ""}:${idx}`;

            return {
              id,
              lat: lat ?? 0,
              lng: lng ?? 0,
              source,
              satellite: sat,
              instrument: instr,
              brightness: brightness,
              frp: frp,
              confidence: confNum,
              confidenceRaw: confRaw,
              daynight,
              acquiredAt,
              radiusM,
            };
          }).filter((h) => Number.isFinite(h.lat) && Number.isFinite(h.lng));

          return list;
        } catch (e) {
          lastErr = e;
          await new Promise((r) => setTimeout(r, 500));
        }
      }
      throw lastErr ?? new Error(`FIRMS fetch failed for ${source}`);
    });

    // 2) Толерираме частични грешки между източници
    const settled = await Promise.allSettled(fetches);
    const successes = settled.filter((s): s is PromiseFulfilledResult<Hotspot[]> => s.status === "fulfilled");
    const failures = settled.filter((s): s is PromiseRejectedResult => s.status === "rejected");
    if (successes.length === 0) {
      const reason = failures.map((f) => String(f.reason?.message || f.reason)).join(" | ") || "fetch failed";
      return NextResponse.json({ ok: false, error: reason }, { status: 502 });
    }
    let hotspots: Hotspot[] = successes.flatMap((s) => s.value);

    // 3) Филтър по confidence (ако е указан)
    if (minConfidence > 0) {
      hotspots = hotspots.filter((h) => (typeof h.confidence === "number" ? h.confidence >= minConfidence : true));
    }

    // 4) Премахваме FIRMS точки до активни докладвани пожари (dedup срещу БД)
    if (bboxStr) {
      const [w, s, e, n] = bboxStr.split(",").map((v) => Number(v.trim()));
      const radLatDeg = dedupRadiusM / 111_320;
      const radLngDeg = dedupRadiusM / (111_320 * Math.max(0.2, Math.cos((centerLat * Math.PI) / 180)));

      const rows = await db
        .select()
        .from(fires)
        .where(
          and(
            gte(fires.lat, s - radLatDeg),
            lte(fires.lat, n + radLatDeg),
            gte(fires.lng, w - radLngDeg),
            lte(fires.lng, e + radLngDeg),
            eq(fires.status, "active"),
          ),
        );

      hotspots = hotspots.filter((h) => {
        for (const f of rows) {
          const d = haversineMeters({ lat: h.lat, lng: h.lng }, { lat: f.lat, lng: f.lng });
          if (d <= dedupRadiusM) return false;
        }
        return true;
      });
    }

    // 5) Клъстеризация по близост → една група = един кръг с по-голям радиус
    if (hotspots.length > 1) {
      hotspots = clusterHotspots(hotspots, clusterRadiusM, centerLat);
    }

    // 6) Ограничение на резултати за безопасност
    if (hotspots.length > 1500) hotspots = hotspots.slice(0, 1500);

    return NextResponse.json({
      ok: true,
      hotspots,
      meta: { sources, days, dedupRadiusM, minConfidence, clusterRadiusM },
    });
  } catch (e: any) {
    console.error(e);
    return NextResponse.json({ ok: false, error: e?.message || "Server error" }, { status: 500 });
  }
}
\n===== END FILE: app/api/firms/route.ts =====\n
===== FILE: app/api/subscriptions/route.ts =====
import { NextResponse } from "next/server";
import { db } from "@/lib/db";
import { notificationSubscriptions } from "@/lib/db/schema";
import { sql } from "drizzle-orm";

export const runtime = "nodejs";

export async function POST(req: Request) {
  try {
    const body = await req.json().catch(() => ({}));
    const email = typeof body?.email === 'string' ? body.email.trim() : null;
    const phone = typeof body?.phone === 'string' ? body.phone.trim() : null;
    const lat = Number(body?.lat);
    const lng = Number(body?.lng);
    const radiusKmRaw = Number(body?.radiusKm);
    const radiusKm = Number.isFinite(radiusKmRaw) ? Math.max(1, Math.min(200, Math.round(radiusKmRaw))) : 15;
    const sourceFirms = body?.sourceFirms === false ? 0 : 1;
    const sourceReports = body?.sourceReports === false ? 0 : 1;

    if ((!email && !phone) || !Number.isFinite(lat) || !Number.isFinite(lng)) {
      return NextResponse.json({ ok: false, error: "Invalid payload" }, { status: 400 });
    }

    const [row] = await db.insert(notificationSubscriptions).values({
      email: email || null,
      phone: phone || null,
      lat,
      lng,
      radiusKm,
      sourceFirms,
      sourceReports,
    }).returning();

    return NextResponse.json({ ok: true, subscription: row });
  } catch (e: any) {
    console.error(e);
    return NextResponse.json({ ok: false, error: e?.message || "Server error" }, { status: 500 });
  }
}

\n===== END FILE: app/api/subscriptions/route.ts =====\n
===== FILE: app/api/webhooks/sendbird/route.ts =====
import { NextResponse } from "next/server";
import crypto from "crypto";
import { db } from "@/lib/db";
import { fires, fireDeactivationVotes } from "@/lib/db/schema";
import { and, eq } from "drizzle-orm";

export const runtime = "nodejs";

function timingSafeEqual(a: string, b: string) {
  const ab = Buffer.from(a, "utf8");
  const bb = Buffer.from(b, "utf8");
  if (ab.length !== bb.length) return false;
  return crypto.timingSafeEqual(ab, bb);
}

function verifySignature(raw: string, headerSig: string | null | undefined) {
  const token = process.env.SENDBIRD_WEBHOOK_TOKEN;
  if (!token) return true; // if not configured, skip verification (dev)
  if (!headerSig) return false;
  const hmac = crypto.createHmac("sha256", token);
  hmac.update(raw);
  const digest = hmac.digest("hex");
  return timingSafeEqual(digest, headerSig);
}

function extractFireId(channelUrl: string | null | undefined): number | null {
  if (!channelUrl) return null;
  // Expected formats: fire-<id> or fire-<id>-zone-<zoneId>
  const m = channelUrl.match(/^fire-(\d+)(?:-zone-(\d+))?$/);
  if (!m) return null;
  const id = Number(m[1]);
  return Number.isFinite(id) ? id : null;
}

export async function POST(req: Request) {
  try {
    const raw = await req.text();
    const sig = req.headers.get("x-sendbird-signature") || req.headers.get("X-Sendbird-Signature");
    if (!verifySignature(raw, sig)) {
      return NextResponse.json({ ok: false, error: "Invalid signature" }, { status: 401 });
    }

    let body: any = {};
    try { body = JSON.parse(raw); } catch {}

    // Only react to message events
    const category = String(body?.category || "");
    if (!category.includes("message")) return NextResponse.json({ ok: true });

    const channelUrl: string | undefined = body?.channel?.channel_url || body?.channel_url || body?.channel?.url;
    const fireId = extractFireId(channelUrl);
    if (!fireId) return NextResponse.json({ ok: true });

    const ts: number | undefined = body?.ts || body?.message?.created_at || body?.created_at;
    const when = ts && Number.isFinite(Number(ts)) ? new Date(Number(ts)) : new Date();

    // Mark activity and auto-reactivate if needed; clear votes
    try {
      await db
        .update(fires)
        .set({ lastActivityAt: when, updatedAt: new Date(), status: 'active', deactivatedAt: null })
        .where(eq(fires.id, fireId));
      await db.delete(fireDeactivationVotes).where(eq(fireDeactivationVotes.fireId, fireId));
    } catch (e) {
      // ignore
    }

    return NextResponse.json({ ok: true });
  } catch (e: any) {
    return NextResponse.json({ ok: false, error: e?.message || "Error" }, { status: 500 });
  }
}

\n===== END FILE: app/api/webhooks/sendbird/route.ts =====\n
===== FILE: app/components/auth-nav.tsx =====
"use client";
import { useUser } from "@auth0/nextjs-auth0";

export default function AuthNav() {
  const { user, isLoading } = useUser();

  return (
    <nav style={{ display: "flex", gap: 12, alignItems: "center", padding: 12 }}>
      {isLoading && <span>Loading session…</span>}
      {!isLoading && !user && (
        <a href="/auth/login" style={{ textDecoration: "underline" }}>
          Login
        </a>
      )}
      {!isLoading && user && (
        <>
          {user.picture && (
            // eslint-disable-next-line @next/next/no-img-element
            <img
              src={user.picture}
              alt={user.name || "User"}
              width={28}
              height={28}
              style={{ borderRadius: "50%" }}
            />
          )}
          <span style={{ fontSize: 14 }}>{user.name || user.email}</span>
          <a href="/auth/logout" style={{ textDecoration: "underline" }}>
            Logout
          </a>
        </>
      )}
    </nav>
  );
}
\n===== END FILE: app/components/auth-nav.tsx =====\n
===== FILE: app/components/case.jsx =====
// components/CaseStudies.tsx
"use client";

import { Card, CardContent, CardFooter, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { ArrowRight } from "lucide-react";

export default function CaseStudies() {
  const cases = [
    {
      title: "Title",
      text: "Egestas elit dui scelerisque ut eu purus aliquam vitae habitasse.",
    },
    {
      title: "Title",
      text: "Id eros pellentesque facilisi id mollis faucibus commodo enim.",
    },
    {
      title: "Title",
      text: "Nunc, pellentesque velit malesuada non massa arcu.",
    },
    {
      title: "Title",
      text: "Imperdiet purus pellentesque sit mi nibh sit integer faucibus.",
    },
  ];

  return (
    <section className="py-20 bg-white">
      <div className="max-w-screen-xl mx-auto px-4">
        {/* Section heading */}
        <div className="text-center mb-12">
          <p className="text-sm font-semibold text-blue-600 uppercase tracking-wide">
            Case Studies
          </p>
          <h2 className="text-2xl font-bold mt-2">
            Interdum sollicitudin tortor viverra porta consequat in.
          </h2>
        </div>

        {/* Cards grid */}
        <div className="grid grid-cols-1 md:grid-cols-4 gap-6 mb-12">
          {cases.map((item, index) => (
            <Card key={index} className="shadow-sm">
              <CardHeader className="bg-gray-100 h-40 flex items-center justify-center">
                <div className="w-16 h-16 bg-gray-300" /> {/* Placeholder image */}
              </CardHeader>
              <CardContent className="pt-4">
                <CardTitle className="text-base mb-2">{item.title}</CardTitle>
                <p className="text-sm text-gray-600">{item.text}</p>
              </CardContent>
              <CardFooter>
                <a
                  href="#"
                  className="text-blue-600 text-sm font-semibold flex items-center gap-1 hover:underline"
                >
                  More Info <ArrowRight className="w-4 h-4" />
                </a>
              </CardFooter>
            </Card>
          ))}
        </div>

        {/* CTA button */}
        <div className="text-center">
          <Button className="bg-blue-600 hover:bg-blue-700 text-white px-6">
            Contact Me
          </Button>
        </div>
      </div>
    </section>
  );
}\n===== END FILE: app/components/case.jsx =====\n
===== FILE: app/components/contact.jsx =====
"use client";

import { useForm } from "react-hook-form";
import {
  Form,
  FormField,
  FormItem,
  FormLabel,
  FormControl,
  FormMessage,
} from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import { Button } from "@/components/ui/button";

export default function ContactForm() {
  const form = useForm({
    defaultValues: {
      name: "",
      email: "",
      subject: "",
      phone: "",
      message: "",
    },
  });

  function onSubmit(values) {
    console.log("Form submitted:", values);
  }

  return (
    <section className="py-20 bg-white">
      <div className="max-w-2xl mx-auto px-4 text-center">
        <p className="text-sm font-semibold text-blue-600 uppercase tracking-wide">
          Contact Me
        </p>
        <h2 className="text-2xl font-bold mb-8">
          Bibendum amet at molestie mattis.
        </h2>

        <Form {...form}>
          <form
            onSubmit={form.handleSubmit(onSubmit)}
            className="space-y-6 text-left"
          >
            {/* Name */}
            <FormField
              control={form.control}
              name="name"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Label Name</FormLabel>
                  <FormControl>
                    <Input placeholder="Placeholder" {...field} />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />

            {/* Email */}
            <FormField
              control={form.control}
              name="email"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Label Name</FormLabel>
                  <FormControl>
                    <Input placeholder="Placeholder" {...field} />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />

            {/* Subject */}
            <FormField
              control={form.control}
              name="subject"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Label Name</FormLabel>
                  <FormControl>
                    <Input placeholder="Placeholder" {...field} />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />

            {/* Phone */}
            <FormField
              control={form.control}
              name="phone"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Label Name</FormLabel>
                  <FormControl>
                    <Input placeholder="Placeholder" {...field} />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />

            {/* Message */}
            <FormField
              control={form.control}
              name="message"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Label Name</FormLabel>
                  <FormControl>
                    <Textarea placeholder="Placeholder" rows={4} {...field} />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />

            {/* Submit */}
            <div className="flex justify-center">
              <Button type="submit" className="bg-blue-600 hover:bg-blue-700">
                Send Message
              </Button>
            </div>
          </form>
        </Form>
      </div>
    </section>
  );
}\n===== END FILE: app/components/contact.jsx =====\n
===== FILE: app/components/subscribe-modal.tsx =====
"use client";

import { useCallback, useEffect, useMemo, useRef, useState } from "react";
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogTrigger } from "@/components/ui/dialog";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Button } from "@/components/ui/button";
import MapProvider from "@/lib/mapbox/provider";
import { useMap } from "@/context/map-context";
import type mapboxgl from "mapbox-gl";

function isValidEmail(v: string) { return /.+@.+\..+/.test(v); }
const ACCESS_TOKEN = process.env.NEXT_PUBLIC_MAPBOX_TOKEN as string | undefined;

function MapInner({ center, onCenterChange, radiusKm }: { center: [number, number]; onCenterChange: (lng: number, lat: number) => void; radiusKm: number; }) {
  const { map } = useMap();
  const markerRef = useRef<mapboxgl.Marker | null>(null);
  const circleId = useRef<string>(`sub-circle-${Math.random().toString(36).slice(2)}`);

  const updateCircle = useCallback((m: mapboxgl.Map, lng: number, lat: number, rKm: number) => {
    if (!m || !m.isStyleLoaded || !m.isStyleLoaded()) {
      const onLoad = () => {
        try { updateCircle(m, lng, lat, rKm); } finally { m.off('load', onLoad); }
      };
      m.on('load', onLoad);
      return;
    }

    const r = Math.max(0.2, Math.min(200, rKm)) * 1000; // meters
    const steps = 64;
    const coords: [number, number][] = [];
    const d2r = Math.PI / 180;
    const earth = 6378137; // meters
    const latRad = lat * d2r;
    for (let i = 0; i <= steps; i++) {
      const theta = (i / steps) * 2 * Math.PI;
      const dx = (r * Math.cos(theta)) / (earth * Math.cos(latRad));
      const dy = (r * Math.sin(theta)) / earth;
      const newLng = lng + (dx * 180) / Math.PI;
      const newLat = lat + (dy * 180) / Math.PI;
      coords.push([newLng, newLat]);
    }
    const data: GeoJSON.Feature<GeoJSON.Polygon> = {
      type: 'Feature',
      properties: {},
      geometry: { type: 'Polygon', coordinates: [coords] },
    };
    const srcId = `${circleId.current}-src`;
    const fillId = `${circleId.current}-fill`;
    const lineId = `${circleId.current}-line`;

    try {
      if (m.getSource(srcId)) {
        (m.getSource(srcId) as mapboxgl.GeoJSONSource).setData(data);
      } else {
        m.addSource(srcId, { type: 'geojson', data });
        if (!m.getLayer(fillId)) m.addLayer({ id: fillId, type: 'fill', source: srcId, paint: { 'fill-color': '#ef4444', 'fill-opacity': 0.18 }});
        if (!m.getLayer(lineId)) m.addLayer({ id: lineId, type: 'line', source: srcId, paint: { 'line-color': '#ef4444', 'line-width': 2, 'line-opacity': 0.6 }});
      }
    } catch (e: any) {
      // If style not ready despite the check, retry on next styledata
      const onStyle = () => {
        try { updateCircle(m, lng, lat, rKm); } finally { m.off('styledata', onStyle); }
      };
      m.on('styledata', onStyle);
    }
  }, []);

  useEffect(() => {
    if (!map) return;
    if (!markerRef.current) {
      const mk = new (require('mapbox-gl').Marker)({ draggable: true, color: '#ef4444' })
        .setLngLat(center)
        .addTo(map);
      mk.on('dragend', () => {
        const p = mk.getLngLat();
        onCenterChange(p.lng, p.lat);
      });
      markerRef.current = mk;
      map.addControl(new (require('mapbox-gl').NavigationControl)({ showCompass: false }));
      map.addControl(new (require('mapbox-gl').GeolocateControl)({ positionOptions: { enableHighAccuracy: true }, trackUserLocation: false }));
      map.on('click', (e) => onCenterChange(e.lngLat.lng, e.lngLat.lat));
    } else {
      markerRef.current.setLngLat(center);
    }
    updateCircle(map, center[0], center[1], radiusKm);
  }, [map, center[0], center[1], radiusKm, onCenterChange, updateCircle]);

  return null;
}

export default function SubscribeModal() {
  const [open, setOpen] = useState(false);
  const [email, setEmail] = useState("");
  const [phone, setPhone] = useState("");
  const [radiusKm, setRadiusKm] = useState<number>(15);
  const [sourceReports, setSourceReports] = useState(true);
  const [sourceFirms, setSourceFirms] = useState(true);
  const [loading, setLoading] = useState(false);
  const [msg, setMsg] = useState<string>("");
  const [query, setQuery] = useState("");
  const [suggestions, setSuggestions] = useState<any[]>([]);
  const [suggestOpen, setSuggestOpen] = useState(false);

  // default center: Sofia
  const [center, setCenter] = useState<[number, number]>([23.3219, 42.6977]);

  const mapRef = useRef<HTMLDivElement | null>(null);

  const doSearch = useCallback(async (q: string) => {
    if (!ACCESS_TOKEN || !q || q.trim().length < 2) { setSuggestions([]); return; }
    try {
      const url = `https://api.mapbox.com/geocoding/v5/mapbox.places/${encodeURIComponent(q)}.json?access_token=${ACCESS_TOKEN}&autocomplete=true&limit=6&language=bg,en`;
      const res = await fetch(url);
      const data = await res.json();
      const feats = Array.isArray(data?.features) ? data.features : [];
      setSuggestions(feats);
      setSuggestOpen(true);
    } catch (e) {
      setSuggestions([]);
    }
  }, []);

  useEffect(() => {
    const id = setTimeout(() => doSearch(query), 250);
    return () => clearTimeout(id);
  }, [query, doSearch]);

  const useMyLocation = () => {
    setMsg("");
    if (!navigator.geolocation) { setMsg("Геолокация не е налична в браузъра."); return; }
    navigator.geolocation.getCurrentPosition(
      (pos) => {
        const { latitude, longitude } = pos.coords;
        setCenter([Number(longitude.toFixed(6)), Number(latitude.toFixed(6))]);
      },
      (err) => setMsg("Неуспешно вземане на локация: " + (err?.message || "")),
      { enableHighAccuracy: true, timeout: 10_000 }
    );
  };

  const onSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setMsg("");
    if (!email && !phone) { setMsg("Въведете имейл или телефон."); return; }
    if (email && !isValidEmail(email)) { setMsg("Невалиден имейл адрес."); return; }
    try {
      setLoading(true);
      const res = await fetch('/api/subscriptions', {
        method: 'POST', headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email, phone, lat: center[1], lng: center[0], radiusKm, sourceFirms, sourceReports }),
      });
      const data = await res.json();
      if (!res.ok || !data?.ok) throw new Error(data?.error || res.statusText);
      setMsg("Успешно записване! Ще получавате известия за района.");
      setEmail(""); setPhone("");
    } catch (e: any) {
      setMsg(e?.message || 'Грешка при записване.');
    } finally {
      setLoading(false);
    }
  };

  return (
    <Dialog open={open} onOpenChange={setOpen}>
      <DialogTrigger asChild>
        <Button variant="secondary">Получавай известия</Button>
      </DialogTrigger>
      <DialogContent className="w-[96vw] max-w-[1040px] p-0 overflow-hidden">
        <div className="grid md:grid-cols-[2fr_1fr] gap-0 md:h-[80vh] md:max-h-[860px]">
          <div className="relative">
            <div className="absolute z-10 w-full p-4">
              <div className="bg-white/90 backdrop-blur-sm rounded-md shadow flex items-center gap-2 p-2">
                <Input
                  placeholder="Търси адрес или място…"
                  value={query}
                  onChange={(e) => setQuery(e.target.value)}
                  onFocus={() => query && setSuggestOpen(true)}
                />
                <Button type="button" variant="outline" onClick={useMyLocation}>Моята локация</Button>
              </div>
              {suggestOpen && suggestions.length > 0 && (
                <div className="mt-2 bg-white/95 backdrop-blur rounded-md shadow max-h-60 overflow-auto">
                  {suggestions.map((f: any) => (
                    <button
                      key={f.id}
                      onClick={() => { setCenter([f.center[0], f.center[1]]); setSuggestOpen(false); setQuery(f.place_name || ''); }}
                      className="w-full text-left px-3 py-2 hover:bg-gray-100 text-sm"
                    >
                      {f.text || f.place_name}
                      <div className="text-[11px] text-gray-500">{f.place_name}</div>
                    </button>
                  ))}
                </div>
              )}
            </div>

            <div ref={mapRef} className="h-[52vh] md:h-full" />

            {/* Map init */}
            <MapProvider
              mapContainerRef={mapRef as any}
              initialViewState={{ longitude: center[0], latitude: center[1], zoom: 10 }}
              onMapLoad={(m) => {
                try { m.resize(); } catch {}
              }}
            >
              <MapInner center={center} onCenterChange={(lng, lat) => setCenter([lng, lat])} radiusKm={radiusKm} />
            </MapProvider>
          </div>

          <div className="flex flex-col border-l bg-white p-5 gap-4">
            <DialogHeader>
              <DialogTitle>Настройка на известия</DialogTitle>
            </DialogHeader>
            <form onSubmit={onSubmit} className="space-y-4">
              <div className="grid grid-cols-1 gap-3">
                <div className="grid grid-cols-2 gap-3">
                  <div>
                    <Label htmlFor="email">Имейл</Label>
                    <Input id="email" placeholder="you@example.com" value={email} onChange={(e) => setEmail(e.target.value)} />
                  </div>
                  <div>
                    <Label htmlFor="phone">Телефон</Label>
                    <Input id="phone" placeholder="3598XXXXXXXX" value={phone} onChange={(e) => setPhone(e.target.value)} />
                  </div>
                </div>

                <div>
                  <Label>Радиус: {radiusKm} км</Label>
                  <input type="range" min={1} max={200} value={radiusKm} onChange={(e) => setRadiusKm(Number(e.target.value))} className="w-full" />
                  <p className="text-xs text-gray-500 mt-1">Препоръка: 10–25 км</p>
                </div>

                <div className="flex items-center gap-4">
                  <label className="flex items-center gap-2 text-sm">
                    <input type="checkbox" checked={sourceReports} onChange={(e) => setSourceReports(e.target.checked)} /> Доклади
                  </label>
                  <label className="flex items-center gap-2 text-sm">
                    <input type="checkbox" checked={sourceFirms} onChange={(e) => setSourceFirms(e.target.checked)} /> FIRMS
                  </label>
                </div>

                <div className="text-xs text-gray-500">Избрано: {center[1].toFixed(5)}, {center[0].toFixed(5)}</div>
                {msg && <div className="text-sm text-gray-700">{msg}</div>}
              </div>
              <div className="flex justify-end gap-2">
                <Button type="button" variant="outline" onClick={() => setOpen(false)}>Затвори</Button>
                <Button type="submit" disabled={loading}>{loading ? 'Записване…' : 'Запиши'}</Button>
              </div>
            </form>
          </div>
        </div>
      </DialogContent>
    </Dialog>
  );
}
\n===== END FILE: app/components/subscribe-modal.tsx =====\n
===== FILE: app/fires/[id]/client.tsx =====
"use client";

import { useMemo, useRef, useState, useTransition, useEffect } from "react";
import MapProvider from "@/lib/mapbox/provider";
import MapControls from "@/components/map/map-controls";
import FireMarker from "@/components/fires/fire-marker";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Separator } from "@/components/ui/separator";
import { metersToReadable, circlePolygon } from "@/lib/geo";
import { Navigation, QrCode, Check, User2, Users, MessageCircle, Plus, X } from "lucide-react";
import * as QRCode from "qrcode";
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription } from "@/components/ui/dialog";
import ZoneDraw from "@/components/zones/zone-draw";
import ZoneList from "@/components/zones/zone-list";
import ZoneShapes from "@/components/zones/zone-shapes";
import SendbirdChat from "@/components/chat/sendbird-chat";
import { useSendbirdUnreadMany } from "@/hooks/useSendbirdUnreadMany";
import type mapboxgl from "mapbox-gl";
import { useRouter } from "next/navigation";
import { useSendbirdUnread } from "@/hooks/useSendbirdUnread";

type Fire = {
  id: number;
  lat: number;
  lng: number;
  radiusM: number;
  status: string;
  createdAt: string;
};

type VolunteerRow = {
  id: number;
  userId: number;
  status: "requested" | "confirmed";
  createdAt: string;
  name: string | null;
  email: string;
};

type ZoneListItem = {
  id: number;
  fireId: number;
  title?: string | null;
  description?: string | null;
  geomType: "circle" | "polygon";
  centerLat?: number | null;
  centerLng?: number | null;
  radiusM?: number | null;
  polygon?: [number, number][];
  createdAt: string;
  members: number;
  /** NEW - за UI подредба/бутоните */
  isMember?: boolean;
  /** NEW - cover снимка (последно качена), ако има */
  coverUrl?: string | null;
};

export default function FireDetailsClient({
  fire,
  viewerStatus,
  initialVolunteers,
  claimAction,
  approveAction,
  generateTokenAction,
  joinBaseUrl,
}: {
  fire: Fire;
  viewerStatus: "none" | "requested" | "confirmed";
  initialVolunteers: { confirmed: VolunteerRow[]; requested: VolunteerRow[] };
  claimAction: (form: FormData) => Promise<{ ok: boolean }>;
  approveAction: (form: FormData) => Promise<{ ok: boolean }>;
  generateTokenAction: (form: FormData) => Promise<{ ok: boolean; token?: string; expiresAt?: string; error?: string }>;
  joinBaseUrl: string;
}) {
  const router = useRouter();
  const mapContainerRef = useRef<HTMLDivElement | null>(null);

  const [viewer, setViewer] = useState(viewerStatus);
  const [confirmed, setConfirmed] = useState(initialVolunteers.confirmed);
  const [requested, setRequested] = useState(initialVolunteers.requested);

  const [isQR, setIsQR] = useState(false);
  const [qrUrl, setQrUrl] = useState<string | null>(null);
  const [qrImg, setQrImg] = useState<string | null>(null);
  const [isPending, startTransition] = useTransition();

  // zones
  const [zones, setZones] = useState<ZoneListItem[]>([]);
  const [zonesLoaded, setZonesLoaded] = useState(false);
  const [zonesRefreshAt, setZonesRefreshAt] = useState<number>(0);
  const [showZoneCreator, setShowZoneCreator] = useState(false);

  // Deactivation (manual vote) state
  const [deactStatus, setDeactStatus] = useState<{ status: string; votes: number; required: number; hasVoted?: boolean } | null>(null);
  const [deactLoading, setDeactLoading] = useState(false);
  useEffect(() => {
    (async () => {
      try {
        const j = await fetch(`/api/fires/${fire.id}/deactivate`, { cache: "no-store" }).then((r) => r.json());
        if (j?.ok) setDeactStatus({ status: j.status, votes: j.votes, required: j.required, hasVoted: j.hasVoted });
      } catch {}
    })();
  }, [fire.id]);
  const voteDeactivate = async () => {
    setDeactLoading(true);
    try {
      const j = await fetch(`/api/fires/${fire.id}/deactivate`, { method: 'POST' }).then((r) => r.json());
      if (j?.ok) {
        const s = await fetch(`/api/fires/${fire.id}/deactivate`, { cache: 'no-store' }).then((r) => r.json());
        if (s?.ok) setDeactStatus({ status: s.status, votes: s.votes, required: s.required, hasVoted: true });
        if (s?.status === 'inactive') {
          // Optionally redirect back to list
          // router.push('/fires');
        }
      }
    } catch {}
    setDeactLoading(false);
  };

  // chat
  const [chatOpen, setChatOpen] = useState(false);
  const [activeChat, setActiveChat] = useState<"fire" | "zone">("fire");
  // local ref to map instance captured on load
  const [mapReady, setMapReady] = useState(false);
  const mapRef = useRef<mapboxgl.Map | null>(null);

  useEffect(() => {
    if (!qrUrl) {
      setQrImg(null);
      return;
    }
    (async () => {
      try {
        const dataUrl = await QRCode.toDataURL(qrUrl, { margin: 1, width: 320 });
        setQrImg(dataUrl);
      } catch (e) {
        console.error(e);
        setQrImg(null);
      }
    })();
  }, [qrUrl]);

  const centerForMap = useMemo(() => ({ lat: fire.lat, lng: fire.lng }), [fire.lat, fire.lng]);

  const claim = () => {
    const fd = new FormData();
    fd.set("fireId", String(fire.id));
    startTransition(async () => {
      const res = await claimAction(fd);
      if (res?.ok) {
        setViewer("requested");
        setRequested((prev) => [
          ...prev,
          { id: -1, userId: -1, status: "requested", createdAt: new Date().toISOString(), name: null, email: "Вие" },
        ]);
      }
    });
  };

  const approve = (userId: number) => {
    const fd = new FormData();
    fd.set("fireId", String(fire.id));
    fd.set("userId", String(userId));
    startTransition(async () => {
      const res = await approveAction(fd);
      if (res?.ok) {
        setRequested((prev) => prev.filter((r) => r.userId !== userId));
        const row = initialVolunteers.requested.find((r) => r.userId === userId) || requested.find((r) => r.userId === userId);
        if (row) {
          setConfirmed((prev) => [...prev, { ...row, status: "confirmed" }]);
        }
      }
    });
  };

  const generateQR = () => {
    const fd = new FormData();
    fd.set("fireId", String(fire.id));
    startTransition(async () => {
      const res = await generateTokenAction(fd);
      if (res?.ok && res.token) {
        const base = joinBaseUrl || (typeof window !== "undefined" ? window.location.origin : "");
        const url = `${base}/fires/${fire.id}/join?token=${res.token}`;
        setQrUrl(url);
        setIsQR(true);
      } else {
        alert(res?.error || "Грешка при генериране на QR.");
      }
    });
  };

  async function loadZones() {
    try {
      const j = await fetch(`/api/fires/${fire.id}/zones`, { cache: "no-store" }).then((r) => r.json());
      if (j?.ok) {
        setZones(j.zones || []);
        setZonesRefreshAt(Date.now());
      } else {
        console.error("Zones load error:", j?.error);
      }
    } catch (e) {
      console.error("Zones fetch failed:", e);
    } finally {
      // ВАЖНО: винаги маркираме като „заредено“, за да имаме fallback (пин) и да избегнем „празна“ карта
      setZonesLoaded(true);
    }
  }
  // Зареждаме зоните при отваряне на изгледа, за да знаем дали да показваме пин-а
  useEffect(() => {
    loadZones();
  }, []);

  // Малък ретрай — ако първото извикване фейлне/карта не е готова
  useEffect(() => {
    if (zonesLoaded) return;
    let tries = 0;
    const id = setInterval(() => {
      if (zonesLoaded || tries >= 4) {
        clearInterval(id);
        return;
      }
      tries += 1;
      loadZones();
    }, 1500);
    return () => clearInterval(id);
  }, [zonesLoaded, fire.id]);

  const canEditZones = viewer === "confirmed";
  const myZone = useMemo(() => zones.find((z) => z.isMember), [zones]);
  const fireConnect = `/api/fires/${fire.id}/chat/connect`;
  const zoneConnect = myZone ? `/api/fires/${fire.id}/zones/${myZone.id}/chat/connect` : null;
  const activeConnectUrl = (activeChat === "zone" && zoneConnect) ? zoneConnect : fireConnect;
  const { total: unreadCount, counts } = useSendbirdUnreadMany([fireConnect, ...(zoneConnect ? [zoneConnect] : [])], chatOpen, activeConnectUrl);
  const fireUnread = counts?.[fireConnect] || 0;
  const zoneUnread = zoneConnect ? (counts?.[zoneConnect] || 0) : 0;

  // Compute and constrain map view to the fire area (zones + vicinity)
  useEffect(() => {
    if (!mapReady || !mapRef.current) return;
    const map = mapRef.current;

    // Helper: compute [w, s, e, n] bounds
    const computeBounds = (): [number, number, number, number] | null => {
      try {
        if (zones && zones.length > 0) {
          let w = Infinity, s = Infinity, e = -Infinity, n = -Infinity;
          for (const z of zones) {
            if (z.geomType === "circle" && z.centerLat != null && z.centerLng != null && z.radiusM) {
              const poly = circlePolygon({ lat: z.centerLat, lng: z.centerLng }, z.radiusM, 64).geometry.coordinates[0];
              for (const [lng, lat] of poly) {
                if (lng < w) w = lng;
                if (lng > e) e = lng;
                if (lat < s) s = lat;
                if (lat > n) n = lat;
              }
            } else if (z.polygon && z.polygon.length > 0) {
              for (const [lng, lat] of z.polygon) {
                if (lng < w) w = lng;
                if (lng > e) e = lng;
                if (lat < s) s = lat;
                if (lat > n) n = lat;
              }
            }
          }
          if (isFinite(w) && isFinite(s) && isFinite(e) && isFinite(n)) return [w, s, e, n];
        }
        // Fallback to fire center + radius if no zones
        const lat = fire.lat;
        const lng = fire.lng;
        const r = Math.max(200, fire.radiusM || 500); // ensure minimal radius
        const degLat = r / 111320; // ~ meters per degree latitude
        const degLng = r / (111320 * Math.cos((lat * Math.PI) / 180) || 1);
        return [lng - degLng, lat - degLat, lng + degLng, lat + degLat];
      } catch {
        return null;
      }
    };

    // Helper: expand bounds by a factor (relative to width/height) plus a small constant margin
    const expand = (b: [number, number, number, number], factor = 0.3): [number, number, number, number] => {
      const [w, s, e, n] = b;
      const width = Math.max(1e-5, e - w);
      const height = Math.max(1e-5, n - s);
      const kx = width * factor + 0.002; // ~200m lon margin near equator
      const ky = height * factor + 0.002; // ~200m lat margin
      return [w - kx, s - ky, e + kx, n + ky];
    };

    const raw = computeBounds();
    if (!raw) return;

    // Soft fit for viewport, wider bounds to limit panning
    const fit = expand(raw, 0.35);
    const clamp = expand(raw, 0.9);

    try {
      // Apply bounds and min/max zoom constraints
      map.setMaxBounds([[clamp[0], clamp[1]], [clamp[2], clamp[3]]]);
      map.setMaxZoom(19);

      // Fit view and then prevent zooming out too far
      map.fitBounds([[fit[0], fit[1]], [fit[2], fit[3]]], { padding: 60, maxZoom: 17, duration: 600 });
      map.once("moveend", () => {
        try {
          // Allow zooming out only a bit from the fitted view
          const current = map.getZoom();
          map.setMinZoom(Math.max(11, current - 1.2));
        } catch {}
      });
    } catch {}
  }, [mapReady, zonesLoaded, zones, fire.id, fire.lat, fire.lng, fire.radiusM]);

  return (
    <div className="w-full min-h-screen">
      <div className="relative h-[65vh] w-full">
        <div id="map-container" ref={mapContainerRef} className="absolute inset-0 h-full w-full" />

        <MapProvider
          mapContainerRef={mapContainerRef}
          initialViewState={{ longitude: centerForMap.lng, latitude: centerForMap.lat, zoom: 15 }}
          styleUrl="mapbox://styles/mapbox/satellite-streets-v12"
          onMapLoad={(map) => {
            // NEW: безопасно презареждаме зоните точно когато стилът/картата са готови
            mapRef.current = map;
            setMapReady(true);
            loadZones();
          }}
        >
          <MapControls />
          {zonesLoaded && zones.length === 0 && (
            <FireMarker id={fire.id} lat={fire.lat} lng={fire.lng} />
          )}

          {zones.length > 0 && <ZoneShapes zones={zones as any} onChange={loadZones} />}

          {showZoneCreator && canEditZones && (
            <div className="absolute top-4 left-4 z-10">
              <ZoneDraw
                fireId={fire.id}
                onCreated={() => {
                  setShowZoneCreator(false);
                  loadZones();
                }}
                onClose={() => setShowZoneCreator(false)}
              />
            </div>
          )}
        </MapProvider>

        <div className="absolute top-4 right-4 z-10 flex items-center gap-2">
          <Badge variant="secondary" className="shadow-lg">Пожар #{fire.id}</Badge>
        </div>

        {canEditZones && !showZoneCreator && (
          <div className="absolute top-4 left-4 z-10">
            <Button size="sm" className="rounded-full shadow-md" onClick={() => setShowZoneCreator(true)} title="Създай зона">
              <Plus className="h-4 w-4 mr-1" />
              Създай зона
            </Button>
          </div>
        )}
      </div>

      <div className="max-w-6xl mx-auto w-full px-4 py-6">
        {deactStatus?.status === 'inactive' && (
          <div className="mb-4 text-sm bg-muted rounded-md p-3">Този пожар е неактивен (скрит от картата).</div>
        )}
        {myZone && (
          <div className="mb-6">
            <Button
              size="lg"
              className="w-full sm:w-auto h-12 text-base sm:text-lg px-6 rounded-xl shadow-lg hover:shadow-xl"
              onClick={() => router.push(`/fires/${fire.id}/zones/${myZone.id}`)}
              title="Виж моята зона"
              aria-label="Виж моята зона"
            >
              <User2 className="h-5 w-5 mr-2" />
              Виж моята зона
            </Button>
          </div>
        )}
        <div className="grid gap-4 grid-cols-1 md:grid-cols-[1.2fr_1fr]">
          <Card className="overflow-hidden min-w-0">
            <CardHeader>
              <CardTitle>Основни данни</CardTitle>
            </CardHeader>
            <CardContent className="space-y-2 text-sm text-muted-foreground">
              <div>
                Статус: <span className="text-foreground font-medium">{fire.status}</span>
              </div>
              <div>
                Радиус: <span className="text-foreground font-medium">{metersToReadable(fire.radiusM)}</span>
              </div>
              <div>
                Координати: <span className="text-foreground font-medium">{fire.lat.toFixed(5)}, {fire.lng.toFixed(5)}</span>
              </div>
              <div>
                Създаден: <span className="text-foreground font-medium" suppressHydrationWarning>{new Date(fire.createdAt).toLocaleString()}</span>
              </div>

              <Separator className="my-3" />

              <div className="flex flex-wrap gap-2">
                <Button
                  variant="outline"
                  size="sm"
                  onClick={() =>
                    window.open(
                      `https://www.google.com/maps/dir/?api=1&destination=${fire.lat},${fire.lng}`,
                      "_blank",
                    )
                  }
                >
                  <Navigation className="h-4 w-4 mr-1.5" />
                  Навигация
                </Button>

                {viewer === "none" && (
                  <Button size="sm" disabled={isPending} onClick={claim}>
                    {isPending ? "Заявяване…" : "Заяви да съм доброволец"}
                  </Button>
                )}
                {viewer === "requested" && (
                  <Button size="sm" variant="secondary" disabled>
                    Заявено — чака потвърждение
                  </Button>
                )}
                {viewer === "confirmed" && (
                  <Button
                    size="sm"
                    onClick={generateQR}
                    disabled={isPending}
                    className="w-full sm:w-auto h-auto min-h-8 py-2 whitespace-normal break-words text-center"
                  >
                    <QrCode className="h-4 w-4 mr-1.5" />
                    Генерирай QR за присъединяване
                  </Button>
                )}
              </div>
            </CardContent>
          </Card>

          <Card className="overflow-hidden min-w-0">
            <CardHeader>
              <CardTitle className="flex items-center justify-between">
                <span>Доброволци</span>
                <span className="text-sm font-normal text-muted-foreground flex items-center gap-3">
                  <span className="inline-flex items-center gap-1">
                    <Users className="h-4 w-4" /> {confirmed.length}
                  </span>
                  <span className="inline-flex items-center gap-1">
                    <User2 className="h-4 w-4" /> {requested.length}
                  </span>
                </span>
              </CardTitle>
            </CardHeader>
            <CardContent className="space-y-4">
              <div>
                <div className="text-xs uppercase text-muted-foreground mb-1">Потвърдени</div>
                {confirmed.length === 0 ? (
                  <div className="text-sm text-muted-foreground">Няма.</div>
                ) : (
                  <ul className="space-y-1">
                    {confirmed.map((r) => (
                      <li key={`c-${r.userId}`} className="text-sm">
                        <span className="font-medium text-foreground break-words">{r.name || r.email}</span>
                      </li>
                    ))}
                  </ul>
                )}
              </div>

              <Separator />

              <div>
                <div className="text-xs uppercase text-muted-foreground mb-1">Заявили</div>
                {requested.length === 0 ? (
                  <div className="text-sm text-muted-foreground">Няма чакащи.</div>
                ) : (
                  <ul className="space-y-2">
                    {requested.map((r) => (
                      <li key={`r-${r.userId}`} className="flex items-center justify-between gap-2 flex-wrap">
                        <div className="text-sm min-w-0 max-w-full">
                          <span className="font-medium text-foreground break-words">{r.name || r.email}</span>
                          <span className="text-muted-foreground" suppressHydrationWarning> — от {new Date(r.createdAt).toLocaleString()}</span>
                        </div>
                        {viewer === "confirmed" ? (
                          <Button size="sm" variant="outline" onClick={() => approve(r.userId)} disabled={isPending}>
                            <Check className="h-4 w-4 mr-1" />
                            Потвърди
                          </Button>
                        ) : (
                          <Badge variant="secondary">Чака потвърждение</Badge>
                        )}
                      </li>
                    ))}
                  </ul>
                )}
              </div>
            </CardContent>
          </Card>
        </div>

        <div className="mt-4">
          <Card>
            <CardHeader>
              <div className="flex items-center justify-between gap-3 flex-wrap">
                <CardTitle>Зони на пожара</CardTitle>
                {viewer === "confirmed" && deactStatus?.status === 'active' && (
                  <div className="flex items-center gap-2 text-sm">
                    <Button size="sm" variant="outline" onClick={voteDeactivate} disabled={deactLoading || deactStatus?.hasVoted} title="Гласувай за деактивиране">
                      {deactStatus?.hasVoted ? 'Гласувахте' : 'Маркирай като неактивен'}
                    </Button>
                    <span className="text-muted-foreground">Гласове: {deactStatus?.votes ?? 0}/{deactStatus?.required ?? 0}</span>
                  </div>
                )}
              </div>
            </CardHeader>
            <CardContent>
              <ZoneList fireId={fire.id} canEdit={canEditZones} onChange={loadZones} refreshAt={zonesRefreshAt} />
            </CardContent>
          </Card>
        </div>
      </div>

      {/* Floating Chat Panel (fixed, doesn't move the button) */}
      {chatOpen && (
        <div className="fixed bottom-24 left-1/2 -translate-x-1/2 sm:left-auto sm:translate-x-0 sm:right-4 z-30 w-[min(420px,calc(100vw-1rem))] max-h-[70vh] bg-background/95 backdrop-blur border rounded-xl shadow-xl p-3">
          <div className="flex items-center justify-between mb-2 gap-2">
            <div className="inline-flex p-0.5 bg-muted rounded-full">
              <Button size="sm" variant={activeChat === "fire" ? "default" : "ghost"} className="rounded-full" onClick={() => setActiveChat("fire")}>
                Общ чат {counts[fireConnect] ? <span className="ml-1 text-xs bg-red-600 text-white rounded-full px-1">{counts[fireConnect] > 99 ? "99+" : counts[fireConnect]}</span> : null}
              </Button>
              <Button size="sm" variant={activeChat === "zone" ? "default" : "ghost"} className="rounded-full" onClick={() => setActiveChat("zone")} disabled={!zoneConnect}>
                Зона {myZone?.title ? `(${myZone.title})` : ""} {zoneConnect && counts[zoneConnect] ? <span className="ml-1 text-xs bg-red-600 text-white rounded-full px-1">{counts[zoneConnect] > 99 ? "99+" : counts[zoneConnect]}</span> : null}
              </Button>
            </div>
            <Button size="icon" variant="ghost" onClick={() => setChatOpen(false)}>
              <X className="h-4 w-4" />
            </Button>
          </div>
          {activeChat === "fire" && <SendbirdChat connectUrl={fireConnect} />}
          {activeChat === "zone" && zoneConnect && <SendbirdChat connectUrl={zoneConnect} />}
          {activeChat === "zone" && !zoneConnect && (
            <div className="text-sm text-muted-foreground py-10 text-center">Не сте член на зона. Влезте в зона, за да видите чат.</div>
          )}
        </div>
      )}

      {/* Unread pill (fixed near the button, no layout shift) */}
      {!chatOpen && unreadCount > 0 && (
        <div className="fixed bottom-6 left-1/2 -translate-x-1/2 sm:left-auto sm:translate-x-0 sm:right-24 z-30 max-w-[calc(100vw-1rem)]">
          <button
            type="button"
            onClick={() => setChatOpen(true)}
            className="rounded-full bg-primary text-primary-foreground px-3 py-1.5 shadow-lg hover:opacity-95 transition"
            title="Отвори чата"
          >
            Имаш {unreadCount} непрочетени — Общ: {fireUnread}{zoneConnect ? `, Зона: ${zoneUnread}` : ""}
          </button>
        </div>
      )}

      {/* Floating Chat Button (fixed anchor) */}
      <div className="fixed bottom-4 right-4 z-40">
        <div className="relative">
          <Button size="icon" className="rounded-full h-12 w-12 shadow-lg" onClick={() => setChatOpen((v) => !v)} title="Чат">
            <MessageCircle className="h-6 w-6" />
          </Button>
          {unreadCount > 0 && !chatOpen && (
            <span className="absolute -top-1 -right-1 min-w-5 h-5 px-1 rounded-full bg-red-600 text-white text-xs flex items-center justify-center shadow">
              {unreadCount > 99 ? "99+" : unreadCount}
            </span>
          )}
        </div>
      </div>

      <Dialog open={isQR} onOpenChange={setIsQR}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>Присъединяване чрез QR</DialogTitle>
            <DialogDescription>
              Сканирай или сподели този код — сканиращият става потвърден доброволец в този пожар.
            </DialogDescription>
          </DialogHeader>
          <div className="flex flex-col items-center justify-center gap-3">
            {qrImg ? (
              // eslint-disable-next-line @next/next/no-img-element
              <img src={qrImg} alt="QR" className="rounded-md border" />
            ) : (
              <div className="text-sm text-muted-foreground">Генериране…</div>
            )}
            {qrUrl && <div className="text-xs break-all text-muted-foreground max-w-full">{qrUrl}</div>}
            {qrUrl && (
              <div className="flex gap-2">
                <Button size="sm" variant="outline" onClick={() => navigator.clipboard?.writeText(qrUrl)}>
                  Копирай линк
                </Button>
                <a href={qrUrl} target="_blank" rel="noreferrer">
                  <Button size="sm">Отвори</Button>
                </a>
              </div>
            )}
          </div>
        </DialogContent>
      </Dialog>
    </div>
  );
}
\n===== END FILE: app/fires/[id]/client.tsx =====\n
===== FILE: app/fires/[id]/join/page.tsx =====
import Link from "next/link";
import { auth0 } from "@/lib/auth0";
import { joinWithToken, getFireById } from "@/app/actions/fires";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";

export const runtime = "nodejs";
export const revalidate = 0;

export default async function JoinWithTokenPage({
  params,
  searchParams,
}: {
  params: Promise<{ id: string }>;
  searchParams: Promise<{ token?: string }>;
}) {
  const { id } = await params;
  const fireId = Number(id);
  const { token = "" } = await searchParams;
  const fire = await getFireById(fireId);
  if (!fire) {
    return (
      <main className="container mx-auto p-6">
        <Card className="max-w-lg mx-auto">
          <CardHeader><CardTitle>Пожарът не е намерен</CardTitle></CardHeader>
          <CardContent><Link href="/fires"><Button variant="outline">Към всички пожари</Button></Link></CardContent>
        </Card>
      </main>
    );
  }

  const session = await auth0.getSession();
  const user = session?.user;

  if (!user) {
    const ret = encodeURIComponent(`/fires/${fireId}/join?token=${encodeURIComponent(token)}`);
    return (
      <main className="container mx-auto p-6">
        <Card className="max-w-lg mx-auto">
          <CardHeader><CardTitle>Необходими са права</CardTitle></CardHeader>
          <CardContent className="space-y-3">
            <p className="text-sm text-muted-foreground">За да се присъединиш като доброволец, влез в профила си.</p>
            <a href={`/auth/login?returnTo=${ret}`}><Button>Вход</Button></a>
          </CardContent>
        </Card>
      </main>
    );
  }

  const res = await joinWithToken(fireId, token);

  return (
    <main className="container mx-auto p-6">
      <Card className="max-w-lg mx-auto">
        <CardHeader>
          <CardTitle>{res.ok ? "Успешно присъединяване" : "Неуспешно присъединяване"}</CardTitle>
        </CardHeader>
        <CardContent className="space-y-3">
          <p className="text-sm text-muted-foreground">
            {res.ok ? "Ти вече си потвърден доброволец за този пожар." : (res.error || "Невалиден или изтекъл токен.")}
          </p>
          <Link href={`/fires/${fireId}`}><Button>Към пожара</Button></Link>
        </CardContent>
      </Card>
    </main>
  );
}
\n===== END FILE: app/fires/[id]/join/page.tsx =====\n
===== FILE: app/fires/[id]/page.tsx =====
import { notFound } from "next/navigation";
import {
  getFireById,
  volunteersForFire,
  myVolunteerStatus,
  claimVolunteer,
  approveVolunteer,
  generateJoinToken,
} from "@/app/actions/fires";
import FireDetailsClient from "./client";

export const runtime = "nodejs";
export const revalidate = 0;

export default async function FireDetailPage({ params }: { params: Promise<{ id: string }> }) {
  const { id } = await params;
  const fireId = Number(id);
  if (!Number.isFinite(fireId)) notFound();

  const fire = await getFireById(fireId);
  if (!fire) notFound();

  const { confirmed, requested } = await volunteersForFire(fireId);
  const viewerStatus = await myVolunteerStatus(fireId);

  const joinBaseUrl = process.env.APP_BASE_URL || "";

  return (
    <FireDetailsClient
      fire={{
        id: fire.id,
        lat: fire.lat,
        lng: fire.lng,
        radiusM: fire.radiusM,
        status: fire.status,
        createdAt: typeof fire.createdAt === "string" ? fire.createdAt : new Date(fire.createdAt).toISOString(),
      }}
      viewerStatus={viewerStatus}
      initialVolunteers={{
        confirmed: confirmed.map((r) => ({
          ...r,
          createdAt: typeof r.createdAt === "string" ? r.createdAt : new Date(r.createdAt as any).toISOString(),
          email: (r as any).email ?? "",
        })),
        requested: requested.map((r) => ({
          ...r,
          createdAt: typeof r.createdAt === "string" ? r.createdAt : new Date(r.createdAt as any).toISOString(),
          email: (r as any).email ?? "",
        })),
      }}
      claimAction={claimVolunteer}
      approveAction={approveVolunteer}
      generateTokenAction={generateJoinToken}
      joinBaseUrl={joinBaseUrl}
    />
  );
}
\n===== END FILE: app/fires/[id]/page.tsx =====\n
===== FILE: app/fires/[id]/zones/[zoneId]/client.tsx =====
// app/fires/[id]/zones/[zoneId]/client.tsx
"use client";

import { useMemo, useState } from "react";
import { Card, CardHeader, CardTitle, CardContent } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Separator } from "@/components/ui/separator";
import { AspectRatio } from "@/components/ui/aspect-ratio";
import { Tabs, TabsList, TabsTrigger, TabsContent } from "@/components/ui/tabs";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import {
  Users,
  ArrowLeft,
  Image as ImageIcon,
  MessageCircle,
  X,
  Loader2,
  PencilLine,
} from "lucide-react";
import { circlePolygon } from "@/lib/geo";
import ImageUploader from "@/components/uploads/image-uploader";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";

const TOKEN = process.env.NEXT_PUBLIC_MAPBOX_TOKEN;
const STYLE = "satellite-streets-v12";

function buildStaticMapPreview(z: any) {
  if (!TOKEN) return null;
  const path = (() => {
    if (
      z.geomType === "circle" &&
      z.centerLat != null &&
      z.centerLng != null &&
      z.radiusM
    ) {
      const poly = circlePolygon(
        { lat: z.centerLat, lng: z.centerLng },
        z.radiusM,
        60
      ).geometry.coordinates[0];
      const pts = poly
        .map(([lng, lat]: [number, number]) => `${lng.toFixed(6)},${lat.toFixed(6)}`)
        .join(";");
      return `path-3+dc2626-80(${pts})`;
    }
    const ring = (z.polygon || []).concat([(z.polygon || [])[0] || [0, 0]]);
    const pts = ring.map(([lng, lat]: [number, number]) => `${lng},${lat}`).join(";");
    return `path-3+dc2626-80(${pts})`;
  })();

  const overlay = encodeURIComponent(path);
  const size = "1200x500@2x";
  return `https://api.mapbox.com/styles/v1/mapbox/${STYLE}/static/${overlay}/auto/${size}?padding=60&access_token=${TOKEN}`;
}

function initials(name?: string | null, email?: string) {
  const src = (name || email || "").trim();
  if (!src) return "U";
  const parts = src.split(/\s+/);
  if (parts.length >= 2) return (parts[0][0] + parts[1][0]).toUpperCase();
  const m = src.match(/[A-Za-zА-Яа-я]/g);
  if (!m) return src.slice(0, 2).toUpperCase();
  return m.slice(0, 2).join("").toUpperCase();
}

export default function ZoneDetailsClient({
  fireId,
  zoneId,
  data,
  canEdit,
}: {
  fireId: number;
  zoneId: number;
  data: {
    ok: true;
    zone: any;
    members: {
      userId: number;
      name: string | null;
      email: string;
      joinedAt: string;
      avatarUrl?: string | null;
    }[];
    coverUrl?: string | null;
    updates: {
      id: number;
      text: string | null;
      createdAt: string;
      userId: number;
      name: string | null;
      email: string;
      images: { id: number; url: string }[];
    }[];
    myZoneId?: number | null;
    isMember?: boolean;
    viewerUserId?: number | null;
  };
  canEdit: boolean;
}) {
  const z = data.zone;
  const [joining, setJoining] = useState(false);
  const [leaving, setLeaving] = useState(false);

  // ---- Meta edit state (в таб "Информация") ----
  const [editingMeta, setEditingMeta] = useState(false);
  const [metaTitle, setMetaTitle] = useState<string>(z.title || "");
  const [metaDesc, setMetaDesc] = useState<string>(z.description || "");
  const [savingMeta, setSavingMeta] = useState(false);

  async function join() {
    setJoining(true);
    try {
      const res = await fetch(`/api/fires/${fireId}/zones/${zoneId}/join`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ action: "join" }),
      }).then((r) => r.json());
      if (!res?.ok) throw new Error(res?.error || "Възникна грешка.");
      location.reload();
    } catch (e: any) {
      alert(e?.message || "Възникна грешка.");
    } finally {
      setJoining(false);
    }
  }

  async function leave() {
    if (!confirm("Сигурни ли сте, че искате да напуснете зоната?")) return;
    setLeaving(true);
    try {
      const res = await fetch(`/api/fires/${fireId}/zones/0/join`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ action: "leave" }),
      }).then((r) => r.json());
      if (!res?.ok) throw new Error(res?.error || "Възникна грешка.");
      location.href = `/fires/${fireId}`;
    } catch (e: any) {
      alert(e?.message || "Възникна грешка.");
    } finally {
      setLeaving(false);
    }
  }

  async function saveMeta() {
    setSavingMeta(true);
    try {
      const res = await fetch(`/api/fires/${fireId}/zones/${zoneId}`, {
        method: "PATCH",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ title: metaTitle, description: metaDesc }),
      }).then((r) => r.json());
      if (!res?.ok) throw new Error(res?.error || "Неуспешно запазване.");
      location.reload();
    } catch (e: any) {
      alert(e?.message || "Възникна грешка.");
    } finally {
      setSavingMeta(false);
    }
  }

  const cover = data.coverUrl || buildStaticMapPreview(z);
  const isMember = !!data.isMember;
  const inAnotherZone = data.myZoneId != null && data.myZoneId !== zoneId;

  // ---- Чат (lazy import за избягване на SSR проблеми) ----
  const SendbirdChat = require("@/components/chat/sendbird-chat").default;
  const { useSendbirdUnreadMany } = require("@/hooks/useSendbirdUnreadMany");
  const [chatOpen, setChatOpen] = useState(false);
  const [activeChat, setActiveChat] = useState<"fire" | "zone">("zone");
  const fireConnect = `/api/fires/${fireId}/chat/connect`;
  const zoneConnect = isMember ? `/api/fires/${fireId}/zones/${zoneId}/chat/connect` : null;
  const activeConnectUrl =
    activeChat === "zone" && zoneConnect ? zoneConnect : fireConnect;
  const { total: unreadCount, counts } = useSendbirdUnreadMany(
    [fireConnect, ...(zoneConnect ? [zoneConnect] : [])],
    chatOpen,
    activeConnectUrl
  );
  const fireUnread = counts?.[fireConnect] || 0;
  const zoneUnread = zoneConnect ? counts?.[zoneConnect] || 0 : 0;

  // ----- Composer state -----
  const [postText, setPostText] = useState("");
  const [postImages, setPostImages] = useState<{ key: string; url: string }[]>(
    []
  );
  const [posting, setPosting] = useState(false);

  async function submitPost() {
    if (!postText.trim() && postImages.length === 0) return;
    setPosting(true);
    try {
      const res = await fetch(`/api/fires/${fireId}/zones/${zoneId}/updates`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ text: postText.trim(), images: postImages }),
      }).then((r) => r.json());
      if (!res?.ok)
        throw new Error(
          res?.error || "Възникна грешка при публикуването."
        );
      location.reload();
    } catch (e: any) {
      alert(e?.message || "Възникна грешка.");
    } finally {
      setPosting(false);
    }
  }

  // ----- Edit update state -----
  const [editingId, setEditingId] = useState<number | null>(null);
  const [editText, setEditText] = useState("");
  const [editAddImages, setEditAddImages] = useState<
    { key: string; url: string }[]
  >([]);
  const [editRemoveImageIds, setEditRemoveImageIds] = useState<number[]>([]);

  function startEdit(u: any) {
    setEditingId(u.id);
    setEditText(u.text || "");
    setEditAddImages([]);
    setEditRemoveImageIds([]);
  }

  function cancelEdit() {
    setEditingId(null);
    setEditText("");
    setEditAddImages([]);
    setEditRemoveImageIds([]);
  }

  async function saveEdit() {
    if (editingId == null) return;
    const payload: any = { text: editText };
    if (editAddImages.length) payload.addImages = editAddImages;
    if (editRemoveImageIds.length) payload.removeImageIds = editRemoveImageIds;
    const res = await fetch(
      `/api/fires/${fireId}/zones/${zoneId}/updates/${editingId}`,
      {
        method: "PATCH",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload),
      }
    ).then((r) => r.json());
    if (!res?.ok) {
      alert(res?.error || "Неуспешно запазване на редакцията.");
      return;
    }
    location.reload();
  }

  return (
    <div className="max-w-6xl mx-auto w-full px-4 py-6">
      {/* Top bar */}
      <div className="mb-4 flex items-center justify-between gap-3">
        <a
          href={`/fires/${fireId}`}
          className="inline-flex items-center text-sm text-muted-foreground hover:text-foreground"
        >
          <ArrowLeft className="h-4 w-4 mr-1" />
          Назад към пожара
        </a>

        <div className="flex items-center gap-2">
          <Badge variant="secondary" className="whitespace-nowrap">
            <Users className="h-3.5 w-3.5 mr-1" />
            {data.members.length} член{data.members.length === 1 ? "" : "а"}
          </Badge>

          {isMember ? (
            <Button variant="outline" onClick={leave} disabled={leaving}>
              {leaving ? (
                <>
                  <Loader2 className="h-4 w-4 animate-spin" />
                  Напускане…
                </>
              ) : (
                "Напусни зоната"
              )}
            </Button>
          ) : (
            <Button onClick={join} disabled={joining}>
              {joining ? (
                <>
                  <Loader2 className="h-4 w-4 animate-spin" />
                  Присъединяване…
                </>
              ) : inAnotherZone ? (
                "Присъедини се към тази зона"
              ) : (
                "Присъедини се към зоната"
              )}
            </Button>
          )}
        </div>
      </div>

      {/* Main layout */}
      <div className="grid gap-6 lg:grid-cols-[2fr,1fr]">
        {/* Left column */}
        <Card className="overflow-hidden">
          <CardHeader className="pb-0">
            <CardTitle className="flex items-center justify-between gap-2">
              <div className="truncate">
                {z.title || `Зона #${z.id}`}
              </div>
              {canEdit && (
                <Button
                  size="sm"
                  variant={editingMeta ? "secondary" : "outline"}
                  onClick={() => {
                    setEditingMeta(true);
                    // Превключваме към таб "info" чрез URL hash (без сложни state машинарии)
                    const el = document.getElementById("tab-info-trigger");
                    (el as HTMLButtonElement | null)?.click?.();
                  }}
                >
                  <PencilLine className="h-4 w-4 mr-1" />
                  Редактирай
                </Button>
              )}
            </CardTitle>
          </CardHeader>

          <CardContent className="pt-4">
            <Tabs defaultValue="updates" className="w-full">
              <TabsList className="w-full">
                <TabsTrigger value="updates" className="flex-1">
                  Активност
                </TabsTrigger>
                <TabsTrigger value="members" className="flex-1">
                  Членове
                </TabsTrigger>
                <TabsTrigger id="tab-info-trigger" value="info" className="flex-1">
                  Информация
                </TabsTrigger>
              </TabsList>

              {/* === Updates === */}
              <TabsContent value="updates" className="mt-4">
                {isMember && (
                  <>
                    {canEdit ? (
                      <div className="rounded-md border p-3 bg-muted/20 space-y-2 overflow-hidden mb-4">
                        <Textarea
                          className="w-full min-h-[100px]"
                          placeholder="Какво се случва? Сподели текст и/или снимки…"
                          value={postText}
                          onChange={(e) => setPostText(e.target.value)}
                        />
                        {postImages.length > 0 && (
                          <div className="grid grid-cols-2 sm:grid-cols-3 gap-2">
                            {postImages.map((im, idx) => (
                              <div key={idx} className="relative">
                                {/* eslint-disable-next-line @next/next/no-img-element */}
                                <img
                                  src={im.url}
                                  alt=""
                                  className="h-[120px] w-full object-cover rounded-md border"
                                />
                                <button
                                  type="button"
                                  className="absolute top-1 right-1 inline-flex h-6 w-6 items-center justify-center rounded-full bg-black/60 text-white text-xs"
                                  onClick={() =>
                                    setPostImages((arr) =>
                                      arr.filter((_, i) => i !== idx)
                                    )
                                  }
                                  title="Премахни"
                                >
                                  ×
                                </button>
                              </div>
                            ))}
                          </div>
                        )}
                        <div className="flex flex-wrap items-center gap-2">
                          <div className="min-w-[160px]">
                            <ImageUploader
                              prefix={`fires/${fireId}/zones/${zoneId}/updates`}
                              onUploaded={(f) =>
                                setPostImages((arr) => [
                                  ...arr,
                                  { key: f.key, url: f.url },
                                ])
                              }
                            />
                          </div>
                          <div className="flex gap-2 w-full sm:w-auto sm:ml-auto">
                            <Button
                              className="flex-1 sm:flex-none"
                              variant="outline"
                              disabled={
                                posting ||
                                (!postText.trim() && postImages.length === 0)
                              }
                              onClick={() => {
                                setPostText("");
                                setPostImages([]);
                              }}
                            >
                              Изчистване
                            </Button>
                            <Button
                              className="flex-1 sm:flex-none"
                              onClick={submitPost}
                              disabled={
                                posting ||
                                (!postText.trim() && postImages.length === 0)
                              }
                            >
                              {posting ? (
                                <>
                                  <Loader2 className="h-4 w-4 animate-spin" />
                                  Публикуване…
                                </>
                              ) : (
                                "Публикувай"
                              )}
                            </Button>
                          </div>
                        </div>
                      </div>
                    ) : (
                      <div className="text-sm text-muted-foreground mb-4">
                        Нямате права да публикувате в тази зона.
                      </div>
                    )}
                  </>
                )}

                {/* Feed */}
                {isMember ? (
                  data.updates.length === 0 ? (
                    <div className="text-sm text-muted-foreground">
                      Още няма публикации.
                    </div>
                  ) : (
                    <ul className="space-y-3">
                      {data.updates.map((u) => (
                        <li key={u.id} className="text-sm rounded-md border p-3 bg-card">
                          <div className="flex items-start justify-between gap-2">
                            <div className="flex items-center gap-2 min-w-0">
                              <Avatar className="h-8 w-8">
                                <AvatarImage src={undefined} alt="" />
                                <AvatarFallback>
                                  {initials(u.name, u.email)}
                                </AvatarFallback>
                              </Avatar>
                              <div className="min-w-0">
                                <div className="font-medium break-words">
                                  {u.name || u.email}
                                </div>
                                <div className="text-xs text-muted-foreground">
                                  {new Date(u.createdAt).toLocaleString("bg-BG")}
                                </div>
                              </div>
                            </div>
                            {u.userId === data.viewerUserId && (
                              <div className="flex gap-2">
                                {editingId === u.id ? (
                                  <>
                                    <Button
                                      size="sm"
                                      variant="outline"
                                      onClick={cancelEdit}
                                    >
                                      Отказ
                                    </Button>
                                    <Button size="sm" onClick={saveEdit}>
                                      Запази
                                    </Button>
                                  </>
                                ) : (
                                  <Button
                                    size="sm"
                                    variant="outline"
                                    onClick={() => startEdit(u)}
                                  >
                                    Редактирай
                                  </Button>
                                )}
                              </div>
                            )}
                          </div>

                          {editingId === u.id ? (
                            <div className="mt-2 space-y-2 overflow-hidden">
                              <Textarea
                                className="w-full min-h-[100px]"
                                value={editText}
                                onChange={(e) => setEditText(e.target.value)}
                              />
                              {u.images?.length > 0 && (
                                <div className="grid grid-cols-2 sm:grid-cols-3 gap-2">
                                  {u.images.map((im: any) => (
                                    <div key={im.id} className="relative">
                                      {/* eslint-disable-next-line @next/next/no-img-element */}
                                      <img
                                        src={im.url}
                                        alt=""
                                        className="h-[120px] w-full object-cover rounded-md border"
                                      />
                                      <button
                                        type="button"
                                        className="absolute top-1 right-1 inline-flex h-6 w-6 items-center justify-center rounded-full bg-black/60 text-white text-xs"
                                        onClick={() =>
                                          setEditRemoveImageIds((arr) =>
                                            arr.includes(im.id)
                                              ? arr
                                              : [...arr, im.id]
                                          )
                                        }
                                        title="Премахни"
                                      >
                                        ×
                                      </button>
                                    </div>
                                  ))}
                                </div>
                              )}
                              {editAddImages.length > 0 && (
                                <div className="grid grid-cols-2 sm:grid-cols-3 gap-2">
                                  {editAddImages.map((im, idx) => (
                                    <div key={idx} className="relative">
                                      {/* eslint-disable-next-line @next/next/no-img-element */}
                                      <img
                                        src={im.url}
                                        alt=""
                                        className="h-[120px] w-full object-cover rounded-md border"
                                      />
                                      <button
                                        type="button"
                                        className="absolute top-1 right-1 inline-flex h-6 w-6 items-center justify-center rounded-full bg-black/60 text-white text-xs"
                                        onClick={() =>
                                          setEditAddImages((arr) =>
                                            arr.filter((_, i) => i !== idx)
                                          )
                                        }
                                        title="Премахни"
                                      >
                                        ×
                                      </button>
                                    </div>
                                  ))}
                                </div>
                              )}
                              <div className="flex flex-wrap items-center gap-2">
                                <div className="min-w-[160px]">
                                  <ImageUploader
                                    prefix={`fires/${fireId}/zones/${zoneId}/updates`}
                                    onUploaded={(f) =>
                                      setEditAddImages((arr) => [
                                        ...arr,
                                        { key: f.key, url: f.url },
                                      ])
                                    }
                                  />
                                </div>
                                {editRemoveImageIds.length > 0 && (
                                  <div className="text-xs text-muted-foreground">
                                    Ще премахнете: {editRemoveImageIds.length} снимки
                                  </div>
                                )}
                              </div>
                            </div>
                          ) : (
                            <div className="mt-2">
                              {u.text && (
                                <div className="text-muted-foreground whitespace-pre-wrap break-words">
                                  {u.text}
                                </div>
                              )}
                              {u.images?.length > 0 && (
                                <div className="mt-2 grid grid-cols-2 sm:grid-cols-3 gap-2">
                                  {u.images.map((im: any) => (
                                    // eslint-disable-next-line @next/next/no-img-element
                                    <img
                                      key={im.id}
                                      src={im.url}
                                      alt=""
                                      className="h-[120px] w-full object-cover rounded-md border"
                                    />
                                  ))}
                                </div>
                              )}
                            </div>
                          )}
                        </li>
                      ))}
                    </ul>
                  )
                ) : (
                  <div className="rounded-md border p-4 bg-muted/30">
                    {inAnotherZone ? (
                      <div className="space-y-3">
                        <div className="text-sm">
                          В момента сте в друга зона за този пожар. Можете да се
                          присъедините към тази, което ще ви премести.
                        </div>
                        <div className="flex flex-wrap gap-2">
                          <Button onClick={join} disabled={joining}>
                            {joining ? (
                              <>
                                <Loader2 className="h-4 w-4 animate-spin" />
                                Присъединяване…
                              </>
                            ) : (
                              "Присъедини се към тази зона"
                            )}
                          </Button>
                          <Button variant="outline" asChild>
                            <a href={`/fires/${fireId}`}>Назад към зоните</a>
                          </Button>
                        </div>
                      </div>
                    ) : (
                      <div className="space-y-3">
                        <div className="text-sm">
                          Не сте член на тази зона. Искате ли да се присъедините?
                        </div>
                        <div className="flex flex-wrap gap-2">
                          <Button onClick={join} disabled={joining}>
                            {joining ? (
                              <>
                                <Loader2 className="h-4 w-4 animate-spin" />
                                Присъединяване…
                              </>
                            ) : (
                              "Присъедини се към зоната"
                            )}
                          </Button>
                          <Button variant="outline" asChild>
                            <a href={`/fires/${fireId}`}>Назад към зоните</a>
                          </Button>
                        </div>
                      </div>
                    )}
                  </div>
                )}
              </TabsContent>

              {/* === Members === */}
              <TabsContent value="members" className="mt-4">
                {!isMember ? (
                  <div className="text-sm text-muted-foreground">
                    Присъединете се, за да видите членовете на зоната.
                  </div>
                ) : data.members.length === 0 ? (
                  <div className="text-sm text-muted-foreground">
                    Няма членове.
                  </div>
                ) : (
                  <ul className="grid sm:grid-cols-2 gap-2">
                    {data.members.map((m) => (
                      <li
                        key={m.userId}
                        className="flex items-center gap-3 rounded-md border p-2"
                      >
                        <Avatar className="h-8 w-8">
                          <AvatarImage src={m.avatarUrl || undefined} alt="" />
                          <AvatarFallback>
                            {initials(m.name, m.email)}
                          </AvatarFallback>
                        </Avatar>
                        <div className="min-w-0">
                          <div className="font-medium break-words">
                            {m.name || m.email}
                          </div>
                          <div className="text-xs text-muted-foreground">
                            от {new Date(m.joinedAt).toLocaleString("bg-BG")}
                          </div>
                        </div>
                      </li>
                    ))}
                  </ul>
                )}
              </TabsContent>

              {/* === Info === */}
              <TabsContent value="info" className="mt-4">
                {editingMeta && canEdit ? (
                  <div className="grid gap-3">
                    <div className="grid gap-1.5">
                      <label className="text-sm text-muted-foreground">
                        Заглавие
                      </label>
                      <Input
                        value={metaTitle}
                        onChange={(e) => setMetaTitle(e.target.value)}
                        placeholder={`Зона #${z.id}`}
                        maxLength={120}
                      />
                    </div>
                    <div className="grid gap-1.5">
                      <label className="text-sm text-muted-foreground">
                        Описание
                      </label>
                      <Textarea
                        value={metaDesc}
                        onChange={(e) => setMetaDesc(e.target.value)}
                        maxLength={4000}
                        placeholder="Добавете ясно и полезно описание…"
                      />
                    </div>
                    <div className="grid gap-1.5">
                      <label className="text-sm text-muted-foreground">
                        Корица (картина или статична карта)
                      </label>
                      <div className="flex items-center gap-3 flex-wrap">
                        {cover ? (
                          // eslint-disable-next-line @next/next/no-img-element
                          <img
                            src={cover}
                            alt="Корица"
                            className="h-[72px] w-[128px] object-cover rounded-md border"
                          />
                        ) : null}
                        <ImageUploader
                          prefix={`fires/${fireId}/zones/${zoneId}/cover`}
                          multiple={false}
                          onUploaded={async (f) => {
                            await fetch(`/api/fires/${fireId}/zones/${zoneId}`, {
                              method: "PATCH",
                              headers: { "Content-Type": "application/json" },
                              body: JSON.stringify({
                                setCoverImage: { url: f.url, key: f.key },
                              }),
                            });
                            location.reload();
                          }}
                        />
                      </div>
                    </div>
                    <div className="flex gap-2">
                      <Button onClick={saveMeta} disabled={savingMeta}>
                        {savingMeta ? (
                          <>
                            <Loader2 className="h-4 w-4 animate-spin" />
                            Запазване…
                          </>
                        ) : (
                          "Запази"
                        )}
                      </Button>
                      <Button
                        variant="outline"
                        onClick={() => {
                          setEditingMeta(false);
                          setMetaTitle(z.title || "");
                          setMetaDesc(z.description || "");
                        }}
                      >
                        Отказ
                      </Button>
                    </div>
                  </div>
                ) : (
                  <>
                    {isMember && z.description ? (
                      <p className="text-muted-foreground">{z.description}</p>
                    ) : (
                      <p className="text-muted-foreground italic">
                        Все още няма описание.
                      </p>
                    )}
                  </>
                )}
              </TabsContent>
            </Tabs>
          </CardContent>
        </Card>

        {/* Right column (sidebar) */}
        <div className="space-y-6 lg:sticky lg:top-20 h-fit">
          <Card className="overflow-hidden">
            {cover ? (
              <AspectRatio ratio={16 / 6}>
                {/* eslint-disable-next-line @next/next/no-img-element */}
                <img
                  src={cover}
                  alt={z.title || `Зона #${z.id}`}
                  className="w-full h-full object-cover"
                />
              </AspectRatio>
            ) : (
              <div className="h-[200px] bg-gradient-to-br from-muted to-background flex items-center justify-center text-muted-foreground">
                <ImageIcon className="h-8 w-8 mr-2" /> Няма корица
              </div>
            )}
            <CardContent className="pt-4">
              <div className="flex items-center justify-between flex-wrap gap-2">
                <Badge variant="secondary">
                  <Users className="h-3.5 w-3.5 mr-1" />
                  {data.members.length} член{data.members.length === 1 ? "" : "а"}
                </Badge>
                {isMember ? (
                  <Button variant="outline" size="sm" onClick={leave} disabled={leaving}>
                    {leaving ? (
                      <>
                        <Loader2 className="h-4 w-4 animate-spin" />
                        Напускане…
                      </>
                    ) : (
                      "Напусни зоната"
                    )}
                  </Button>
                ) : (
                  <Button size="sm" onClick={join} disabled={joining}>
                    {joining ? (
                      <>
                        <Loader2 className="h-4 w-4 animate-spin" />
                        Присъединяване…
                      </>
                    ) : (
                      "Присъедини се"
                    )}
                  </Button>
                )}
              </div>
            </CardContent>
          </Card>
        </div>
      </div>

      {/* Floating Chat Panel */}
      <div>
        {chatOpen && (
          <div className="fixed bottom-24 left-1/2 -translate-x-1/2 sm:left-auto sm:translate-x-0 sm:right-4 z-30 w-[min(420px,calc(100vw-1rem))] max-h-[70vh] bg-background/95 backdrop-blur border rounded-xl shadow-xl p-3">
            <div className="flex items-center justify-between mb-2 gap-2">
              <div className="inline-flex p-0.5 bg-muted rounded-full">
                <button
                  className={`px-3 py-1.5 rounded-full text-sm ${
                    activeChat === "zone"
                      ? "bg-primary text-primary-foreground"
                      : "hover:bg-muted-foreground/10"
                  }`}
                  onClick={() => setActiveChat("zone")}
                  disabled={!zoneConnect}
                >
                  Зона {z.title ? `(${z.title})` : ""}{" "}
                  {zoneConnect && counts?.[zoneConnect] ? (
                    <span className="ml-1 text-xs bg-red-600 text-white rounded-full px-1">
                      {counts[zoneConnect] > 99 ? "99+" : counts[zoneConnect]}
                    </span>
                  ) : null}
                </button>
                <button
                  className={`px-3 py-1.5 rounded-full text-sm ${
                    activeChat === "fire"
                      ? "bg-primary text-primary-foreground"
                      : "hover:bg-muted-foreground/10"
                  }`}
                  onClick={() => setActiveChat("fire")}
                >
                  Чат за пожара{" "}
                  {counts?.[fireConnect] ? (
                    <span className="ml-1 text-xs bg-red-600 text-white rounded-full px-1">
                      {counts[fireConnect] > 99 ? "99+" : counts[fireConnect]}
                    </span>
                  ) : null}
                </button>
              </div>
              <button
                className="h-8 w-8 inline-flex items-center justify-center rounded-md hover:bg-muted"
                onClick={() => setChatOpen(false)}
              >
                <X className="h-4 w-4" />
              </button>
            </div>
            {activeChat === "zone" && zoneConnect && (
              <SendbirdChat connectUrl={zoneConnect} />
            )}
            {activeChat === "zone" && !zoneConnect && (
              <div className="text-sm text-muted-foreground py-10 text-center">
                Нямате достъп до чата на зоната. Присъединете се първо.
              </div>
            )}
            {activeChat === "fire" && <SendbirdChat connectUrl={fireConnect} />}
          </div>
        )}
        {!chatOpen && unreadCount > 0 && (
          <div className="fixed bottom-6 left-1/2 -translate-x-1/2 sm:left-auto sm:translate-x-0 sm:right-24 z-30 max-w-[calc(100vw-1rem)]">
            <button
              type="button"
              onClick={() => setChatOpen(true)}
              className="rounded-full bg-primary text-primary-foreground px-3 py-1.5 shadow-lg hover:opacity-95 transition"
              title="Отвори чата"
            >
              Съобщения {unreadCount} — пожар: {fireUnread}
              {zoneConnect ? `, зона: ${zoneUnread}` : ""}
            </button>
          </div>
        )}
        <div className="fixed bottom-4 right-4 z-40">
          <div className="relative">
            <Button
              size="icon"
              className="rounded-full h-12 w-12 shadow-lg"
              onClick={() => setChatOpen((v: boolean) => !v)}
              title={chatOpen ? "Затвори чата" : "Отвори чата"}
            >
              <MessageCircle className="h-6 w-6" />
            </Button>
            {unreadCount > 0 && !chatOpen && (
              <span className="absolute -top-1 -right-1 min-w-5 h-5 px-1 rounded-full bg-red-600 text-white text-xs flex items-center justify-center shadow">
                {unreadCount > 99 ? "99+" : unreadCount}
              </span>
            )}
          </div>
        </div>
      </div>
    </div>
  );
}

\n===== END FILE: app/fires/[id]/zones/[zoneId]/client.tsx =====\n
===== FILE: app/home-client.tsx =====
"use client";

import { useEffect, useMemo, useRef, useState } from "react";
import MapProvider from "@/lib/mapbox/provider";
import MapControls from "@/components/map/map-controls";
import MapSearch from "@/components/map/map-search";

import FireCircles, { type FireItem } from "@/components/fires/fire-circles";
import FireMarker from "@/components/fires/fire-marker";
import FirePopup from "@/components/fires/fire-popup";
import UserLocationMarker from "@/components/fires/user-location-marker";
import ReportFire from "@/components/fires/report-fire";
import FireList from "@/components/fires/fire-list";
import { haversineMeters } from "@/lib/geo";

// 🆕 FIRMS
import FirmsHotspots from "@/components/fires/firms-hotspots";
type LatLng = { lat: number; lng: number };

export default function HomeClient({
  initialFires,
  createAction,
}: {
  initialFires: FireItem[];
  createAction: (formData: FormData) => Promise<void>;
}) {
  const mapContainerRef = useRef<HTMLDivElement | null>(null);

  const defaultCenter = useMemo<LatLng>(() => ({ lat: 42.6977, lng: 23.3219 }), []); // Sofia
  const [userPos, setUserPos] = useState<LatLng | null>(null);
  const [approxCenter, setApproxCenter] = useState<LatLng | null>(null);

  const [selectedId, setSelectedId] = useState<number | null>(null);

  // Geo + IP fallback
  useEffect(() => {
    let done = false;

    if (navigator.geolocation) {
      navigator.geolocation.getCurrentPosition(
        (pos) => {
          if (done) return;
          done = true;
          const lat = pos.coords.latitude;
          const lng = pos.coords.longitude;
          setUserPos({ lat, lng });
        },
        async () => {
          if (done) return;
          try {
            const r = await fetch("/api/ip-geo");
            const j = await r.json();
            if (j?.latitude && j?.longitude) setApproxCenter({ lat: j.latitude, lng: j.longitude });
          } catch {}
        },
        { enableHighAccuracy: true, maximumAge: 10000, timeout: 8000 },
      );
    } else {
      (async () => {
        try {
          const r = await fetch("/api/ip-geo");
          const j = await r.json();
          if (j?.latitude && j?.longitude) setApproxCenter({ lat: j.latitude, lng: j.longitude });
        } catch {}
      })();
    }
  }, []);

  const centerForMap = userPos ?? approxCenter ?? defaultCenter;

  // Compute proximity-sorted fires on client
  const fires = useMemo(() => {
    const withDistance = initialFires.map((f) => {
      if (!userPos && !approxCenter) return f;
      const origin = userPos ?? approxCenter!;
      return { ...f, distanceM: haversineMeters(origin, { lat: f.lat, lng: f.lng }) };
    });
    if (!userPos && !approxCenter) return withDistance;
    return withDistance.slice().sort((a, b) => (a.distanceM ?? 0) - (b.distanceM ?? 0));
  }, [initialFires, userPos, approxCenter]);

  const selected = selectedId ? fires.find((f) => f.id === selectedId) ?? null : null;

  return (
    <div className="w-full min-h-screen">
      <div className="relative h-[65vh] w-full">
        <div id="map-container" ref={mapContainerRef} className="absolute inset-0 h-full w-full" />

        <MapProvider
          mapContainerRef={mapContainerRef}
          initialViewState={{ longitude: centerForMap.lng, latitude: centerForMap.lat, zoom: 11 }}
        >
          <MapSearch />
          <MapControls />
          {/** Fixed to default streets style; no style switcher */}

          {/* 🆕 FIRMS Live layer (жълто/оранжево) */}
          <FirmsHotspots
            createAction={createAction}
            dedupRadiusM={500}
            days={2}
            minConfidence={0}
            activeFires={fires.map((f) => ({ lat: f.lat, lng: f.lng }))}
          />

          {/* Report Fire via server action */}
          <ReportFire action={createAction} />

          <FireCircles fires={fires} />
          {fires.map((f) => (
            <FireMarker key={f.id} id={f.id} lat={f.lat} lng={f.lng} onClick={(id) => setSelectedId(id)} />
          ))}
          {userPos && <UserLocationMarker lat={userPos.lat} lng={userPos.lng} />}
          {selected && (
            <FirePopup
              id={selected.id}
              lat={selected.lat}
              lng={selected.lng}
              radiusM={selected.radiusM}
              createdAt={selected.createdAt}
              volunteersConfirmed={(selected as any).volunteersConfirmed}
              volunteersRequested={(selected as any).volunteersRequested}
              onClose={() => setSelectedId(null)}
            />
          )}
        </MapProvider>
      </div>

      <div className="mt-6">
        <FireList fires={fires} onFocus={(f) => setSelectedId(f.id)} title="Активни пожари" />
      </div>
    </div>
  );
}
\n===== END FILE: app/home-client.tsx =====\n
===== FILE: app/page.tsx =====
import Header from "./components/header.jsx";
import Hero from "./components/hero.jsx";
import Feature from "./components/feature.jsx";
import CaseStudies from "./components/case.jsx";
import Testimonials from "./components/testimonials.jsx";
import ContactForm from "./components/contact.jsx";
import Footer from "./components/footer.jsx";

export default function Home() {
  return (
    <div>
      <Header />
      <div className="max-w-[1280px] mx-auto">
        <Hero />
        <Feature />
        <CaseStudies />
        <Testimonials />
        <ContactForm />
      </div>
      <Footer />
    </div>
  );
}

\n===== END FILE: app/page.tsx =====\n
===== FILE: app/profile/page.tsx =====
import { auth0 } from "@/lib/auth0"
import Image from "next/image"
import Link from "next/link"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Button } from "@/components/ui/button"

export default async function ProfilePage() {
  const session = await auth0.getSession()
  const user = session?.user

  if (!user) {
    return (
      <main className="container mx-auto p-6">
        <Card className="max-w-md mx-auto">
          <CardHeader>
            <CardTitle>Profile</CardTitle>
          </CardHeader>
          <CardContent className="space-y-4">
            <p className="text-sm text-muted-foreground">You are not logged in.</p>
            <Button asChild>
              <Link href="/auth/login">Login</Link>
            </Button>
          </CardContent>
        </Card>
      </main>
    )
  }

  return (
    <main className="container mx-auto p-6">
      <Card className="max-w-lg mx-auto">
        <CardHeader>
          <CardTitle>Profile</CardTitle>
        </CardHeader>
        <CardContent className="space-y-6">
          <div className="flex items-center gap-4">
            {user.picture && (
              <img
                src={user.picture}
                alt={user.name || "User"}
                width={64}
                height={64}
                className="rounded-full"
              />
            )}
            <div>
              <h2 className="text-lg font-semibold">{user.name || user.email}</h2>
              {user.email && (
                <p className="text-sm text-muted-foreground">{user.email}</p>
              )}
            </div>
          </div>
        </CardContent>
      </Card>
    </main>
  )
}
\n===== END FILE: app/profile/page.tsx =====\n
===== FILE: components.json =====
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "",
    "css": "app/globals.css",
    "baseColor": "neutral",
    "cssVariables": true,
    "prefix": ""
  },
  "iconLibrary": "lucide",
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  }
}
\n===== END FILE: components.json =====\n
===== FILE: components/chat/chat-box.tsx =====
"use client";

import { useEffect, useRef, useState } from "react";
import { Button } from "@/components/ui/button";
import { Textarea } from "@/components/ui/textarea";

type Message = { id: number; userId: number; name?: string | null; email: string; message: string; createdAt: string };

export default function ChatBox({
  fetchUrl,
  postUrl,
  canBlock = false,
  onBlock,
}: {
  fetchUrl: string;
  postUrl: string;
  canBlock?: boolean;
  onBlock?: (userId: number) => void;
}) {
  const [messages, setMessages] = useState<Message[]>([]);
  const [text, setText] = useState("");
  const [busy, setBusy] = useState(false);
  const [poll, setPoll] = useState(true);
  const ref = useRef<HTMLDivElement | null>(null);

  async function load() {
    const res = await fetch(fetchUrl, { cache: "no-store" }).then((r) => r.json());
    if (res?.ok) setMessages(res.messages || []);
  }
  useEffect(() => {
    load();
  }, [fetchUrl]);

  useEffect(() => {
    if (!poll) return;
    const t = setInterval(load, 3500);
    return () => clearInterval(t);
  }, [poll, fetchUrl]);

  useEffect(() => {
    ref.current?.scrollTo({ top: 9999999, behavior: "smooth" });
  }, [messages.length]);

  async function send() {
    const body = text.trim();
    if (!body) return;
    setBusy(true);
    try {
      const res = await fetch(postUrl, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ message: body }),
      }).then((r) => r.json());
      if (!res?.ok) throw new Error(res?.error || "Грешка");
      setText("");
      await load();
    } catch (e: any) {
      alert(e?.message || "Грешка");
    } finally {
      setBusy(false);
    }
  }

  return (
    <div className="space-y-3">
      <div ref={ref} className="max-h-[46vh] overflow-y-auto rounded-lg border p-3 bg-background/50">
        {messages.map((m) => (
          <div key={m.id} className="py-1.5">
            <div className="text-xs text-muted-foreground">
              <span className="font-medium text-foreground">{m.name || m.email}</span>{" "}
              <span suppressHydrationWarning>• {new Date(m.createdAt).toLocaleString()}</span>
              {canBlock && onBlock && (
                <Button size="sm" variant="outline" className="ml-2 h-6 px-2" onClick={() => onBlock(m.userId)}>
                  Блокирай
                </Button>
              )}
            </div>
            <div className="text-sm">{m.message}</div>
          </div>
        ))}
        {messages.length === 0 && <div className="text-sm text-muted-foreground">Няма съобщения още.</div>}
      </div>

      <div className="flex gap-2">
        <Textarea rows={2} placeholder="Напиши съобщение…" value={text} onChange={(e) => setText(e.target.value)} />
        <Button onClick={send} disabled={busy || !text.trim()} className="self-start">
          Изпрати
        </Button>
      </div>
    </div>
  );
}
\n===== END FILE: components/chat/chat-box.tsx =====\n
===== FILE: components/chat/sendbird-chat.tsx =====
"use client";

import { useEffect, useMemo, useState } from "react";
import dynamic from "next/dynamic";

// Lazy-load UI kit on client only to avoid SSR issues
const SendBirdProvider = dynamic(() => import("@sendbird/uikit-react").then(m => m.SendBirdProvider), { ssr: false }) as any;
const Channel = dynamic(() => import("@sendbird/uikit-react").then(m => m.Channel), { ssr: false }) as any;
const ChannelSettings = dynamic(() => import("@sendbird/uikit-react").then(m => m.ChannelSettings), { ssr: false }) as any;

type ConnectInfo = {
  ok: boolean;
  appId?: string;
  userId?: string;
  nickname?: string | null;
  accessToken?: string | null;
  channelUrl?: string;
  error?: string;
};

export default function SendbirdChat({ fireId, connectUrl }: { fireId?: number; connectUrl?: string }) {
  const [info, setInfo] = useState<ConnectInfo | null>(null);
  const [error, setError] = useState<string | null>(null);
  const [settingsOpen, setSettingsOpen] = useState(false);

  useEffect(() => {
    let canceled = false;
    (async () => {
      try {
        const url = connectUrl || (fireId != null ? `/api/fires/${fireId}/chat/connect` : "");
        if (!url) throw new Error("Липсва connectUrl");
        const j: ConnectInfo = await fetch(url, { cache: "no-store" }).then(r => r.json());
        if (canceled) return;
        if (!j?.ok) {
          setError(j?.error || "Грешка при свързване към Sendbird.");
          return;
        }
        setInfo(j);
      } catch (e: any) {
        if (!canceled) setError(e?.message || "Грешка при свързване към Sendbird.");
      }
    })();
    return () => { canceled = true; };
  }, [fireId, connectUrl]);

  const content = useMemo(() => {
    if (error) return <div className="text-sm text-red-500">{error}</div>;
    if (!info) return <div className="text-sm text-muted-foreground">Зареждане…</div>;
    if (!info.appId || !info.userId || !info.channelUrl)
      return <div className="text-sm text-red-500">Липсват данни за свързване към Sendbird.</div>;

    return (
      <div style={{ height: '60vh', overflow: 'visible' }}>
        <SendBirdProvider
          appId={info.appId}
          userId={info.userId}
          accessToken={info.accessToken || undefined}
          nickname={info.nickname || undefined}
        >
          <Channel
            channelUrl={info.channelUrl}
            startingPoint={0}
            queries={{ messageListParams: { prevResultSize: 50, nextResultSize: 0, isInclusive: true, includeReactions: true, includeMetaArray: true, includeParentMessageInfo: true, includeThreadInfo: true } }}
            onChatHeaderActionClick={() => setSettingsOpen(true)}
          />
          {settingsOpen && (
            <ChannelSettings
              channelUrl={info.channelUrl}
              onClose={() => setSettingsOpen(false)}
            />
          )}
        </SendBirdProvider>
      </div>
    );
  }, [info, error, settingsOpen]);

  return (
    <div className="sb-wrapper">{content}</div>
  );
}
\n===== END FILE: components/chat/sendbird-chat.tsx =====\n
===== FILE: components/fires/firms-hotspots.tsx =====
"use client";

import { useEffect, useMemo, useRef, useState, useTransition } from "react";
import { useMap } from "@/context/map-context";
import { circlePolygon, haversineMeters } from "@/lib/geo";
import FirmsMarker from "./firms-marker";
import FirmsPopup from "./firms-popup";
import { useUser } from "@auth0/nextjs-auth0";
import { useDebounce } from "@/hooks/useDebounce";

export type FirmsHotspot = {
  id: string;
  lat: number;
  lng: number;
  source: string;
  satellite?: string;
  instrument?: string;
  brightness?: number;
  frp?: number;         // при клъстер = Σ FRP (също идва във frpTotal)
  confidence?: number;
  confidenceRaw?: string;
  daynight?: string;
  acquiredAt?: string;
  radiusM: number;
  distanceM?: number;
  // нови
  count?: number;
  sources?: string[];
  firstSeenAt?: string;
  lastSeenAt?: string;
  frpTotal?: number;
};

const SRC_ID = "firms-polygons-src";
const FILL_ID = "firms-polygons-fill";
const LINE_ID = "firms-polygons-line";

// за подреждане под червените пожари (ако вече са налични)
const FIRES_FILL_ID = "fires-polygons-fill";
const FIRES_LINE_ID = "fires-polygons-line";

type Props = {
  createAction: (formData: FormData) => Promise<void>;
  dedupRadiusM?: number;
  minConfidence?: number;
  days?: number;
  maxMarkers?: number;
  activeFires?: { lat: number; lng: number }[];
  clusterRadiusM?: number; // ново
};

export default function FirmsHotspots({
  createAction,
  dedupRadiusM = 500,
  minConfidence = 0,
  days = 2,
  maxMarkers = 250,
  activeFires = [],
  clusterRadiusM = 650,
}: Props) {
  const { map } = useMap();
  const { user } = useUser();

  const [hotspots, setHotspots] = useState<FirmsHotspot[]>([]);
  const [selectedId, setSelectedId] = useState<string | null>(null);
  const [isPending, startTransition] = useTransition();

  const [isLoadedOnce, setIsLoadedOnce] = useState(false);
  const [isLoading, setIsLoading] = useState(false);

  // === FETCH bbox ===
  const fetchRef = useRef<AbortController | null>(null);
  const [bboxString, setBboxString] = useState<string | null>(null);
  const debouncedBbox = useDebounce(bboxString, 350);

  useEffect(() => {
    if (!map) return;
    const apply = () => {
      try {
        const b = map.getBounds() as any;
        const sw = b.getSouthWest();
        const ne = b.getNorthEast();
        const bbox = `${sw.lng},${sw.lat},${ne.lng},${ne.lat}`;
        setBboxString(bbox);
      } catch {}
    };
    // Зареждаме при първоначално зареждане на картата и при движение/зуум
    map.on("moveend", apply);
    const onLoad = () => apply();
    try {
      map.on("load", onLoad as any);
    } catch {}
    // ако стилът вече е зареден – приложи веднага
    if ((map as any).loaded?.() || (map as any).isStyleLoaded?.()) apply();
    return () => {
      try {
        map.off("moveend", apply);
        map.off("load", onLoad as any);
      } catch {}
    };
  }, [map]);

  useEffect(() => {
    if (!debouncedBbox) return;
    const controller = new AbortController();
    fetchRef.current?.abort();
    fetchRef.current = controller;

    (async () => {
      setIsLoading(true);
      try {
        const params = new URLSearchParams();
        params.set("bbox", debouncedBbox);
        params.set("dedupRadiusM", String(dedupRadiusM));
        if (minConfidence > 0) params.set("minConfidence", String(minConfidence));
        params.set("days", String(days));
        params.set("clusterRadiusM", String(clusterRadiusM)); // ново

        const res = await fetch(`/api/firms?${params.toString()}`, { signal: controller.signal, cache: "no-store" });
        const j = await res.json();
        if (j?.ok) {
          const next: any[] = Array.isArray(j.hotspots) ? j.hotspots : [];
          if (next.length >= 0) setHotspots(next as any);
          setIsLoadedOnce(true);
        } else {
          console.error("FIRMS error:", j?.error);
        }
      } catch (e) {
        if (!(e as any)?.name?.includes?.("AbortError")) {
          console.error(e);
        }
      } finally {
        setIsLoading(false);
      }
    })();

    return () => controller.abort();
  }, [debouncedBbox, dedupRadiusM, minConfidence, days, clusterRadiusM]);

  const selected = useMemo(
    () => (selectedId ? hotspots.find((h) => h.id === selectedId) ?? null : null),
    [hotspots, selectedId]
  );

  // Клиентска дедупликация срещу активни пожари (допълнителна защита)
  const visibleHotspots = useMemo(() => {
    if (!activeFires?.length) return hotspots;
    return hotspots.filter((h) => {
      for (const f of activeFires) {
        const d = haversineMeters({ lat: h.lat, lng: h.lng }, f);
        if (d <= dedupRadiusM) return false;
      }
      return true;
    });
  }, [hotspots, activeFires, dedupRadiusM]);

  // === GeoJSON полигоните (жълти) ===
  const geojson = useMemo(() => {
    return {
      type: "FeatureCollection" as const,
      features: visibleHotspots.map((h) => ({
        type: "Feature" as const,
        properties: {
          id: h.id,
          radiusM: h.radiusM,
          source: h.source,
          count: h.count ?? 1,
        },
        geometry: circlePolygon({ lat: h.lat, lng: h.lng }, h.radiusM).geometry,
      })),
    };
  }, [visibleHotspots]);

  // Добавяне/ъпдейт на източник и слоеве – винаги под червените (ако те съществуват)
  useEffect(() => {
    if (!map) return;

    const addOrUpdate = () => {
      if (!map || !map.isStyleLoaded()) return;
      try {
        // source
        if (!map.getSource(SRC_ID)) {
          map.addSource(SRC_ID, { type: "geojson", data: geojson });
        } else {
          (map.getSource(SRC_ID) as any)?.setData?.(geojson);
        }

        // fill
        if (!map.getLayer(FILL_ID)) {
          const layer: any = {
            id: FILL_ID,
            type: "fill",
            source: SRC_ID,
            paint: {
              "fill-color": "#f59e0b",
              "fill-opacity": 0.12,
            },
          };
          if (map.getLayer(FIRES_FILL_ID)) (map as any).addLayer(layer, FIRES_FILL_ID);
          else map.addLayer(layer);
        }

        // line
        if (!map.getLayer(LINE_ID)) {
          const layer: any = {
            id: LINE_ID,
            type: "line",
            source: SRC_ID,
            paint: {
              "line-color": "#f59e0b",
              "line-width": 2,
              "line-opacity": 0.7,
            },
          };
          if (map.getLayer(FIRES_LINE_ID)) (map as any).addLayer(layer, FIRES_LINE_ID);
          else map.addLayer(layer);
        }

        // преместване под червените, ако се появят по-късно
        try {
          if (map.getLayer(FIRES_FILL_ID)) (map as any).moveLayer(FILL_ID, FIRES_FILL_ID);
          if (map.getLayer(FIRES_LINE_ID)) (map as any).moveLayer(LINE_ID, FIRES_LINE_ID);
        } catch {}
      } catch {
        // swallow
      }
    };

    const onStyle = () => addOrUpdate();
    map.on("style.load", onStyle as any);
    if (map.isStyleLoaded()) addOrUpdate();

    return () => {
      try {
        map.off("style.load", onStyle as any);
      } catch {}
    };
  }, [map, geojson]);

  // live ъпдейт на данните
  useEffect(() => {
    if (!map || !map.isStyleLoaded()) return;
    try {
      (map.getSource(SRC_ID) as any)?.setData?.(geojson);
    } catch {}
  }, [map, geojson]);

  // чистене на слоевете при унищожаване
  useEffect(() => {
    return () => {
      if (!map) return;
      try {
        if (map.getLayer(LINE_ID)) map.removeLayer(LINE_ID);
        if (map.getLayer(FILL_ID)) map.removeLayer(FILL_ID);
        if (map.getSource(SRC_ID)) map.removeSource(SRC_ID);
      } catch {}
    };
  }, [map]);

  // Превръщане на FIRMS сигнал/клъстер → докладван пожар (в БД)
  const promoteToFire = (h: FirmsHotspot) => {
    startTransition(async () => {
      try {
        const fd = new FormData();
        fd.set("lat", String(h.lat));
        fd.set("lng", String(h.lng));
        fd.set("radiusM", String(h.radiusM));
        await createAction(fd);
        setHotspots((prev) => prev.filter((x) => x.id !== h.id));
        setSelectedId(null);
      } catch (e: any) {
        alert(e?.message || "Неуспешно създаване.");
      }
    });
  };

  return (
    <>
      {/* Индикатор за live състояние */}
      <div className="absolute top-4 right-[11.5rem] sm:right-[13rem] z-10">
        {isLoading ? (
          <div className="bg-background/90 border rounded-lg shadow-lg px-2 py-1 text-xs">
            Зареждане FIRMS…
          </div>
        ) : isLoadedOnce ? (
          <div className="bg-background/90 border rounded-lg shadow-lg px-2 py-1 text-xs">
            FIRMS: {visibleHotspots.length} групи
          </div>
        ) : null}
      </div>

      {/* DOM пинове */}
      {visibleHotspots.slice(0, maxMarkers).map((h) => (
        <FirmsMarker
          key={h.id}
          id={h.id}
          lat={h.lat}
          lng={h.lng}
          count={h.count ?? 1}
          onClick={() => setSelectedId(h.id)}
        />
      ))}

      {selected && (
        <FirmsPopup
          hotspot={selected}
          isLoggedIn={!!user}
          isSubmitting={isPending}
          onPromote={() => promoteToFire(selected)}
          onClose={() => setSelectedId(null)}
        />
      )}
    </>
  );
}
\n===== END FILE: components/fires/firms-hotspots.tsx =====\n
===== FILE: components/fires/report-fire.tsx =====
"use client";

import { useEffect, useState, useTransition } from "react";
import { useRouter } from "next/navigation";
import { useUser } from "@auth0/nextjs-auth0";
import { useMap } from "@/context/map-context";
import { Button } from "@/components/ui/button";
import { circlePolygon, metersToReadable } from "@/lib/geo";
import FireMarker from "./fire-marker";

const PREVIEW_SRC = "fire-preview-src";
const PREVIEW_FILL = "fire-preview-fill";
const PREVIEW_LINE = "fire-preview-line";

type Props = {
  action: (formData: FormData) => Promise<void>;
};

export default function ReportFire({ action }: Props) {
  const { user, isLoading } = useUser();
  const { map } = useMap();
  const router = useRouter();

  const [isReporting, setIsReporting] = useState(false);
  const [point, setPoint] = useState<{ lat: number; lng: number } | null>(null);
  const [radius, setRadius] = useState(300); // m
  const [isPending, startTransition] = useTransition();

  // Добавяме/ъпдейтваме "preview" слой
  useEffect(() => {
    if (!map) return;

    const applyPreview = () => {
      if (!map || !map.isStyleLoaded()) return;

      if (!point) {
        // премахваме ако има
        try {
          if (map.getLayer(PREVIEW_LINE)) map.removeLayer(PREVIEW_LINE);
          if (map.getLayer(PREVIEW_FILL)) map.removeLayer(PREVIEW_FILL);
          if (map.getSource(PREVIEW_SRC)) map.removeSource(PREVIEW_SRC);
        } catch {}
        return;
      }

      const gj = {
        type: "FeatureCollection" as const,
        features: [circlePolygon(point, radius)],
      };

      try {
        if (!map.getSource(PREVIEW_SRC)) {
          map.addSource(PREVIEW_SRC, { type: "geojson", data: gj });
          map.addLayer({
            id: PREVIEW_FILL,
            type: "fill",
            source: PREVIEW_SRC,
            paint: { "fill-color": "#ef4444", "fill-opacity": 0.12 },
          });
          map.addLayer({
            id: PREVIEW_LINE,
            type: "line",
            source: PREVIEW_SRC,
            paint: { "line-color": "#ef4444", "line-width": 2, "line-opacity": 0.7 },
          });
        } else {
          const src = map.getSource(PREVIEW_SRC) as any;
          src?.setData?.(gj);
        }
      } catch {}
    };

    // ensure on current style
    applyPreview();

    // re-apply on future style changes too
    const handler = () => applyPreview();
    map.on("style.load", handler as any);
    return () => {
      try {
        map.off("style.load", handler as any);
      } catch {}
    };
  }, [map, point, radius]);

  // Click върху картата при режим "докладване"
  useEffect(() => {
    if (!map) return;
    if (!isReporting) return;

    const onClick = (e: any) => {
      const { lng, lat } = e.lngLat;
      setPoint({ lat, lng });
    };

    map.getCanvas().style.cursor = "crosshair";
    map.on("click", onClick);

    return () => {
      map.off("click", onClick);
      map.getCanvas().style.cursor = "";
    };
  }, [map, isReporting]);

  const canCreate = !!point && radius >= 50 && radius <= 20000;

  const startReporting = () => {
    setIsReporting(true);
    setPoint(null);
    setRadius(300);
  };
  const cancelReporting = () => {
    setIsReporting(false);
    setPoint(null);
  };

  const onSubmit = (formData: FormData) => {
    startTransition(async () => {
      try {
        await action(formData);
        router.refresh();
        cancelReporting();
      } catch (e: any) {
        alert(e?.message || "Неуспешно създаване.");
      }
    });
  };

  return (
    <div className="absolute top-4 right-4 z-10 flex flex-col items-end gap-2">
      {!isLoading && !user && (
        <div className="bg-background/90 border rounded-lg shadow-lg p-3 max-w-[320px]">
          <div className="text-sm mb-2">За да докладваш пожар, влез в профила си.</div>
          <div className="flex gap-2">
            <a href="/auth/login">
              <Button size="sm">Вход</Button>
            </a>
          </div>
        </div>
      )}

      <div className="bg-background/90 border rounded-lg shadow-lg p-2 flex gap-2">
        {!isReporting ? (
          <Button size="sm" onClick={startReporting} disabled={!user || isLoading}>
            Докладвай пожар
          </Button>
        ) : (
          <>
            <Button size="sm" variant="secondary" onClick={cancelReporting}>
              Откажи
            </Button>
            <div className="hidden sm:flex items-center text-sm text-muted-foreground px-1">Кликни на картата за позиция</div>
          </>
        )}
      </div>

      {isReporting && (
        <div className="bg-background/90 border rounded-lg shadow-lg p-3 w-[280px] sm:w-[360px]">
          <div className="text-sm font-medium mb-1">Нова точка на пожар</div>
          <div className="text-xs text-muted-foreground mb-3">
            1) Кликни на картата, за да зададеш център. 2) Задай радиус. 3) Създай пожар.
          </div>

          <div className="space-y-2">
            <label className="text-xs text-muted-foreground">Радиус: <span className="text-foreground font-medium">{metersToReadable(radius)}</span></label>
            <input
              type="range"
              min={50}
              max={5000}
              step={10}
              value={radius}
              onChange={(e) => setRadius(parseInt(e.target.value, 10))}
              className="w-full"
            />
            <div className="flex items-center justify-between text-xs text-muted-foreground">
              <span>50 м</span><span>5 км</span>
            </div>
          </div>

          <form action={onSubmit} className="mt-3 flex gap-2 items-center">
            <input type="hidden" name="lat" value={point?.lat ?? ""} />
            <input type="hidden" name="lng" value={point?.lng ?? ""} />
            <input type="hidden" name="radiusM" value={radius} />
            <Button size="sm" type="submit" disabled={!canCreate || isPending}>
              {isPending ? "Създаване…" : "Създай пожар"}
            </Button>
            <Button size="sm" variant="outline" type="button" onClick={cancelReporting}>
              Затвори
            </Button>
          </form>
          {!point && <div className="mt-2 text-xs text-muted-foreground">Избери точка на картата…</div>}
        </div>
      )}

      {isReporting && point && (
        <FireMarker id={-1} lat={point.lat} lng={point.lng} />
      )}
    </div>
  );
}
\n===== END FILE: components/fires/report-fire.tsx =====\n
===== FILE: components/map/map-marker.tsx =====
"use client";

import mapboxgl from "mapbox-gl";
import React, { useEffect, useRef, useState } from "react";
import { createPortal } from "react-dom";
import { useMap } from "@/context/map-context";
import { LocationFeature } from "@/lib/mapbox/utils";

type Props = {
  longitude: number;
  latitude: number;
  data: LocationFeature;
  onHover?: (args: {
    isHovered: boolean;
    position: { longitude: number; latitude: number };
    marker: mapboxgl.Marker;
    data: LocationFeature;
  }) => void;
  onClick?: (args: {
    position: { longitude: number; latitude: number };
    marker: mapboxgl.Marker;
    data: LocationFeature;
  }) => void;
  children?: React.ReactNode;
};

export default function Marker({
  children,
  latitude,
  longitude,
  data,
  onHover,
  onClick,
}: Props) {
  const { map } = useMap();
  const markerRef = useRef<mapboxgl.Marker | null>(null);

  // контейнер за React портала – създаваме го веднъж
  const [container, setContainer] = useState<HTMLDivElement | null>(null);
  useEffect(() => {
    if (typeof document !== "undefined") {
      setContainer(document.createElement("div"));
    }
  }, []);

  // стабилни референции към callback-ите (без да ре-създаваме маркера)
  const hoverRef = useRef<typeof onHover>(undefined);
  const clickRef = useRef<typeof onClick>(undefined);
  const dataRef = useRef<LocationFeature>(data);
  useEffect(() => {
    hoverRef.current = onHover;
  }, [onHover]);
  useEffect(() => {
    clickRef.current = onClick;
  }, [onClick]);
  useEffect(() => {
    dataRef.current = data;
  }, [data]);

  // добавяне на слушатели към контейнера (веднъж)
  useEffect(() => {
    if (!container) return;
    const handleEnter = () => {
      if (!markerRef.current) return;
      hoverRef.current?.({
        isHovered: true,
        position: { longitude, latitude },
        marker: markerRef.current,
        data: dataRef.current,
      });
    };
    const handleLeave = () => {
      if (!markerRef.current) return;
      hoverRef.current?.({
        isHovered: false,
        position: { longitude, latitude },
        marker: markerRef.current,
        data: dataRef.current,
      });
    };
    const handleClick = () => {
      if (!markerRef.current) return;
      clickRef.current?.({
        position: { longitude, latitude },
        marker: markerRef.current,
        data: dataRef.current,
      });
    };

    container.addEventListener("mouseenter", handleEnter);
    container.addEventListener("mouseleave", handleLeave);
    container.addEventListener("click", handleClick);

    return () => {
      container.removeEventListener("mouseenter", handleEnter);
      container.removeEventListener("mouseleave", handleLeave);
      container.removeEventListener("click", handleClick);
    };
    // умишлено НЕ зависим от onHover/onClick/data, защото използваме рефове
  }, [container, latitude, longitude]);

  // създаваме маркера ВЕДНЪЖ (не ползваме style.load) – маркерите оцеляват при смяна на стил
  useEffect(() => {
    if (!map || !container) return;
    if (markerRef.current) return; // вече е създаден

    try {
      const marker = new mapboxgl.Marker({ element: container })
        .setLngLat([longitude, latitude])
        .addTo(map);
      markerRef.current = marker;
    } catch {
      // ignore
    }

    return () => {
      try {
        markerRef.current?.remove();
      } catch {}
      markerRef.current = null;
    };
  }, [map, container]); // умишлено НЕ зависим от longitude/latitude

  // плавно обновяване на позицията, без да унищожаваме маркера
  useEffect(() => {
    markerRef.current?.setLngLat([longitude, latitude]);
  }, [longitude, latitude]);

  if (!container) return null;
  return createPortal(children, container);
}
\n===== END FILE: components/map/map-marker.tsx =====\n
===== FILE: components/map/map-popup.tsx =====
"use client";

import { useMap } from "@/context/map-context";
import mapboxgl from "mapbox-gl";
import { useCallback, useEffect, useMemo, useState } from "react";
import { createPortal } from "react-dom";

type PopupProps = {
  children: React.ReactNode;
  latitude?: number;
  longitude?: number;
  onClose?: () => void;
  marker?: mapboxgl.Marker;
} & mapboxgl.PopupOptions;

export default function Popup({
  latitude,
  longitude,
  children,
  marker,
  onClose,
  className,
  ...props
}: PopupProps) {
  const { map } = useMap();

  const [container, setContainer] = useState<HTMLDivElement | null>(null);
  useEffect(() => {
    if (typeof document !== "undefined") {
      setContainer(document.createElement("div"));
    }
  }, []);
  const handleClose = useCallback(() => onClose?.(), [onClose]);

  useEffect(() => {
    if (!map || !container) return;

    const popup = new mapboxgl.Popup({
      closeButton: true,
      closeOnClick: false,
      ...props,
      className: `mapboxgl-custom-popup ${className ?? ""}`,
    })
      .setDOMContent(container)
      .setMaxWidth("none");

    popup.on("close", handleClose);

    if (marker) {
      const current = marker.getPopup();
      if (current) current.remove();
      marker.setPopup(popup);
      marker.togglePopup();
    } else if (latitude !== undefined && longitude !== undefined) {
      popup.setLngLat([longitude, latitude]).addTo(map);
    }

    return () => {
      popup.off("close", handleClose);
      // Detach our container before removing the popup to avoid React portal cleanup conflicts
      try {
        popup.setDOMContent(document.createElement("div"));
      } catch {}
      try {
        popup.remove();
      } catch {}
      try {
        if (marker && marker.getPopup()) marker.setPopup(null);
      } catch {}
    };
  }, [map, marker, latitude, longitude, props, className, container, handleClose]);

  if (!container) return null;
  return createPortal(children, container);
}
\n===== END FILE: components/map/map-popup.tsx =====\n
===== FILE: components/map/map-search.tsx =====
"use client";

import { useEffect, useMemo, useState } from "react";
import { Loader2, MapPin, X } from "lucide-react";
import { useMap } from "@/context/map-context";
import { cn } from "@/lib/utils";
import { iconMap, LocationFeature, LocationSuggestion } from "@/lib/mapbox/utils";
import { Command, CommandInput, CommandList, CommandEmpty, CommandGroup, CommandItem } from "@/components/ui/command";
import { LocationMarker } from "@/components/location-marker";
import { LocationPopup } from "@/components/location-popup";
import { useDebounce } from "@/hooks/useDebounce";

export default function MapSearch() {
  const { map } = useMap();
  const [query, setQuery] = useState("");
  const [displayValue, setDisplayValue] = useState("");
  const [results, setResults] = useState<LocationSuggestion[]>([]);
  const [isSearching, setIsSearching] = useState(false);
  const [isOpen, setIsOpen] = useState(false);
  const [selectedLocation, setSelectedLocation] = useState<LocationFeature | null>(null);
  const [selectedLocations, setSelectedLocations] = useState<LocationFeature[]>([]);
  const debouncedQuery = useDebounce(query, 400);

  const accessToken = process.env.NEXT_PUBLIC_MAPBOX_TOKEN!;
  const sessionToken = useMemo(() => {
    const env = process.env.NEXT_PUBLIC_MAPBOX_SESSION_TOKEN;
    if (env) return env;
    const key = "mapbox-session-token";
    const cached = typeof window !== "undefined" ? localStorage.getItem(key) : null;
    if (cached) return cached;
    const generated = typeof crypto !== "undefined" && "randomUUID" in crypto ? crypto.randomUUID() : String(Math.random()).slice(2);
    if (typeof window !== "undefined") localStorage.setItem(key, generated);
    return generated;
  }, []);

  useEffect(() => {
    if (!debouncedQuery.trim()) {
      setResults([]);
      setIsOpen(false);
      return;
    }

    const searchLocations = async () => {
      setIsSearching(true);
      setIsOpen(true);

      try {
        const res = await fetch(
          `https://api.mapbox.com/search/searchbox/v1/suggest?q=${encodeURIComponent(debouncedQuery)}&access_token=${accessToken}&session_token=${sessionToken}&limit=5`
        );

        const data = await res.json();
        setResults(data?.suggestions ?? []);
      } catch (err) {
        console.error("Geocoding error:", err);
        setResults([]);
      } finally {
        setIsSearching(false);
      }
    };

    searchLocations();
  }, [debouncedQuery, accessToken, sessionToken]);

  const handleInputChange = (value: string) => {
    setQuery(value);
    setDisplayValue(value);
  };

  const handleSelect = async (suggestion: LocationSuggestion) => {
    try {
      setIsSearching(true);

      const res = await fetch(
        `https://api.mapbox.com/search/searchbox/v1/retrieve/${suggestion.mapbox_id}?access_token=${accessToken}&session_token=${sessionToken}`
      );

      const data = await res.json();
      const featuresData = data?.features as LocationFeature[] | undefined;

      if (map && featuresData?.length) {
        const [lng, lat] = featuresData[0]?.geometry?.coordinates;
        map.flyTo({ center: [lng, lat], zoom: 14, speed: 4, duration: 1000, essential: true });

        setDisplayValue(suggestion.name);
        setSelectedLocations(featuresData);
        setSelectedLocation(featuresData[0]);
        setResults([]);
        setIsOpen(false);
      }
    } catch (err) {
      console.error("Retrieve error:", err);
    } finally {
      setIsSearching(false);
    }
  };

  const clearSearch = () => {
    setQuery("");
    setDisplayValue("");
    setResults([]);
    setIsOpen(false);
    setSelectedLocation(null);
    setSelectedLocations([]);
  };

  return (
    <>
      <section className="absolute top-4 left-1/2 sm:left-4 z-10 w-[90vw] sm:w-[350px] -translate-x-1/2 sm:translate-x-0 rounded-lg shadow-lg">
        <Command className="rounded-lg">
          <div className={cn("w-full flex items-center justify-between px-3 gap-1", isOpen && "border-b")}>
            <CommandInput placeholder="Търси локация..." value={displayValue} onValueChange={handleInputChange} className="flex-1" />
            {displayValue && !isSearching && (
              <X className="size-4 shrink-0 text-muted-foreground cursor-pointer hover:text-foreground transition-colors" onClick={clearSearch} />
            )}
            {isSearching && <Loader2 className="size-4 shrink-0 text-primary animate-spin" />}
          </div>

          {isOpen && (
            <CommandList className="max-h-60 overflow-y-auto">
              {!query.trim() || isSearching ? null : results.length === 0 ? (
                <CommandEmpty className="py-6 text-center">
                  <div className="flex flex-col items-center justify-center space-y-1">
                    <p className="text-sm font-medium">Няма резултати</p>
                    <p className="text-xs text-muted-foreground">Пробвай с друг термин</p>
                  </div>
                </CommandEmpty>
              ) : (
                <CommandGroup>
                  {results.map((location) => (
                    <CommandItem
                      key={location.mapbox_id}
                      onSelect={() => handleSelect(location)}
                      value={`${location.name} ${location.place_formatted} ${location.mapbox_id}`}
                      className="flex items-center py-3 px-2 cursor-pointer hover:bg-accent rounded-md"
                    >
                      <div className="flex items-center space-x-2">
                        <div className="bg-primary/10 p-1.5 rounded-full">
                          {location.maki && iconMap[location.maki] ? iconMap[location.maki] : <MapPin className="h-4 w-4 text-primary" />}
                        </div>
                        <div className="flex flex-col">
                          <span className="text-sm font-medium truncate max-w-[270px]">{location.name}</span>
                          <span className="text-xs text-muted-foreground truncate max-w-[270px]">{location.place_formatted}</span>
                        </div>
                      </div>
                    </CommandItem>
                  ))}
                </CommandGroup>
              )}
            </CommandList>
          )}
        </Command>
      </section>

      {selectedLocations.map((location) => (
        <LocationMarker key={location.properties.mapbox_id} location={location} onHover={(data) => setSelectedLocation(data)} />
      ))}

      {selectedLocation && (
        <LocationPopup
          location={selectedLocation}
          onClose={() => {
            setSelectedLocation(null);
            setSelectedLocations([]);
          }}
        />
      )}
    </>
  );
}
\n===== END FILE: components/map/map-search.tsx =====\n
===== FILE: components/map/map-styles.tsx =====
"use client";

import React, { useEffect, useState } from "react";
import { MapIcon, MoonIcon, SatelliteIcon, SunIcon, TreesIcon } from "lucide-react";
import { useTheme } from "next-themes";
import { useMap } from "@/context/map-context";
import { Tabs, TabsList, TabsTrigger } from "@/components/ui/tabs";

type StyleOption = {
  id: string;
  label: string;
  icon: React.ReactNode;
};

const STYLE_OPTIONS: StyleOption[] = [
  { id: "streets-v12", label: "Map", icon: <MapIcon className="w-5 h-5" /> },
  { id: "satellite-streets-v12", label: "Satellite", icon: <SatelliteIcon className="w-5 h-5" /> },
  { id: "outdoors-v12", label: "Terrain", icon: <TreesIcon className="w-5 h-5" /> },
  { id: "light-v11", label: "Light", icon: <SunIcon className="w-5 h-5" /> },
  { id: "dark-v11", label: "Dark", icon: <MoonIcon className="w-5 h-5" /> },
];

export default function MapStyles({ initialStyle = "streets-v12" }: { initialStyle?: string }) {
  const { map } = useMap();
  const { setTheme } = useTheme();
  const [activeStyle, setActiveStyle] = useState(initialStyle);
  const [mounted, setMounted] = useState(false);

  // Избягваме SSR за Tabs/ids, за да няма hydration mismatch
  useEffect(() => setMounted(true), []);

  const handleChange = (value: string) => {
    if (!map) return;
    map.setStyle(`mapbox://styles/mapbox/${value}`);
    setActiveStyle(value);
  };

  useEffect(() => {
    setTheme(activeStyle === "dark-v11" ? "dark" : "light");
  }, [activeStyle, setTheme]);

  if (!mounted) return null;

  return (
    <aside className="absolute bottom-4 left-4 z-10">
      <Tabs value={activeStyle} onValueChange={handleChange}>
        <TabsList className="bg-background/90 shadow-lg backdrop-blur">
          {STYLE_OPTIONS.map((style) => (
            <TabsTrigger
              key={style.id}
              value={style.id}
              className="data-[state=active]:bg-primary data-[state=active]:text-primary-foreground text-sm flex items-center sm:px-3 sm:py-1.5"
            >
              {style.icon}
              <span className="hidden sm:inline ml-1">{style.label}</span>
            </TabsTrigger>
          ))}
        </TabsList>
      </Tabs>
    </aside>
  );
}
\n===== END FILE: components/map/map-styles.tsx =====\n
===== FILE: components/ui/carousel.tsx =====
"use client"

import * as React from "react"
import useEmblaCarousel, {
  type UseEmblaCarouselType,
} from "embla-carousel-react"
import { ArrowLeft, ArrowRight } from "lucide-react"

import { cn } from "@/lib/utils"
import { Button } from "@/components/ui/button"

type CarouselApi = UseEmblaCarouselType[1]
type UseCarouselParameters = Parameters<typeof useEmblaCarousel>
type CarouselOptions = UseCarouselParameters[0]
type CarouselPlugin = UseCarouselParameters[1]

type CarouselProps = {
  opts?: CarouselOptions
  plugins?: CarouselPlugin
  orientation?: "horizontal" | "vertical"
  setApi?: (api: CarouselApi) => void
}

type CarouselContextProps = {
  carouselRef: ReturnType<typeof useEmblaCarousel>[0]
  api: ReturnType<typeof useEmblaCarousel>[1]
  scrollPrev: () => void
  scrollNext: () => void
  canScrollPrev: boolean
  canScrollNext: boolean
} & CarouselProps

const CarouselContext = React.createContext<CarouselContextProps | null>(null)

function useCarousel() {
  const context = React.useContext(CarouselContext)

  if (!context) {
    throw new Error("useCarousel must be used within a <Carousel />")
  }

  return context
}

function Carousel({
  orientation = "horizontal",
  opts,
  setApi,
  plugins,
  className,
  children,
  ...props
}: React.ComponentProps<"div"> & CarouselProps) {
  const [carouselRef, api] = useEmblaCarousel(
    {
      ...opts,
      axis: orientation === "horizontal" ? "x" : "y",
    },
    plugins
  )
  const [canScrollPrev, setCanScrollPrev] = React.useState(false)
  const [canScrollNext, setCanScrollNext] = React.useState(false)

  const onSelect = React.useCallback((api: CarouselApi) => {
    if (!api) return
    setCanScrollPrev(api.canScrollPrev())
    setCanScrollNext(api.canScrollNext())
  }, [])

  const scrollPrev = React.useCallback(() => {
    api?.scrollPrev()
  }, [api])

  const scrollNext = React.useCallback(() => {
    api?.scrollNext()
  }, [api])

  const handleKeyDown = React.useCallback(
    (event: React.KeyboardEvent<HTMLDivElement>) => {
      if (event.key === "ArrowLeft") {
        event.preventDefault()
        scrollPrev()
      } else if (event.key === "ArrowRight") {
        event.preventDefault()
        scrollNext()
      }
    },
    [scrollPrev, scrollNext]
  )

  React.useEffect(() => {
    if (!api || !setApi) return
    setApi(api)
  }, [api, setApi])

  React.useEffect(() => {
    if (!api) return
    onSelect(api)
    api.on("reInit", onSelect)
    api.on("select", onSelect)

    return () => {
      api?.off("select", onSelect)
    }
  }, [api, onSelect])

  return (
    <CarouselContext.Provider
      value={{
        carouselRef,
        api: api,
        opts,
        orientation:
          orientation || (opts?.axis === "y" ? "vertical" : "horizontal"),
        scrollPrev,
        scrollNext,
        canScrollPrev,
        canScrollNext,
      }}
    >
      <div
        onKeyDownCapture={handleKeyDown}
        className={cn("relative", className)}
        role="region"
        aria-roledescription="carousel"
        data-slot="carousel"
        {...props}
      >
        {children}
      </div>
    </CarouselContext.Provider>
  )
}

function CarouselContent({ className, ...props }: React.ComponentProps<"div">) {
  const { carouselRef, orientation } = useCarousel()

  return (
    <div
      ref={carouselRef}
      className="overflow-hidden"
      data-slot="carousel-content"
    >
      <div
        className={cn(
          "flex",
          orientation === "horizontal" ? "-ml-4" : "-mt-4 flex-col",
          className
        )}
        {...props}
      />
    </div>
  )
}

function CarouselItem({ className, ...props }: React.ComponentProps<"div">) {
  const { orientation } = useCarousel()

  return (
    <div
      role="group"
      aria-roledescription="slide"
      data-slot="carousel-item"
      className={cn(
        "min-w-0 shrink-0 grow-0 basis-full",
        orientation === "horizontal" ? "pl-4" : "pt-4",
        className
      )}
      {...props}
    />
  )
}

function CarouselPrevious({
  className,
  variant = "outline",
  size = "icon",
  ...props
}: React.ComponentProps<typeof Button>) {
  const { orientation, scrollPrev, canScrollPrev } = useCarousel()

  return (
    <Button
      data-slot="carousel-previous"
      variant={variant}
      size={size}
      className={cn(
        "size-8 rounded-full",
        orientation === "horizontal"
          ? // Desktop (≥850px): side positioning
            "absolute top-1/2 -left-12 -translate-y-1/2"
          : "-top-12 left-1/2 -translate-x-1/2 rotate-90",
        // Mobile (<850px): move below, centered
        "max-[850px]:static max-[850px]:mx-auto max-[850px]:block",
        className
      )}
      disabled={!canScrollPrev}
      onClick={scrollPrev}
      {...props}
    >
      <ArrowLeft />
      <span className="sr-only">Previous slide</span>
    </Button>
  )
}

function CarouselNext({
  className,
  variant = "outline",
  size = "icon",
  ...props
}: React.ComponentProps<typeof Button>) {
  const { orientation, scrollNext, canScrollNext } = useCarousel()

  return (
    <Button
      data-slot="carousel-next"
      variant={variant}
      size={size}
      className={cn(
        "size-8 rounded-full",
        orientation === "horizontal"
          ? "absolute top-1/2 -right-12 -translate-y-1/2"
          : "-bottom-12 left-1/2 -translate-x-1/2 rotate-90",
        "max-[850px]:static max-[850px]:mx-auto max-[850px]:block",
        className
      )}
      disabled={!canScrollNext}
      onClick={scrollNext}
      {...props}
    >
      <ArrowRight />
      <span className="sr-only">Next slide</span>
    </Button>
  )
}


export {
  type CarouselApi,
  Carousel,
  CarouselContent,
  CarouselItem,
  CarouselPrevious,
  CarouselNext,
}
\n===== END FILE: components/ui/carousel.tsx =====\n
===== FILE: components/uploads/image-uploader.tsx =====
"use client";

import { useRef, useState } from "react";
import { Button } from "@/components/ui/button";

export default function ImageUploader({
  prefix,
  onUploaded,
  multiple = true,
}: {
  prefix: string;
  onUploaded: (file: { key: string; url: string; width?: number; height?: number }) => void;
  multiple?: boolean;
}) {
  const [busy, setBusy] = useState(false);
  const fileRef = useRef<HTMLInputElement | null>(null);

  async function handleFiles(files: FileList | null) {
    if (!files || !files.length) return;
    setBusy(true);
    try {
      for (const f of Array.from(files)) {
        const ct = f.type || "application/octet-stream";
        const ext = f.name.includes(".") ? "." + f.name.split(".").pop() : "";
        const p = await fetch("/api/uploads/presign", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ prefix, contentType: ct, ext }),
        }).then((r) => r.json());
        if (!p?.ok) throw new Error(p?.error || "Грешка при пресайна.");
        // Include ACL header to match the presigned request (server signs with ACL: public-read)
        const putRes = await fetch(p.url, {
          method: "PUT",
          body: f,
          headers: { "Content-Type": ct },
        });
        if (!putRes.ok) {
          let details = "";
          try { details = await putRes.text(); } catch {}
          const msg = `Неуспешно качване (${putRes.status})${details ? ": " + details.slice(0, 200) : ""}`;
          // eslint-disable-next-line no-console
          console.error("S3 PUT error", putRes.status, details);
          throw new Error(msg);
        }
        onUploaded({ key: p.key, url: p.publicUrl });
      }
    } catch (e) {
      alert((e as any)?.message || "Грешка при качването.");
    } finally {
      setBusy(false);
      // Allow selecting the same file again by clearing the input value
      if (fileRef.current) fileRef.current.value = "";
    }
  }

  return (
    <div className="inline-flex items-center gap-2">
      <input
        ref={fileRef}
        type="file"
        accept="image/*"
        multiple={multiple}
        className="hidden"
        onChange={(e) => handleFiles(e.target.files)}
      />
      <Button
        size="sm"
        variant="outline"
        type="button"
        disabled={busy}
        onClick={() => fileRef.current?.click()}
      >
        {busy ? "Качване…" : multiple ? "Качи изображения" : "Качи изображение"}
      </Button>
    </div>
  );
}
\n===== END FILE: components/uploads/image-uploader.tsx =====\n
===== FILE: components/zones/zone-draw.tsx =====
"use client";

import { useCallback, useEffect, useMemo, useRef, useState, useTransition } from "react";
import { useMap } from "@/context/map-context";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import { MousePointer2, Undo2, Check, XCircle } from "lucide-react";
import type mapboxgl from "mapbox-gl";
// Полигонално рисуване чрез Mapbox Draw (както в docs примера)
import MapboxDraw from "@mapbox/mapbox-gl-draw";
import "@mapbox/mapbox-gl-draw/dist/mapbox-gl-draw.css";

/**
 * Основни подобрения:
 * - Улавяне на събития на map container (capture), за да работи върху маркери/попъпи.
 * - Стабилно изключване/възстановяване на doubleClickZoom/dragPan/boxZoom/keyboard/touchZoomRotate.
 * - По-добри подсказки и UX (Esc=отказ, Enter/двуклик=край, десен клик/Backspace=назад).
 * - Без dynamic require; коректни превю слоеве; устойчивост при смяна на стил.
 */

export default function ZoneDraw({
  fireId,
  onCreated,
  onClose,
}: {
  fireId: number;
  onCreated?: () => void;
  onClose?: () => void;
}) {
  const { map } = useMap();

  // UI/формови полета
  const [mode, setMode] = useState<"idle" | "polygon" | "details">("polygon");
  const [title, setTitle] = useState("");
  const [description, setDescription] = useState("");
  // Mobile detection for adaptive UX
  const [isMobile, setIsMobile] = useState(false);

  // Геометрия
  const [points, setPoints] = useState<[number, number][]>([]);
  const [cursor, setCursor] = useState<[number, number] | null>(null);

  const [hint, setHint] = useState<string>("");
  const [isPending, startTransition] = useTransition();

  // Рефове за текущо състояние (избягват stale затваряния в DOM listeners)
  const modeRef = useRef(mode);
  const pointsRef = useRef(points);
  const drawRef = useRef<MapboxDraw | null>(null);

  useEffect(() => { modeRef.current = mode; }, [mode]);
  useEffect(() => { pointsRef.current = points; }, [points]);

  // Detect mobile / touch or narrow screens
  useEffect(() => {
    try {
      const compute = () => {
        const coarse = window.matchMedia?.("(pointer: coarse)")?.matches || (navigator as any).maxTouchPoints > 0;
        const narrow = window.matchMedia?.("(max-width: 768px)")?.matches;
        setIsMobile(!!(coarse || narrow));
      };
      compute();
      window.addEventListener("resize", compute);
      return () => window.removeEventListener("resize", compute);
    } catch {}
  }, []);

  // Запомняне на интеракции за възстановяване
  const interactionsRef = useRef<{
    doubleClickZoom?: boolean;
    boxZoom?: boolean;
    dragPan?: boolean;
    keyboard?: boolean;
    touchZoomRotate?: boolean;
  } | null>(null);

  // Идентификатори за превю слоеве
  const PREVIEW_SRC = "zone-draw-preview-src";
  const PREVIEW_FILL = "zone-draw-preview-fill";
  const PREVIEW_LINE = "zone-draw-preview-line";
  const PREVIEW_PTS = "zone-draw-preview-pts";

  // GeoJSON превю според текущия режим
  const previewGeojson = useMemo(() => {
    const features: any[] = [];

    if (mode === "polygon") {
      const verts = points.slice();
      if (cursor) verts.push(cursor);
      if (verts.length >= 2) {
        features.push({
          type: "Feature",
          properties: { __kind: "line" },
          geometry: { type: "LineString", coordinates: verts },
        });
      }
      if (points.length >= 3) {
        const ring = points.concat([cursor || points[0], points[0]]);
        features.push({
          type: "Feature",
          properties: { __kind: "polygon" },
          geometry: { type: "Polygon", coordinates: [ring] },
        });
      }
      if (points.length > 0) {
        features.push({
          type: "Feature",
          properties: { __kind: "point" },
          geometry: { type: "MultiPoint", coordinates: points },
        });
      }
    }

    return { type: "FeatureCollection", features } as any;
  }, [mode, points, cursor]);

  // Помощни: блок/разблок на map интеракции по време на рисуване
  const lockInteractions = useCallback(() => {
    if (!map) return;
    try {
      interactionsRef.current = {
        doubleClickZoom: (map as any).doubleClickZoom?.isEnabled?.(),
        boxZoom: (map as any).boxZoom?.isEnabled?.(),
        dragPan: (map as any).dragPan?.isEnabled?.(),
        keyboard: (map as any).keyboard?.isEnabled?.(),
        touchZoomRotate: (map as any).touchZoomRotate?.isEnabled?.(),
      };
      // On mobile, keep pan/zoom enabled during drawing for better UX
      (map as any).doubleClickZoom?.disable?.();
      (map as any).boxZoom?.disable?.();
      if (isMobile) {
        (map as any).keyboard?.disable?.();
        // leave dragPan and touchZoomRotate enabled on mobile
      } else {
        (map as any).dragPan?.disable?.();
        (map as any).keyboard?.disable?.();
        (map as any).touchZoomRotate?.disable?.();
      }
    } catch {
      // ignore
    }
  }, [map, isMobile]);

  const unlockInteractions = useCallback(() => {
    if (!map || !interactionsRef.current) return;
    const prev = interactionsRef.current;
    interactionsRef.current = null;
    try {
      if (prev.doubleClickZoom) (map as any).doubleClickZoom?.enable?.();
      if (prev.boxZoom) (map as any).boxZoom?.enable?.();
      if (prev.dragPan) (map as any).dragPan?.enable?.();
      if (prev.keyboard) (map as any).keyboard?.enable?.();
      if (prev.touchZoomRotate) (map as any).touchZoomRotate?.enable?.();
    } catch {
      // ignore
    }
  }, [map]);

  // Курсор и listeners чрез Mapbox събития (подобно на картата с пожарите)
  useEffect(() => {
    if (!map) return;
    const container = map.getContainer();

    const applyCursor = () => {
      try {
        const cc = map.getCanvas?.();
        if (!cc) return;
        (cc as HTMLCanvasElement).style.cursor = mode === "idle" ? "" : "crosshair";
      } catch {}
    };

    // Активни слушатели и курсор само при истинско рисуване (polygon)
    if (mode !== "polygon") {
      applyCursor();
      unlockInteractions();
      setHint("");
      return;
    }

    // активен режим → блок интеракции и подсказка
    lockInteractions();
    applyCursor();
    setHint(
      isMobile
        ? "Тапай върху картата, за да добавяш точки и очертаеш зоната. Двоен тап или бутона ‘Готово’ за край."
        : "Кликвай, за да добавяш точки. Двоен клик/Enter за край. Десен клик/Backspace за назад. Esc за отказ."
    );

    // Интеграция с Mapbox Draw за полигон
    if (mode === "polygon") {
      try {
        // Ако вече има draw control – махаме го, за да зададем правилен режим
        if (drawRef.current) {
          try { map.removeControl(drawRef.current as any); } catch {}
          drawRef.current = null;
        }
        const draw = new MapboxDraw({
          displayControlsDefault: false,
          controls: {},
          // Стартираме в simple_select; ще превключим към draw_polygon само ако няма предварителни точки
          defaultMode: "simple_select",
        });
        map.addControl(draw as any, "top-right");
        drawRef.current = draw;
        try {
          const pts = pointsRef.current;
          if (pts && pts.length >= 3) {
            const ring = pts.concat([pts[0]]);
            let fid: any = (draw as any).add({
              type: "Feature",
              properties: {},
              geometry: { type: "Polygon", coordinates: [ring] },
            });
            if (Array.isArray(fid)) fid = fid[0];
            // Веднага включваме редакция на върховете
            (draw as any).changeMode && (draw as any).changeMode("direct_select", { featureId: fid });
          } else {
            (draw as any).changeMode && (draw as any).changeMode("draw_polygon");
          }
        } catch {}

        const syncFromDraw = () => {
          const data = draw.getAll();
          if (!data || !data.features || data.features.length === 0) {
            setPoints([]);
            return;
          }
          // Вземаме първия полигон и външния ринг
          const poly: any = data.features.find((f: any) => f.geometry?.type === "Polygon");
          if (!poly) return;
          const ring: [number, number][] = (poly.geometry as any).coordinates?.[0] || [];
          // махаме последната дублираща се точка (затваряне)
          const cleaned = ring.slice(0, ring.length > 1 ? ring.length - 1 : ring.length);
          setPoints(cleaned);
        };
        const onCreate = () => {
          syncFromDraw();
          // На телефон след приключване на полигона → преминаваме към попълване на детайли
          if (isMobile) setMode("details");
        };
        const onUpdate = () => syncFromDraw();
        const onDelete = () => {
          setPoints([]);
          try { (draw as any).changeMode && (draw as any).changeMode("draw_polygon"); } catch {}
        };
        const onModeChange = (ev: any) => {
          try {
            const modeName = ev?.mode;
            if (modeName !== "draw_polygon") {
              const data = draw.getAll();
              const hasFeatures = !!(data && data.features && data.features.length > 0);
              if (!hasFeatures) {
                (draw as any).changeMode && (draw as any).changeMode("draw_polygon");
              }
            }
          } catch {}
        };

        map.on("draw.create", onCreate as any);
        map.on("draw.update", onUpdate as any);
        map.on("draw.delete", onDelete as any);
        map.on("draw.modechange", onModeChange as any);

        // Запазваме cleanup функции в ref за по-късно
        (drawRef as any).listeners = { onCreate, onUpdate, onDelete, onModeChange };
      } catch (e) {
        console.error("MapboxDraw init error", e);
      }
    }

    // DOM helpers (работят и върху маркери/попъпи)
    const toLngLat = (e: MouseEvent) => {
      const rect = container.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      const ll = map.unproject([x, y]);
      return { lng: ll.lng, lat: ll.lat };
    };

    const onClick = (e: mapboxgl.MapMouseEvent) => {
      const { lng, lat } = e.lngLat;
      if (modeRef.current === "polygon" && drawRef.current) return; // Draw поема полигон

      if (modeRef.current === "polygon") {
        // Ако кликът е достатъчно близо до първата точка → подсказка за затваряне
        const pts = pointsRef.current;
        if (pts.length >= 3) {
          try {
            const p0 = pts[0];
            const a = map.project({ lng: p0[0], lat: p0[1] });
            const b = map.project({ lng, lat });
            const d = Math.hypot(a.x - b.x, a.y - b.y);
            if (d < 12) {
              setHint("Полигон затворен. Натисни „Създай зона“ или Enter.");
              return;
            }
          } catch {}
        }

        setPoints((prev) => [...prev, [lng, lat]]);
        setHint((prev) =>
          (pointsRef.current.length + 1 >= 3)
            ? "Двоен клик или Enter за завършване. Десен клик/Backspace за назад."
            : "Добави още точки."
        );
      }
    };

    const onDomClick = (e: MouseEvent) => {
      // Ако използваме Mapbox Draw за полигон, не спираме събитията
      if (modeRef.current === "polygon" && drawRef.current) return;
      // В противен случай прихващаме събитието върху контейнера
      e.preventDefault();
      e.stopPropagation();
      const { lng, lat } = toLngLat(e);
      if (modeRef.current === "polygon") {
        const pts = pointsRef.current;
        if (pts.length >= 3) {
          try {
            const p0 = pts[0];
            const a = map.project({ lng: p0[0], lat: p0[1] });
            const b = map.project({ lng, lat });
            const d = Math.hypot(a.x - b.x, a.y - b.y);
            if (d < 12) {
              setHint("Полигон затворен. Натисни „Създай зона“ или Enter.");
              return;
            }
          } catch {}
        }
        setPoints((prev) => [...prev, [lng, lat]]);
        setHint((prev) =>
          (pointsRef.current.length + 1 >= 3)
            ? "Двоен клик или Enter за завършване. Десен клик/Backspace за назад."
            : "Добави още точки."
        );
      }
    };

    const onMouseMove = (e: mapboxgl.MapMouseEvent) => {
      const { lng, lat } = e.lngLat;
      if (modeRef.current === "polygon" && drawRef.current) return; // Draw поема полигон
      if (modeRef.current === "polygon") {
        setCursor([lng, lat]);
      }
    };

    const onDomMouseMove = (e: MouseEvent) => {
      // Ако използваме Mapbox Draw за полигон, не спираме/обработваме DOM събитията
      if (modeRef.current === "polygon" && drawRef.current) return;
      const { lng, lat } = toLngLat(e);
      if (modeRef.current === "polygon") {
        setCursor([lng, lat]);
      }
    };

    const onDblClick = (_e: mapboxgl.MapMouseEvent) => {
      if (modeRef.current === "polygon" && drawRef.current) return; // Draw поема полигон
      if (modeRef.current === "polygon" && pointsRef.current.length >= 3) {
        if (isMobile) setMode("details");
        else createZone();
      }
    };

    const onDomDblClick = (e: MouseEvent) => {
      // Ако използваме Mapbox Draw за полигон, не спираме събитията
      if (modeRef.current === "polygon" && drawRef.current) return;
      e.preventDefault();
      e.stopPropagation();
      if (modeRef.current === "polygon" && pointsRef.current.length >= 3) {
        if (isMobile) setMode("details");
        else createZone();
      }
    };

    const onContext = (_e: mapboxgl.MapMouseEvent) => {
      if (modeRef.current === "polygon" && drawRef.current) return; // Draw поема полигон
      if (modeRef.current !== "polygon") return;
      if (pointsRef.current.length === 0) return;
      setPoints((p) => p.slice(0, -1));
    };

    const onDomContext = (e: MouseEvent) => {
      if (modeRef.current !== "polygon") return;
      if (pointsRef.current.length === 0) return;
      // Ако Mapbox Draw е активен, оставяме събитията да минат към него
      if (drawRef.current) return;
      e.preventDefault();
      e.stopPropagation();
      setPoints((p) => p.slice(0, -1));
    };

    const onKeyDown = (e: KeyboardEvent) => {
      const m = modeRef.current;
      if (m !== "polygon") return;

      // Always allow closing with Escape
      if (e.key === "Escape") {
        e.preventDefault();
        reset();
        return;
      }

      // If Mapbox Draw is active, let it handle Backspace/Delete for vertex/feature deletion.
      if (drawRef.current) {
        if ((e.key === "Enter" || e.key === "Return") && pointsRef.current.length >= 3) {
          // Allow Enter to finalize via our create handler
          e.preventDefault();
          createZone();
        }
        return;
      }

      // Fallback (no Draw): local handling
      if ((e.key === "Backspace" || e.key === "Delete") && pointsRef.current.length > 0) {
        e.preventDefault();
        setPoints((p) => p.slice(0, -1));
      }
      if ((e.key === "Enter" || e.key === "Return") && pointsRef.current.length >= 3) {
        e.preventDefault();
        createZone();
      }
    };

    // Mapbox събития (както при докладване на пожар) – за circle
    map.on("click", onClick as any);
    map.on("mousemove", onMouseMove as any);
    map.on("dblclick", onDblClick as any);
    map.on("contextmenu", onContext as any);
    window.addEventListener("keydown", onKeyDown);

    // DOM capture върху контейнера → работи и при клик върху HTML маркери/попъпи
    container.addEventListener("click", onDomClick, { capture: true });
    container.addEventListener("mousemove", onDomMouseMove, { capture: true });
    container.addEventListener("dblclick", onDomDblClick, { capture: true });
    container.addEventListener("contextmenu", onDomContext, { capture: true });

    const cleanup = () => {
      try {
        map.off("click", onClick as any);
        map.off("mousemove", onMouseMove as any);
        map.off("dblclick", onDblClick as any);
        map.off("contextmenu", onContext as any);
        window.removeEventListener("keydown", onKeyDown);
        container.removeEventListener("click", onDomClick, { capture: true } as any);
        container.removeEventListener("mousemove", onDomMouseMove, { capture: true } as any);
        container.removeEventListener("dblclick", onDomDblClick, { capture: true } as any);
        container.removeEventListener("contextmenu", onDomContext, { capture: true } as any);
        // премахваме draw ако е активен
        try {
          if (drawRef.current) {
            // изключваме draw listeners
            const lst: any = (drawRef as any).listeners;
            if (lst) {
              try { map.off("draw.create", lst.onCreate as any); } catch {}
              try { map.off("draw.update", lst.onUpdate as any); } catch {}
              try { map.off("draw.delete", lst.onDelete as any); } catch {}
              try { map.off("draw.modechange", lst.onModeChange as any); } catch {}
            }
            map.removeControl(drawRef.current as any);
            drawRef.current = null;
          }
        } catch {}
      } catch {}
      applyCursor();
      unlockInteractions();
      setCursor(null);
      setHint("");
    };
    return cleanup;
  }, [map, lockInteractions, unlockInteractions, mode, isMobile]);

  // Превю слоеве: ensure + live update + cleanup (изключени, когато е активен MapboxDraw за полигон)
  useEffect(() => {
    if (!map) return;
    if (mode === "polygon" && drawRef.current) return; // draw се грижи за визуализацията

    const ensure = () => {
      if (!map || !map.isStyleLoaded()) return;
      const fc = previewGeojson;
      try {
        if (!map.getSource(PREVIEW_SRC)) {
          map.addSource(PREVIEW_SRC, { type: "geojson", data: fc });
        } else {
          (map.getSource(PREVIEW_SRC) as any)?.setData?.(fc);
        }

        if (!map.getLayer(PREVIEW_FILL)) {
          map.addLayer({
            id: PREVIEW_FILL,
            type: "fill",
            source: PREVIEW_SRC,
            filter: ["==", ["geometry-type"], "Polygon"],
            paint: { "fill-color": "#22c55e", "fill-opacity": 0.16 },
          });
        }
        if (!map.getLayer(PREVIEW_LINE)) {
          map.addLayer({
            id: PREVIEW_LINE,
            type: "line",
            source: PREVIEW_SRC,
            paint: { "line-color": "#16a34a", "line-width": 2, "line-opacity": 0.8 },
          });
        }
        if (!map.getLayer(PREVIEW_PTS)) {
          map.addLayer({
            id: PREVIEW_PTS,
            type: "circle",
            source: PREVIEW_SRC,
            filter: [
              "any",
              ["==", ["geometry-type"], "Point"],
              ["==", ["geometry-type"], "MultiPoint"],
            ],
            paint: {
              "circle-radius": 6,
              "circle-color": "#16a34a",
              "circle-stroke-color": "#064e3b",
              "circle-stroke-width": 1,
              "circle-opacity": 0.9,
            },
          });
        }

        // Винаги държим превю слоевете най-отгоре
        try {
          if (map.getLayer(PREVIEW_FILL)) (map as any).moveLayer(PREVIEW_FILL);
          if (map.getLayer(PREVIEW_LINE)) (map as any).moveLayer(PREVIEW_LINE);
          if (map.getLayer(PREVIEW_PTS)) (map as any).moveLayer(PREVIEW_PTS);
        } catch {}
      } catch {
        // ignore transient style errors
      }
    };

    const onStyle = () => ensure();
    map.on("style.load", onStyle as any);
    if (map.isStyleLoaded()) ensure();

    return () => {
      try {
        map.off("style.load", onStyle as any);
      } catch {}
    };
  }, [map, previewGeojson, mode]);

  // Live обновяване на GeoJSON-а
  useEffect(() => {
    if (!map || !map.isStyleLoaded()) return;
    if (mode === "polygon" && drawRef.current) return; // draw mode → прескачаме
    try {
      (map.getSource(PREVIEW_SRC) as any)?.setData?.(previewGeojson);
    } catch {}
  }, [map, previewGeojson, mode]);

  // Премахване на превю слоевете при idle/Unmount
  useEffect(() => {
    if (!map) return;
    if (mode !== "idle") return;
    
    try {
      if (map.getLayer(PREVIEW_LINE)) map.removeLayer(PREVIEW_LINE);
      if (map.getLayer(PREVIEW_FILL)) map.removeLayer(PREVIEW_FILL);
      if (map.getLayer(PREVIEW_PTS)) map.removeLayer(PREVIEW_PTS);
      if (map.getSource(PREVIEW_SRC)) map.removeSource(PREVIEW_SRC);
    } catch {}
  }, [map, mode]);

  const createZone = useCallback(() => {
    if (!map) return;
    const pts = pointsRef.current;
    if (!pts || pts.length < 3) return alert("Минимум 3 точки.");
    // На мобилни: ако още не сме отворили формата за детайли → отвори я
    if (isMobile && mode !== "details") {
      setMode("details");
      return;
    }
    startTransition(async () => {
      const res = await fetch(`/api/fires/${fireId}/zones`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          title,
          description,
          geomType: "polygon",
          polygon: pts,
        }),
      }).then((r) => r.json());
      if (!res?.ok) return alert(res?.error || "Грешка");
      reset();
      onCreated?.();
    });
  }, [map, fireId, title, description, onCreated, isMobile, mode]);

  function reset() {
    setMode("idle");
    setPoints([]);
    setCursor(null);
    setTitle("");
    setDescription("");
    setHint("");
  }

  return (
    <>
      {/* Desktop / non-drawing full panel OR any non-mobile */}
      {!(isMobile && mode === "polygon") && (
        <div className="bg-background/90 backdrop-blur-md border rounded-lg shadow-lg p-3 w-[320px] sm:w-[380px] space-y-2">
          <div className="flex items-center justify-between">
            <div className="text-sm font-medium">Създай зона</div>
            <div className="flex items-center gap-1">
              <Button size="icon" variant="ghost" onClick={() => { reset(); onClose?.(); }} title="Затвори">
                <XCircle className="h-4 w-4" />
              </Button>
            </div>
          </div>

          <div className="flex gap-2">
            {/* Desktop: Undo last point if not using Draw; Mobile details: go back to edit */}
            {(!drawRef.current || (isMobile && mode === "details")) && (
              <Button
                size="sm"
                variant="outline"
                onClick={() => {
                  if (isMobile && mode === "details") {
                    setMode("polygon");
                  } else {
                    setPoints((p) => p.slice(0, -1));
                  }
                }}
                disabled={!isMobile && points.length === 0}
              >
                <Undo2 className="h-4 w-4 mr-1" /> {isMobile && mode === "details" ? "Назад към полигона" : "Назад"}
              </Button>
            )}
            <Button
              size="sm"
              variant="outline"
              onClick={() => {
                if (isMobile && mode === "details") {
                  setPoints([]);
                  setMode("polygon");
                  return;
                }
                if (drawRef.current) {
                  try { (drawRef.current as any).deleteAll(); } catch {}
                  try { (drawRef.current as any).changeMode && (drawRef.current as any).changeMode("draw_polygon"); } catch {}
                }
                setPoints([]);
              }}
              disabled={(!drawRef.current && points.length === 0)}
            >
              Изчисти
            </Button>
          </div>

          <Input placeholder="Име (по желание)" value={title} onChange={(e) => setTitle(e.target.value)} />
          <Textarea placeholder="Описание (по желание)" value={description} onChange={(e) => setDescription(e.target.value)} rows={3} />

          {mode === "polygon" && (
            <div className="text-xs text-muted-foreground flex items-center gap-1">
              <MousePointer2 className="h-3.5 w-3.5" />
              <span>
                Кликвай точки. Двоен клик/Enter за край. Десен клик/Backspace за назад. Точки: {points.length}
              </span>
            </div>
          )}

          {hint && <div className="text-xs text-muted-foreground">{hint}</div>}

          <div className="flex gap-2">
            <Button
              size="sm"
              onClick={createZone}
              disabled={isPending || (mode === "polygon" && points.length < 3)}
            >
              {isPending ? "Създаване…" : (<><Check className="h-4 w-4 mr-1" /> Създай зона</>)}
            </Button>
          </div>
        </div>
      )}

      {/* Mobile drawing: compact overlay controls, keep map fully usable */}
      {isMobile && mode === "polygon" && (
        <>
          <div className="fixed top-4 left-1/2 -translate-x-1/2 z-[100] px-3 py-2 rounded-full border bg-background/90 backdrop-blur text-xs text-muted-foreground shadow max-w-[92vw] text-center">
            Тапай върху картата, за да добавяш точки и очертаеш зоната. Двоен тап или „Готово“ за край. Точки: {points.length}
          </div>
          <div className="fixed bottom-4 left-1/2 -translate-x-1/2 z-[100]">
            <div className="flex items-center gap-2 bg-background/95 backdrop-blur px-3 py-2 rounded-full border shadow-lg">
              {!drawRef.current && (
                <Button size="sm" variant="ghost" onClick={() => setPoints((p) => p.slice(0, -1))} disabled={points.length === 0}>
                  Назад
                </Button>
              )}
              <Button
                size="sm"
                variant="ghost"
                onClick={() => {
                  if (drawRef.current) {
                    try { (drawRef.current as any).deleteAll(); } catch {}
                    try { (drawRef.current as any).changeMode && (drawRef.current as any).changeMode("draw_polygon"); } catch {}
                  }
                  setPoints([]);
                }}
                disabled={(!drawRef.current && points.length === 0)}
              >
                Изчисти
              </Button>
              <Button
                size="sm"
                onClick={() => {
                  if (points.length < 3) return alert("Минимум 3 точки.");
                  setMode("details");
                }}
                disabled={isPending || points.length < 3}
              >
                Готово
              </Button>
              <Button size="sm" variant="outline" onClick={() => { reset(); onClose?.(); }}>
                Откажи
              </Button>
            </div>
          </div>
        </>
      )}
    </>
  );
}
\n===== END FILE: components/zones/zone-draw.tsx =====\n
===== FILE: components/zones/zone-list.tsx =====
"use client";

import { useEffect, useMemo, useState } from "react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Users, ArrowRight, CheckCircle2 } from "lucide-react";
import { AspectRatio } from "@/components/ui/aspect-ratio";
import { circlePolygon } from "@/lib/geo";
import { useRouter } from "next/navigation";

type Zone = {
  id: number;
  title?: string | null;
  description?: string | null;
  geomType: "circle" | "polygon";
  centerLat?: number | null;
  centerLng?: number | null;
  radiusM?: number | null;
  polygon?: [number, number][];
  createdAt: string;
  members: number;
  isMember?: boolean;
  coverUrl?: string | null;
};

const TOKEN = process.env.NEXT_PUBLIC_MAPBOX_TOKEN;
const STYLE = "satellite-streets-v12";

/** Генерира статично Mapbox превю с очертанията на зоната */
function buildStaticMapPreview(z: Zone) {
  if (!TOKEN) return null;

  const path = (() => {
    if (z.geomType === "circle" && z.centerLat != null && z.centerLng != null && z.radiusM) {
      const poly = circlePolygon({ lat: z.centerLat, lng: z.centerLng }, z.radiusM, 60).geometry.coordinates[0];
      const pts = poly.map(([lng, lat]) => `${lng.toFixed(6)},${lat.toFixed(6)}`).join(";");
      return `path-3+dc2626-80(${pts})`;
    }
    const ring = (z.polygon || []).concat([(z.polygon || [])[0] || [0, 0]]);
    const pts = ring.map(([lng, lat]) => `${lng},${lat}`).join(";");
    return `path-3+dc2626-80(${pts})`;
  })();

  const overlay = encodeURIComponent(path);
  // @2x за по-остри изображения; padding=40 дава въздух около очертанията
  const size = "560x260@2x";
  return `https://api.mapbox.com/styles/v1/mapbox/${STYLE}/static/${overlay}/auto/${size}?padding=40&access_token=${TOKEN}`;
}

export default function ZoneList({
  fireId,
  canEdit,
  onChange,
  refreshAt,
}: {
  fireId: number;
  canEdit: boolean;
  onChange?: () => void;
  refreshAt?: number;
}) {
  const router = useRouter();
  const [zones, setZones] = useState<Zone[]>([]);
  const [joining, setJoining] = useState<number | null>(null);
  const [leaving, setLeaving] = useState(false);

  async function load() {
    const res = await fetch(`/api/fires/${fireId}/zones`, { cache: "no-store" }).then((r) => r.json());
    if (res?.ok) setZones(res.zones);
  }
  useEffect(() => {
    load();
  }, [fireId, refreshAt]);

  const sorted = useMemo(() => {
    const arr = [...zones];
    arr.sort((a, b) => {
      if (a.isMember && !b.isMember) return -1;
      if (!a.isMember && b.isMember) return 1;
      // по-новите и/или по-масовите да са по-напред
      const createdDiff = new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime();
      if (createdDiff !== 0) return createdDiff;
      return (b.members ?? 0) - (a.members ?? 0);
    });
    return arr;
  }, [zones]);

  const join = async (zoneId: number) => {
    setJoining(zoneId);
    try {
      const res = await fetch(`/api/fires/${fireId}/zones/${zoneId}/join`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ action: "join" }),
      }).then((r) => r.json());
      if (!res?.ok) throw new Error(res?.error || "Грешка");
      onChange?.();
      load();
    } catch (e: any) {
      alert(e?.message || "Грешка");
    } finally {
      setJoining(null);
    }
  };

  const leave = async () => {
    setLeaving(true);
    try {
      const res = await fetch(`/api/fires/${fireId}/zones/0/join`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ action: "leave" }),
      }).then((r) => r.json());
      if (!res?.ok) throw new Error(res?.error || "Грешка");
      onChange?.();
      load();
    } catch (e: any) {
      alert(e?.message || "Грешка");
    } finally {
      setLeaving(false);
    }
  };

  return (
    <div className="grid gap-4 sm:grid-cols-2 lg:grid-cols-3">
      {sorted.map((z) => {
        const preview = z.coverUrl || buildStaticMapPreview(z) || null;

        return (
          <Card
            key={z.id}
            className={[
              "overflow-hidden transition-all duration-200 border",
              z.isMember ? "ring-2 ring-primary/70 border-primary/30 shadow-md" : "hover:shadow-md",
            ].join(" ")}
          >
            {preview ? (
              <div className="p-3 pb-0">
                <AspectRatio ratio={16 / 7}>
                  {/* eslint-disable-next-line @next/next/no-img-element */}
                  <img
                    src={preview}
                    alt={z.title || `Зона #${z.id}`}
                    className="h-full w-full object-cover rounded-lg border"
                  />
                </AspectRatio>
              </div>
            ) : (
              <div className="mx-3 mt-3 h-[160px] rounded-lg border bg-gradient-to-br from-muted to-background" />
            )}

            <CardHeader className="pb-2">
              <CardTitle className="flex items-center justify-between gap-2">
                <span className="truncate">{z.title || `Зона #${z.id}`}</span>
                <Badge variant={z.isMember ? "default" : "secondary"} className="whitespace-nowrap">
                  <Users className="h-3.5 w-3.5 mr-1" />
                  {z.members}
                </Badge>
              </CardTitle>
            </CardHeader>

            <CardContent className="space-y-3">
              {z.description ? (
                <p className="text-sm text-muted-foreground line-clamp-2">{z.description}</p>
              ) : (
                <p className="text-sm text-muted-foreground italic">Няма описание.</p>
              )}

              <div className="flex flex-wrap items-center gap-2 pt-1">
                {z.isMember ? (
                  <>
                    <Button
                      size="sm"
                      className="group"
                      onClick={() => router.push(`/fires/${fireId}/zones/${z.id}`)}
                    >
                      Още за зоната
                      <ArrowRight className="h-4 w-4 ml-1 transition-transform group-hover:translate-x-0.5" />
                    </Button>
                    <Button
                      size="sm"
                      variant="outline"
                      onClick={leave}
                      disabled={leaving}
                    >
                      {leaving ? "Излизане…" : "Излез от зона"}
                    </Button>
                    <Badge className="ml-auto" variant="outline">
                      <CheckCircle2 className="h-3.5 w-3.5 mr-1" />
                      В зоната
                    </Badge>
                  </>
                ) : (
                  <Button
                    size="sm"
                    onClick={() => join(z.id)}
                    disabled={joining === z.id}
                    className="w-full sm:w-auto"
                  >
                    {joining === z.id ? "Присъединяване…" : "Влез в зоната"}
                  </Button>
                )}
              </div>

              {false && canEdit && null}
            </CardContent>
          </Card>
        );
      })}
      {zones.length === 0 && (
        <div className="text-sm text-muted-foreground">Няма зони.</div>
      )}
    </div>
  );
}
\n===== END FILE: components/zones/zone-list.tsx =====\n
===== FILE: components/zones/zone-shapes.tsx =====
"use client";

import { useCallback, useEffect, useMemo, useState } from "react";
import { useMap } from "@/context/map-context";
import { circlePolygon } from "@/lib/geo";
import Popup from "@/components/map/map-popup";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Users } from "lucide-react";
import { useRouter } from "next/navigation";

type Zone = {
  id: number;
  fireId: number;
  title?: string | null;
  description?: string | null;
  geomType: "circle" | "polygon";
  centerLat?: number | null;
  centerLng?: number | null;
  radiusM?: number | null;
  polygon?: [number, number][];
  // optional membership flag (present in ZoneListItem)
  isMember?: boolean;
  // optional extras when provided from list endpoint
  createdAt?: string;
  members?: number;
  coverUrl?: string | null;
};

const SRC_ID = "zones-polygons-src";
const FILL_ID = "zones-polygons-fill";
const LINE_ID = "zones-polygons-line";
// Special highlight layers for user's own zone (kept above all)
const MY_FILL_ID = "zones-polygons-fill-my";
const MY_LINE_ID = "zones-polygons-line-my";

export default function ZoneShapes({ zones, onChange }: { zones: Zone[]; onChange?: () => void }) {
  const { map } = useMap();
  const router = useRouter();

  const [selected, setSelected] = useState<
    | {
        id: number;
        fireId: number;
        title: string;
        isMember?: boolean;
        lng: number;
        lat: number;
      }
    | null
  >(null);
  const [joining, setJoining] = useState(false);
  const [leaving, setLeaving] = useState(false);

  // optimisticMark is defined after geojson

  const geojson = useMemo(() => {
    return {
      type: "FeatureCollection" as const,
      features: zones.map((z) => {
        const geometry =
          z.geomType === "circle" && z.centerLat != null && z.centerLng != null && z.radiusM
            ? circlePolygon({ lat: z.centerLat, lng: z.centerLng }, z.radiusM).geometry
            : {
                type: "Polygon" as const,
                coordinates: [(z.polygon || []).concat([(z.polygon || [])[0] || [0, 0]])] as [number, number][][],
              };
        return {
          type: "Feature" as const,
          properties: { id: z.id, fireId: z.fireId, title: z.title || "", isMember: !!z.isMember },
          geometry,
        };
      }),
    };
  }, [zones]);

  // Optimistic map style update: mark my zone immediately after join/leave
  const optimisticMark = useCallback(
    (mode: "join" | "leave", zoneId?: number) => {
      if (!map) return;
      try {
        const src: any = map.getSource(SRC_ID);
        if (!src || !src.setData) return;
        const newFc = {
          ...geojson,
          features: (geojson.features || []).map((f: any) => {
            const fid = Number(f?.properties?.id);
            const isMy = mode === "join" ? fid === zoneId : false;
            return { ...f, properties: { ...f.properties, isMember: isMy } };
          }),
        } as any;
        src.setData(newFc);
      } catch {}
    },
    [map, geojson],
  );

  useEffect(() => {
    if (!map) return;

    const ensure = () => {
      // Be defensive: sometimes isStyleLoaded() lies during rapid mounts.
      if (!map) return;
      try {
        // Ensure source exists, otherwise add it
        if (!map.getSource(SRC_ID)) {
          map.addSource(SRC_ID, { type: "geojson", data: geojson });
        }
        // Update data (safe even immediately after add)
        (map.getSource(SRC_ID) as any)?.setData?.(geojson);

        // Ensure fill/line layers exist
        if (!map.getLayer(FILL_ID)) {
          map.addLayer({
            id: FILL_ID,
            type: "fill",
            source: SRC_ID,
            // Base zones (not my zone)
            filter: ["!=", ["get", "isMember"], true],
            paint: {
              "fill-color": "#ef4444",
              "fill-opacity": 0.15,
            },
          });
        }
        if (!map.getLayer(LINE_ID)) {
          map.addLayer({
            id: LINE_ID,
            type: "line",
            source: SRC_ID,
            filter: ["!=", ["get", "isMember"], true],
            paint: {
              "line-color": "#dc2626",
              "line-width": 2,
              "line-opacity": 0.7,
            },
          });
        }
        // My zone highlight layers
        if (!map.getLayer(MY_FILL_ID)) {
          map.addLayer({
            id: MY_FILL_ID,
            type: "fill",
            source: SRC_ID,
            filter: ["==", ["get", "isMember"], true],
            paint: {
              // Blue highlight with slightly higher opacity
              "fill-color": "#3b82f6",
              "fill-opacity": 0.22,
            },
          });
        }
        if (!map.getLayer(MY_LINE_ID)) {
          map.addLayer({
            id: MY_LINE_ID,
            type: "line",
            source: SRC_ID,
            filter: ["==", ["get", "isMember"], true],
            paint: {
              // Stronger outline
              "line-color": "#1d4ed8",
              "line-width": 3,
              "line-opacity": 0.85,
            },
          });
        }
        // Keep zone layers near the top for reliable clicks
        try {
          if (map.getLayer(FILL_ID)) (map as any).moveLayer(FILL_ID);
          if (map.getLayer(LINE_ID)) (map as any).moveLayer(LINE_ID);
          if (map.getLayer(MY_FILL_ID)) (map as any).moveLayer(MY_FILL_ID);
          if (map.getLayer(MY_LINE_ID)) (map as any).moveLayer(MY_LINE_ID);
        } catch {}
      } catch {}
    };

    // Try on multiple lifecycle events to beat race conditions
    const onLoad = () => ensure();
    const onStyle = () => ensure();
    const onIdle = () => ensure();
    map.on("load", onLoad as any);
    map.on("style.load", onStyle as any);
    map.on("idle", onIdle as any);
    // Also attempt immediately if the style is already ready
    try {
      if (map.isStyleLoaded?.()) ensure();
    } catch {}
    // And schedule a short retry window just in case
    const t1 = setTimeout(ensure, 150);
    const t2 = setTimeout(ensure, 500);

    return () => {
      try {
        clearTimeout(t1);
        clearTimeout(t2);
        map.off("load", onLoad as any);
        map.off("style.load", onStyle as any);
        map.off("idle", onIdle as any);
      } catch {}
    };
  }, [map, geojson]);

  useEffect(() => {
    if (!map || !map.isStyleLoaded()) return;
    try {
      // If source/layers are missing for any reason (e.g. a late style refresh), re-create them
      if (!map.getSource(SRC_ID)) {
        try {
          map.addSource(SRC_ID, { type: "geojson", data: geojson });
        } catch {}
      } else {
        (map.getSource(SRC_ID) as any)?.setData?.(geojson);
      }
      if (!map.getLayer(FILL_ID)) {
        try {
          map.addLayer({ id: FILL_ID, type: "fill", source: SRC_ID, filter: ["!=", ["get", "isMember"], true], paint: { "fill-color": "#ef4444", "fill-opacity": 0.15 } });
        } catch {}
      }
      if (!map.getLayer(LINE_ID)) {
        try {
          map.addLayer({ id: LINE_ID, type: "line", source: SRC_ID, filter: ["!=", ["get", "isMember"], true], paint: { "line-color": "#dc2626", "line-width": 2, "line-opacity": 0.7 } });
        } catch {}
      }
      if (!map.getLayer(MY_FILL_ID)) {
        try {
          map.addLayer({ id: MY_FILL_ID, type: "fill", source: SRC_ID, filter: ["==", ["get", "isMember"], true], paint: { "fill-color": "#3b82f6", "fill-opacity": 0.22 } });
        } catch {}
      }
      if (!map.getLayer(MY_LINE_ID)) {
        try {
          map.addLayer({ id: MY_LINE_ID, type: "line", source: SRC_ID, filter: ["==", ["get", "isMember"], true], paint: { "line-color": "#1d4ed8", "line-width": 3, "line-opacity": 0.85 } });
        } catch {}
      }
      try {
        if (map.getLayer(FILL_ID)) (map as any).moveLayer(FILL_ID);
        if (map.getLayer(LINE_ID)) (map as any).moveLayer(LINE_ID);
        if (map.getLayer(MY_FILL_ID)) (map as any).moveLayer(MY_FILL_ID);
        if (map.getLayer(MY_LINE_ID)) (map as any).moveLayer(MY_LINE_ID);
      } catch {}
    } catch {}
  }, [map, geojson]);

  // Interactions: hover + click on polygons
  useEffect(() => {
    if (!map) return;

    const onEnter = () => {
      try {
        const c = map.getCanvas?.();
        if (c) (c as HTMLCanvasElement).style.cursor = "pointer";
      } catch {}
    };
    const onLeave = () => {
      try {
        const c = map.getCanvas?.();
        if (c) (c as HTMLCanvasElement).style.cursor = "";
      } catch {}
    };
    const onClick = (e: any) => {
      const f = e?.features?.[0];
      if (!f) return;
      const p = f.properties || {};
      const id = Number(p.id);
      const fireId = Number(p.fireId);
      const title = String(p.title || "Зона");
      const isMember = p.isMember === true || p.isMember === "true" || p.isMember === 1 || p.isMember === "1";
      const { lng, lat } = e.lngLat || { lng: 0, lat: 0 };
      if (isMember) {
        // Direct navigation for user's own zone
        router.push(`/fires/${fireId}/zones/${id}`);
        setSelected(null);
        return;
      }
      setSelected({ id, fireId, title, isMember, lng, lat });
    };

    let onMapClick: ((ev: any) => void) | null = null;

    const attach = () => {
      try {
        if (map.getLayer(FILL_ID)) {
          map.on("mouseenter", FILL_ID, onEnter as any);
          map.on("mouseleave", FILL_ID, onLeave as any);
          map.on("click", FILL_ID, onClick as any);
        }
        if (map.getLayer(LINE_ID)) {
          map.on("mouseenter", LINE_ID, onEnter as any);
          map.on("mouseleave", LINE_ID, onLeave as any);
          map.on("click", LINE_ID, onClick as any);
        }
        if (map.getLayer(MY_FILL_ID)) {
          map.on("mouseenter", MY_FILL_ID, onEnter as any);
          map.on("mouseleave", MY_FILL_ID, onLeave as any);
          map.on("click", MY_FILL_ID, onClick as any);
        }
        if (map.getLayer(MY_LINE_ID)) {
          map.on("mouseenter", MY_LINE_ID, onEnter as any);
          map.on("mouseleave", MY_LINE_ID, onLeave as any);
          map.on("click", MY_LINE_ID, onClick as any);
        }
        // Global fallback click: query features from our layers (more robust)
        onMapClick = (ev: any) => {
          try {
            const layersToQuery = [MY_FILL_ID, MY_LINE_ID, FILL_ID, LINE_ID].filter((id) => !!map.getLayer(id));
            if (layersToQuery.length === 0) return;
            const feats = map.queryRenderedFeatures(ev.point, { layers: layersToQuery as any });
            const f = feats?.[0];
            if (!f) return;
            const p: any = f.properties || {};
            const id = Number(p.id);
            const fireId = Number(p.fireId);
            const title = String(p.title || "Зона");
            const isMember = p.isMember === true || p.isMember === "true" || p.isMember === 1 || p.isMember === "1";
            const { lng, lat } = ev.lngLat || { lng: 0, lat: 0 };
            if (isMember) {
              router.push(`/fires/${fireId}/zones/${id}`);
              setSelected(null);
              return;
            }
            setSelected({ id, fireId, title, isMember, lng, lat });
          } catch {}
        };
        map.on("click", onMapClick as any);
      } catch {}
    };
    const detach = () => {
      try {
        if (map.getLayer(FILL_ID)) {
          map.off("mouseenter", FILL_ID, onEnter as any);
          map.off("mouseleave", FILL_ID, onLeave as any);
          map.off("click", FILL_ID, onClick as any);
        }
        if (map.getLayer(LINE_ID)) {
          map.off("mouseenter", LINE_ID, onEnter as any);
          map.off("mouseleave", LINE_ID, onLeave as any);
          map.off("click", LINE_ID, onClick as any);
        }
        if (map.getLayer(MY_FILL_ID)) {
          map.off("mouseenter", MY_FILL_ID, onEnter as any);
          map.off("mouseleave", MY_FILL_ID, onLeave as any);
          map.off("click", MY_FILL_ID, onClick as any);
        }
        if (map.getLayer(MY_LINE_ID)) {
          map.off("mouseenter", MY_LINE_ID, onEnter as any);
          map.off("mouseleave", MY_LINE_ID, onLeave as any);
          map.off("click", MY_LINE_ID, onClick as any);
        }
        if (onMapClick) map.off("click", onMapClick as any);
      } catch {}
    };

    attach();
    const onStyle = () => {
      detach();
      attach();
    };
    map.on("style.load", onStyle as any);

    return () => {
      try {
        map.off("style.load", onStyle as any);
      } catch {}
      detach();
    };
  }, [map]);

  useEffect(() => {
    return () => {
      if (!map) return;
      try {
        if (map.getLayer(LINE_ID)) map.removeLayer(LINE_ID);
        if (map.getLayer(FILL_ID)) map.removeLayer(FILL_ID);
        if (map.getLayer(MY_LINE_ID)) map.removeLayer(MY_LINE_ID);
        if (map.getLayer(MY_FILL_ID)) map.removeLayer(MY_FILL_ID);
        if (map.getSource(SRC_ID)) map.removeSource(SRC_ID);
      } catch {}
    };
  }, [map]);

  const doOpen = useCallback(() => {
    if (!selected) return;
    router.push(`/fires/${selected.fireId}/zones/${selected.id}`);
    setSelected(null);
  }, [router, selected]);

  const doJoin = useCallback(async () => {
    if (!selected) return;
    setJoining(true);
    try {
      const res = await fetch(`/api/fires/${selected.fireId}/zones/${selected.id}/join`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ action: "join" }),
      }).then((r) => r.json());
      if (!res?.ok) throw new Error(res?.error || "Грешка");
      // Optimistic update: recolor on map and update popup state
      optimisticMark("join", selected.id);
      setSelected((prev) => (prev ? { ...prev, isMember: true } : prev));
      onChange?.();
    } catch (e: any) {
      alert(e?.message || "Грешка");
    } finally {
      setJoining(false);
    }
  }, [selected, optimisticMark, onChange]);

  const doLeave = useCallback(async () => {
    if (!selected) return;
    setLeaving(true);
    try {
      const res = await fetch(`/api/fires/${selected.fireId}/zones/0/join`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ action: "leave" }),
      }).then((r) => r.json());
      if (!res?.ok) throw new Error(res?.error || "Грешка");
      // Optimistic update: remove highlight and update popup state
      optimisticMark("leave");
      setSelected((prev) => (prev ? { ...prev, isMember: false } : prev));
      onChange?.();
    } catch (e: any) {
      alert(e?.message || "Грешка");
    } finally {
      setLeaving(false);
    }
  }, [selected, optimisticMark, onChange]);

  return (
    <>
      {selected && (() => {
        const z = zones.find((x) => x.id === selected.id);
        const displayTitle = z?.title || selected.title || null;
        const zoneLabel = `Зона #${selected.id}`;
        const desc = z?.description || "Няма описание.";
        const members = z?.members ?? undefined;
        const isMember = selected.isMember ?? z?.isMember ?? false;
        const cover = z?.coverUrl || null;
        // For user's zone: no popup/buttons; click already navigates directly.
        if (isMember) return null;
        return (
          <Popup latitude={selected.lat} longitude={selected.lng} offset={12} closeOnMove={false}>
            <div className="min-w-[240px] max-w-[320px]">
              {cover && (
                // eslint-disable-next-line @next/next/no-img-element
                <img src={cover} alt={displayTitle || zoneLabel} className="w-full h-28 object-cover rounded-md border mb-2" />
              )}
              <div className="flex items-center justify-between gap-2 mb-1">
                <Badge variant="outline" className="shrink-0">{zoneLabel}</Badge>
                {typeof members === "number" && (
                  <Badge variant="secondary" className="shrink-0">
                    <Users className="h-3.5 w-3.5 mr-1" /> {members}
                  </Badge>
                )}
              </div>
              {displayTitle && (
                <div className="text-sm font-semibold leading-snug truncate pr-1 mb-1">{displayTitle}</div>
              )}
              {desc && (
                <div className="text-xs text-muted-foreground mb-3 line-clamp-3">{desc}</div>
              )}

              <div className="flex items-center gap-2">
                <Button size="sm" variant="outline" onClick={doJoin} disabled={joining} className="flex-1">
                  {joining ? "Присъединяване…" : "Влез"}
                </Button>
              </div>
            </div>
          </Popup>
        );
      })()}
    </>
  );
}
\n===== END FILE: components/zones/zone-shapes.tsx =====\n
===== FILE: drizzle/0000_greedy_wiccan.sql =====
CREATE TABLE "sessions" (
	"id" serial PRIMARY KEY NOT NULL,
	"user_id" integer NOT NULL,
	"session_token" text NOT NULL,
	"created_at" timestamp with time zone DEFAULT now() NOT NULL
);
--> statement-breakpoint
CREATE TABLE "users" (
	"id" serial PRIMARY KEY NOT NULL,
	"email" varchar(255) NOT NULL,
	"name" text,
	"created_at" timestamp with time zone DEFAULT now() NOT NULL,
	"updated_at" timestamp with time zone DEFAULT now() NOT NULL
);
--> statement-breakpoint
ALTER TABLE "sessions" ADD CONSTRAINT "sessions_user_id_users_id_fk" FOREIGN KEY ("user_id") REFERENCES "public"."users"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
CREATE UNIQUE INDEX "sessions_token_unique" ON "sessions" USING btree ("session_token");--> statement-breakpoint
CREATE INDEX "sessions_user_id_idx" ON "sessions" USING btree ("user_id");--> statement-breakpoint
CREATE UNIQUE INDEX "users_email_unique" ON "users" USING btree ("email");--> statement-breakpoint
CREATE INDEX "users_created_at_idx" ON "users" USING btree ("created_at");\n===== END FILE: drizzle/0000_greedy_wiccan.sql =====\n
===== FILE: drizzle/0003_fire_zones_and_chat.sql =====
-- ZONES
CREATE TABLE "zones" (
  "id" serial PRIMARY KEY NOT NULL,
  "fire_id" integer NOT NULL,
  "title" varchar(120),
  "description" text,
  "geom_type" varchar(10) NOT NULL,
  "center_lat" double precision,
  "center_lng" double precision,
  "radius_m" integer,
  "polygon" jsonb,
  "created_by" integer,
  "created_at" timestamp with time zone DEFAULT now() NOT NULL,
  "updated_at" timestamp with time zone DEFAULT now() NOT NULL
);
ALTER TABLE "zones" ADD CONSTRAINT "zones_fire_id_fires_id_fk"
  FOREIGN KEY ("fire_id") REFERENCES "public"."fires"("id")
  ON DELETE cascade ON UPDATE no action;
ALTER TABLE "zones" ADD CONSTRAINT "zones_created_by_users_id_fk"
  FOREIGN KEY ("created_by") REFERENCES "public"."users"("id")
  ON DELETE set null ON UPDATE no action;
CREATE INDEX "zones_fire_id_idx" ON "zones" USING btree ("fire_id");

CREATE TABLE "zone_members" (
  "id" serial PRIMARY KEY NOT NULL,
  "zone_id" integer NOT NULL,
  "fire_id" integer NOT NULL,
  "user_id" integer NOT NULL,
  "created_at" timestamp with time zone DEFAULT now() NOT NULL
);
ALTER TABLE "zone_members" ADD CONSTRAINT "zone_members_zone_id_zones_id_fk"
  FOREIGN KEY ("zone_id") REFERENCES "public"."zones"("id")
  ON DELETE cascade ON UPDATE no action;
ALTER TABLE "zone_members" ADD CONSTRAINT "zone_members_fire_id_fires_id_fk"
  FOREIGN KEY ("fire_id") REFERENCES "public"."fires"("id")
  ON DELETE cascade ON UPDATE no action;
ALTER TABLE "zone_members" ADD CONSTRAINT "zone_members_user_id_users_id_fk"
  FOREIGN KEY ("user_id") REFERENCES "public"."users"("id")
  ON DELETE cascade ON UPDATE no action;
CREATE UNIQUE INDEX "zone_members_fire_user_unique" ON "zone_members" USING btree ("fire_id","user_id");
CREATE INDEX "zone_members_zone_id_idx" ON "zone_members" USING btree ("zone_id");
CREATE INDEX "zone_members_fire_id_idx" ON "zone_members" USING btree ("fire_id");
CREATE INDEX "zone_members_user_id_idx" ON "zone_members" USING btree ("user_id");

CREATE TABLE "zone_gallery_images" (
  "id" serial PRIMARY KEY NOT NULL,
  "zone_id" integer NOT NULL,
  "user_id" integer NOT NULL,
  "s3_key" varchar(256) NOT NULL,
  "url" text NOT NULL,
  "width" integer,
  "height" integer,
  "created_at" timestamp with time zone DEFAULT now() NOT NULL
);
ALTER TABLE "zone_gallery_images" ADD CONSTRAINT "zone_gallery_images_zone_id_zones_id_fk"
  FOREIGN KEY ("zone_id") REFERENCES "public"."zones"("id")
  ON DELETE cascade ON UPDATE no action;
ALTER TABLE "zone_gallery_images" ADD CONSTRAINT "zone_gallery_images_user_id_users_id_fk"
  FOREIGN KEY ("user_id") REFERENCES "public"."users"("id")
  ON DELETE cascade ON UPDATE no action;
CREATE INDEX "zone_gallery_zone_idx" ON "zone_gallery_images" USING btree ("zone_id");

CREATE TABLE "zone_updates" (
  "id" serial PRIMARY KEY NOT NULL,
  "zone_id" integer NOT NULL,
  "user_id" integer NOT NULL,
  "text" text,
  "created_at" timestamp with time zone DEFAULT now() NOT NULL
);
ALTER TABLE "zone_updates" ADD CONSTRAINT "zone_updates_zone_id_zones_id_fk"
  FOREIGN KEY ("zone_id") REFERENCES "public"."zones"("id")
  ON DELETE cascade ON UPDATE no action;
ALTER TABLE "zone_updates" ADD CONSTRAINT "zone_updates_user_id_users_id_fk"
  FOREIGN KEY ("user_id") REFERENCES "public"."users"("id")
  ON DELETE cascade ON UPDATE no action;
CREATE INDEX "zone_updates_zone_idx" ON "zone_updates" USING btree ("zone_id");

CREATE TABLE "zone_update_images" (
  "id" serial PRIMARY KEY NOT NULL,
  "update_id" integer NOT NULL,
  "s3_key" varchar(256) NOT NULL,
  "url" text NOT NULL,
  "width" integer,
  "height" integer
);
ALTER TABLE "zone_update_images" ADD CONSTRAINT "zone_update_images_update_id_zone_updates_id_fk"
  FOREIGN KEY ("update_id") REFERENCES "public"."zone_updates"("id")
  ON DELETE cascade ON UPDATE no action;
CREATE INDEX "zone_update_images_update_idx" ON "zone_update_images" USING btree ("update_id");

-- CHATS
CREATE TABLE "chat_messages" (
  "id" serial PRIMARY KEY NOT NULL,
  "fire_id" integer NOT NULL,
  "zone_id" integer,
  "user_id" integer NOT NULL,
  "message" text NOT NULL DEFAULT '',
  "created_at" timestamp with time zone DEFAULT now() NOT NULL,
  "deleted_at" timestamp with time zone
);
ALTER TABLE "chat_messages" ADD CONSTRAINT "chat_messages_fire_id_fires_id_fk"
  FOREIGN KEY ("fire_id") REFERENCES "public"."fires"("id")
  ON DELETE cascade ON UPDATE no action;
ALTER TABLE "chat_messages" ADD CONSTRAINT "chat_messages_zone_id_zones_id_fk"
  FOREIGN KEY ("zone_id") REFERENCES "public"."zones"("id")
  ON DELETE cascade ON UPDATE no action;
ALTER TABLE "chat_messages" ADD CONSTRAINT "chat_messages_user_id_users_id_fk"
  FOREIGN KEY ("user_id") REFERENCES "public"."users"("id")
  ON DELETE cascade ON UPDATE no action;
CREATE INDEX "chat_fire_idx" ON "chat_messages" USING btree ("fire_id");
CREATE INDEX "chat_zone_idx" ON "chat_messages" USING btree ("zone_id");
CREATE INDEX "chat_created_idx" ON "chat_messages" USING btree ("created_at");

CREATE TABLE "chat_blocks" (
  "id" serial PRIMARY KEY NOT NULL,
  "fire_id" integer NOT NULL,
  "blocked_user_id" integer NOT NULL,
  "blocked_by_user_id" integer NOT NULL,
  "created_at" timestamp with time zone DEFAULT now() NOT NULL
);
ALTER TABLE "chat_blocks" ADD CONSTRAINT "chat_blocks_fire_id_fires_id_fk"
  FOREIGN KEY ("fire_id") REFERENCES "public"."fires"("id")
  ON DELETE cascade ON UPDATE no action;
ALTER TABLE "chat_blocks" ADD CONSTRAINT "chat_blocks_blocked_user_id_users_id_fk"
  FOREIGN KEY ("blocked_user_id") REFERENCES "public"."users"("id")
  ON DELETE cascade ON UPDATE no action;
ALTER TABLE "chat_blocks" ADD CONSTRAINT "chat_blocks_blocked_by_user_id_users_id_fk"
  FOREIGN KEY ("blocked_by_user_id") REFERENCES "public"."users"("id")
  ON DELETE cascade ON UPDATE no action;
CREATE UNIQUE INDEX "chat_blocks_fire_blocked_unique" ON "chat_blocks" USING btree ("fire_id","blocked_user_id");
CREATE INDEX "chat_blocks_fire_idx" ON "chat_blocks" USING btree ("fire_id");

-- QR uses
CREATE TABLE "fire_join_token_uses" (
  "id" serial PRIMARY KEY NOT NULL,
  "token_id" integer NOT NULL,
  "user_id" integer NOT NULL,
  "used_at" timestamp with time zone DEFAULT now() NOT NULL
);
ALTER TABLE "fire_join_token_uses" ADD CONSTRAINT "fire_join_token_uses_token_id_fire_join_tokens_id_fk"
  FOREIGN KEY ("token_id") REFERENCES "public"."fire_join_tokens"("id")
  ON DELETE cascade ON UPDATE no action;
ALTER TABLE "fire_join_token_uses" ADD CONSTRAINT "fire_join_token_uses_user_id_users_id_fk"
  FOREIGN KEY ("user_id") REFERENCES "public"."users"("id")
  ON DELETE cascade ON UPDATE no action;
CREATE INDEX "fire_join_token_uses_token_idx" ON "fire_join_token_uses" USING btree ("token_id");
CREATE INDEX "fire_join_token_uses_user_idx" ON "fire_join_token_uses" USING btree ("user_id");

\n===== END FILE: drizzle/0003_fire_zones_and_chat.sql =====\n
===== FILE: drizzle/0003_free_johnny_storm.sql =====
CREATE TABLE "chat_blocks" (
	"id" serial PRIMARY KEY NOT NULL,
	"fire_id" integer NOT NULL,
	"blocked_user_id" integer NOT NULL,
	"blocked_by_user_id" integer NOT NULL,
	"created_at" timestamp with time zone DEFAULT now() NOT NULL
);
--> statement-breakpoint
CREATE TABLE "chat_messages" (
	"id" serial PRIMARY KEY NOT NULL,
	"fire_id" integer NOT NULL,
	"zone_id" integer,
	"user_id" integer NOT NULL,
	"message" text DEFAULT '' NOT NULL,
	"created_at" timestamp with time zone DEFAULT now() NOT NULL,
	"deleted_at" timestamp with time zone
);
--> statement-breakpoint
CREATE TABLE "fire_deactivation_votes" (
	"id" serial PRIMARY KEY NOT NULL,
	"fire_id" integer NOT NULL,
	"user_id" integer NOT NULL,
	"created_at" timestamp with time zone DEFAULT now() NOT NULL
);
--> statement-breakpoint
CREATE TABLE "fire_join_token_uses" (
	"id" serial PRIMARY KEY NOT NULL,
	"token_id" integer NOT NULL,
	"user_id" integer NOT NULL,
	"used_at" timestamp with time zone DEFAULT now() NOT NULL
);
--> statement-breakpoint
CREATE TABLE "fire_join_tokens" (
	"id" serial PRIMARY KEY NOT NULL,
	"fire_id" integer NOT NULL,
	"token" varchar(128) NOT NULL,
	"created_by" integer NOT NULL,
	"created_at" timestamp with time zone DEFAULT now() NOT NULL,
	"expires_at" timestamp with time zone NOT NULL,
	"revoked_at" timestamp with time zone
);
--> statement-breakpoint
CREATE TABLE "fire_volunteers" (
	"id" serial PRIMARY KEY NOT NULL,
	"fire_id" integer NOT NULL,
	"user_id" integer NOT NULL,
	"status" varchar(16) DEFAULT 'requested' NOT NULL,
	"created_at" timestamp with time zone DEFAULT now() NOT NULL,
	"updated_at" timestamp with time zone DEFAULT now() NOT NULL
);
--> statement-breakpoint
CREATE TABLE "notification_deliveries" (
	"id" serial PRIMARY KEY NOT NULL,
	"subscription_id" integer NOT NULL,
	"event_key" varchar(256) NOT NULL,
	"delivered_at" timestamp with time zone DEFAULT now() NOT NULL,
	"meta" jsonb
);
--> statement-breakpoint
CREATE TABLE "notification_subscriptions" (
	"id" serial PRIMARY KEY NOT NULL,
	"email" varchar(255),
	"phone" varchar(32),
	"lat" double precision NOT NULL,
	"lng" double precision NOT NULL,
	"radius_km" integer DEFAULT 15 NOT NULL,
	"source_firms" integer DEFAULT 1 NOT NULL,
	"source_reports" integer DEFAULT 1 NOT NULL,
	"created_at" timestamp with time zone DEFAULT now() NOT NULL,
	"updated_at" timestamp with time zone DEFAULT now() NOT NULL
);
--> statement-breakpoint
CREATE TABLE "zone_gallery_images" (
	"id" serial PRIMARY KEY NOT NULL,
	"zone_id" integer NOT NULL,
	"user_id" integer NOT NULL,
	"s3_key" varchar(256) NOT NULL,
	"url" text NOT NULL,
	"width" integer,
	"height" integer,
	"created_at" timestamp with time zone DEFAULT now() NOT NULL
);
--> statement-breakpoint
CREATE TABLE "zone_members" (
	"id" serial PRIMARY KEY NOT NULL,
	"zone_id" integer NOT NULL,
	"fire_id" integer NOT NULL,
	"user_id" integer NOT NULL,
	"created_at" timestamp with time zone DEFAULT now() NOT NULL
);
--> statement-breakpoint
CREATE TABLE "zone_update_images" (
	"id" serial PRIMARY KEY NOT NULL,
	"update_id" integer NOT NULL,
	"s3_key" varchar(256) NOT NULL,
	"url" text NOT NULL,
	"width" integer,
	"height" integer
);
--> statement-breakpoint
CREATE TABLE "zone_updates" (
	"id" serial PRIMARY KEY NOT NULL,
	"zone_id" integer NOT NULL,
	"user_id" integer NOT NULL,
	"text" text,
	"created_at" timestamp with time zone DEFAULT now() NOT NULL
);
--> statement-breakpoint
CREATE TABLE "zones" (
	"id" serial PRIMARY KEY NOT NULL,
	"fire_id" integer NOT NULL,
	"title" varchar(120),
	"description" text,
	"geom_type" varchar(10) NOT NULL,
	"center_lat" double precision,
	"center_lng" double precision,
	"radius_m" integer,
	"polygon" jsonb,
	"created_by" integer,
	"created_at" timestamp with time zone DEFAULT now() NOT NULL,
	"updated_at" timestamp with time zone DEFAULT now() NOT NULL
);
--> statement-breakpoint
ALTER TABLE "fires" ADD COLUMN "last_activity_at" timestamp with time zone DEFAULT now() NOT NULL;--> statement-breakpoint
ALTER TABLE "fires" ADD COLUMN "deactivated_at" timestamp with time zone;--> statement-breakpoint
ALTER TABLE "chat_blocks" ADD CONSTRAINT "chat_blocks_fire_id_fires_id_fk" FOREIGN KEY ("fire_id") REFERENCES "public"."fires"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "chat_blocks" ADD CONSTRAINT "chat_blocks_blocked_user_id_users_id_fk" FOREIGN KEY ("blocked_user_id") REFERENCES "public"."users"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "chat_blocks" ADD CONSTRAINT "chat_blocks_blocked_by_user_id_users_id_fk" FOREIGN KEY ("blocked_by_user_id") REFERENCES "public"."users"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "chat_messages" ADD CONSTRAINT "chat_messages_fire_id_fires_id_fk" FOREIGN KEY ("fire_id") REFERENCES "public"."fires"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "chat_messages" ADD CONSTRAINT "chat_messages_zone_id_zones_id_fk" FOREIGN KEY ("zone_id") REFERENCES "public"."zones"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "chat_messages" ADD CONSTRAINT "chat_messages_user_id_users_id_fk" FOREIGN KEY ("user_id") REFERENCES "public"."users"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "fire_deactivation_votes" ADD CONSTRAINT "fire_deactivation_votes_fire_id_fires_id_fk" FOREIGN KEY ("fire_id") REFERENCES "public"."fires"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "fire_deactivation_votes" ADD CONSTRAINT "fire_deactivation_votes_user_id_users_id_fk" FOREIGN KEY ("user_id") REFERENCES "public"."users"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "fire_join_token_uses" ADD CONSTRAINT "fire_join_token_uses_token_id_fire_join_tokens_id_fk" FOREIGN KEY ("token_id") REFERENCES "public"."fire_join_tokens"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "fire_join_token_uses" ADD CONSTRAINT "fire_join_token_uses_user_id_users_id_fk" FOREIGN KEY ("user_id") REFERENCES "public"."users"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "fire_join_tokens" ADD CONSTRAINT "fire_join_tokens_fire_id_fires_id_fk" FOREIGN KEY ("fire_id") REFERENCES "public"."fires"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "fire_join_tokens" ADD CONSTRAINT "fire_join_tokens_created_by_users_id_fk" FOREIGN KEY ("created_by") REFERENCES "public"."users"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "fire_volunteers" ADD CONSTRAINT "fire_volunteers_fire_id_fires_id_fk" FOREIGN KEY ("fire_id") REFERENCES "public"."fires"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "fire_volunteers" ADD CONSTRAINT "fire_volunteers_user_id_users_id_fk" FOREIGN KEY ("user_id") REFERENCES "public"."users"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "notification_deliveries" ADD CONSTRAINT "notification_deliveries_subscription_id_notification_subscriptions_id_fk" FOREIGN KEY ("subscription_id") REFERENCES "public"."notification_subscriptions"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "zone_gallery_images" ADD CONSTRAINT "zone_gallery_images_zone_id_zones_id_fk" FOREIGN KEY ("zone_id") REFERENCES "public"."zones"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "zone_gallery_images" ADD CONSTRAINT "zone_gallery_images_user_id_users_id_fk" FOREIGN KEY ("user_id") REFERENCES "public"."users"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "zone_members" ADD CONSTRAINT "zone_members_zone_id_zones_id_fk" FOREIGN KEY ("zone_id") REFERENCES "public"."zones"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "zone_members" ADD CONSTRAINT "zone_members_fire_id_fires_id_fk" FOREIGN KEY ("fire_id") REFERENCES "public"."fires"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "zone_members" ADD CONSTRAINT "zone_members_user_id_users_id_fk" FOREIGN KEY ("user_id") REFERENCES "public"."users"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "zone_update_images" ADD CONSTRAINT "zone_update_images_update_id_zone_updates_id_fk" FOREIGN KEY ("update_id") REFERENCES "public"."zone_updates"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "zone_updates" ADD CONSTRAINT "zone_updates_zone_id_zones_id_fk" FOREIGN KEY ("zone_id") REFERENCES "public"."zones"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "zone_updates" ADD CONSTRAINT "zone_updates_user_id_users_id_fk" FOREIGN KEY ("user_id") REFERENCES "public"."users"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "zones" ADD CONSTRAINT "zones_fire_id_fires_id_fk" FOREIGN KEY ("fire_id") REFERENCES "public"."fires"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "zones" ADD CONSTRAINT "zones_created_by_users_id_fk" FOREIGN KEY ("created_by") REFERENCES "public"."users"("id") ON DELETE set null ON UPDATE no action;--> statement-breakpoint
CREATE UNIQUE INDEX "chat_blocks_fire_blocked_unique" ON "chat_blocks" USING btree ("fire_id","blocked_user_id");--> statement-breakpoint
CREATE INDEX "chat_blocks_fire_idx" ON "chat_blocks" USING btree ("fire_id");--> statement-breakpoint
CREATE INDEX "chat_fire_idx" ON "chat_messages" USING btree ("fire_id");--> statement-breakpoint
CREATE INDEX "chat_zone_idx" ON "chat_messages" USING btree ("zone_id");--> statement-breakpoint
CREATE INDEX "chat_created_idx" ON "chat_messages" USING btree ("created_at");--> statement-breakpoint
CREATE UNIQUE INDEX "fire_deactivation_votes_unique" ON "fire_deactivation_votes" USING btree ("fire_id","user_id");--> statement-breakpoint
CREATE INDEX "fire_deactivation_votes_fire_idx" ON "fire_deactivation_votes" USING btree ("fire_id");--> statement-breakpoint
CREATE INDEX "fire_deactivation_votes_user_idx" ON "fire_deactivation_votes" USING btree ("user_id");--> statement-breakpoint
CREATE INDEX "fire_join_token_uses_token_idx" ON "fire_join_token_uses" USING btree ("token_id");--> statement-breakpoint
CREATE INDEX "fire_join_token_uses_user_idx" ON "fire_join_token_uses" USING btree ("user_id");--> statement-breakpoint
CREATE UNIQUE INDEX "fire_join_tokens_token_unique" ON "fire_join_tokens" USING btree ("token");--> statement-breakpoint
CREATE INDEX "fire_join_tokens_fire_id_idx" ON "fire_join_tokens" USING btree ("fire_id");--> statement-breakpoint
CREATE UNIQUE INDEX "fire_volunteers_fire_user_unique" ON "fire_volunteers" USING btree ("fire_id","user_id");--> statement-breakpoint
CREATE INDEX "fire_volunteers_fire_id_idx" ON "fire_volunteers" USING btree ("fire_id");--> statement-breakpoint
CREATE INDEX "fire_volunteers_user_id_idx" ON "fire_volunteers" USING btree ("user_id");--> statement-breakpoint
CREATE UNIQUE INDEX "notif_delivery_sub_event_unique" ON "notification_deliveries" USING btree ("subscription_id","event_key");--> statement-breakpoint
CREATE INDEX "notif_delivery_sub_idx" ON "notification_deliveries" USING btree ("subscription_id");--> statement-breakpoint
CREATE INDEX "notif_sub_email_idx" ON "notification_subscriptions" USING btree ("email");--> statement-breakpoint
CREATE INDEX "notif_sub_phone_idx" ON "notification_subscriptions" USING btree ("phone");--> statement-breakpoint
CREATE INDEX "notif_sub_coord_idx" ON "notification_subscriptions" USING btree ("lat","lng");--> statement-breakpoint
CREATE INDEX "zone_gallery_zone_idx" ON "zone_gallery_images" USING btree ("zone_id");--> statement-breakpoint
CREATE UNIQUE INDEX "zone_members_fire_user_unique" ON "zone_members" USING btree ("fire_id","user_id");--> statement-breakpoint
CREATE INDEX "zone_members_zone_id_idx" ON "zone_members" USING btree ("zone_id");--> statement-breakpoint
CREATE INDEX "zone_members_fire_id_idx" ON "zone_members" USING btree ("fire_id");--> statement-breakpoint
CREATE INDEX "zone_members_user_id_idx" ON "zone_members" USING btree ("user_id");--> statement-breakpoint
CREATE INDEX "zone_update_images_update_idx" ON "zone_update_images" USING btree ("update_id");--> statement-breakpoint
CREATE INDEX "zone_updates_zone_idx" ON "zone_updates" USING btree ("zone_id");--> statement-breakpoint
CREATE INDEX "zones_fire_id_idx" ON "zones" USING btree ("fire_id");\n===== END FILE: drizzle/0003_free_johnny_storm.sql =====\n
===== FILE: hooks/useDebounce.ts =====
"use client";

import { useEffect, useState } from "react";

export function useDebounce<T>(value: T, delay = 300) {
  const [v, setV] = useState(value);
  useEffect(() => {
    const id = setTimeout(() => setV(value), delay);
    return () => clearTimeout(id);
  }, [value, delay]);
  return v;
}

\n===== END FILE: hooks/useDebounce.ts =====\n
===== FILE: hooks/useSendbirdUnread.ts =====
"use client";

import { useEffect, useRef, useState } from "react";
import SendbirdChat from "@sendbird/chat";
import { GroupChannelModule, GroupChannelHandler, type GroupChannel } from "@sendbird/chat/groupChannel";

type ConnectInfo = {
  ok: boolean;
  appId?: string;
  userId?: string;
  accessToken?: string | null;
  channelUrl?: string;
  error?: string;
};

export function useSendbirdUnread(fireId: number, chatOpen: boolean) {
  const sbRef = useRef<any>(null);
  const channelRef = useRef<GroupChannel | null>(null);
  const [count, setCount] = useState(0);
  const [ready, setReady] = useState(false);
  const handlerIdRef = useRef<string | null>(null);

  useEffect(() => {
    let cancelled = false;
    (async () => {
      try {
        const info: ConnectInfo = await fetch(`/api/fires/${fireId}/chat/connect`, { cache: "no-store" }).then((r) => r.json());
        if (cancelled || !info?.ok || !info.appId || !info.userId || !info.channelUrl) return;

        const sb = await SendbirdChat.init({ appId: info.appId, modules: [new GroupChannelModule()] });
        sbRef.current = sb;
        await sb.connect(info.userId, info.accessToken || undefined);
        const ch = await sb.groupChannel.getChannel(info.channelUrl);
        if (cancelled) return;
        channelRef.current = ch;
        setCount((ch as any).unreadMessageCount || 0);

        const handlerId = `fire-${fireId}-unread-${Math.random().toString(36).slice(2)}`;
        handlerIdRef.current = handlerId;
        const handler = new GroupChannelHandler({
          onMessageReceived: (channel) => {
            if (channel.url === ch.url) setCount((channel as any).unreadMessageCount || 0);
          },
          onUserMarkedRead: (channel) => {
            if (channel.url === ch.url) setCount((channel as any).unreadMessageCount || 0);
          },
          onUnreadMemberStatusUpdated: (channel) => {
            if (channel.url === ch.url) setCount((channel as any).unreadMessageCount || 0);
          },
          onChannelChanged: (channel) => {
            if (channel.url === ch.url) setCount((channel as any).unreadMessageCount || 0);
          },
        });
        sb.groupChannel.addGroupChannelHandler(handlerId, handler);
        setReady(true);
      } catch (_) {
        // ignore
      }
    })();
    return () => {
      cancelled = true;
      const sb = sbRef.current as any;
      if (sb && handlerIdRef.current) {
        try { sb.groupChannel.removeGroupChannelHandler(handlerIdRef.current); } catch {}
      }
      // Keep the connection; do not disconnect to avoid flicker with the chat UI instance
    };
  }, [fireId]);

  useEffect(() => {
    if (chatOpen && channelRef.current) {
      try { channelRef.current.markAsRead(); } catch {}
      setCount(0);
    }
  }, [chatOpen]);

  return { count, ready };
}
\n===== END FILE: hooks/useSendbirdUnread.ts =====\n
===== FILE: hooks/useSendbirdUnreadMany.ts =====
"use client";

import { useEffect, useRef, useState } from "react";
import SendbirdChat from "@sendbird/chat";
import { GroupChannelModule, GroupChannelHandler } from "@sendbird/chat/groupChannel";

type ConnectInfo = {
  ok: boolean;
  appId?: string;
  userId?: string;
  accessToken?: string | null;
  channelUrl?: string;
};

export function useSendbirdUnreadMany(connectUrls: string[], chatOpen: boolean, activeConnectUrl?: string | null) {
  const sbRef = useRef<any>(null);
  const credRef = useRef<{ appId: string; userId: string; accessToken?: string } | null>(null);
  const handlerIdsRef = useRef<string[]>([]);
  const channelsRef = useRef<any[]>([]);
  const [counts, setCounts] = useState<Record<string, number>>({}); // keyed by connectUrl
  const connectToChannelUrlRef = useRef<Record<string, string>>({});
  const channelToConnectUrlRef = useRef<Record<string, string>>({});

  useEffect(() => {
    let cancelled = false;
    (async () => {
      try {
        // Fetch connect info for all
        const infos: ConnectInfo[] = await Promise.all(
          connectUrls.map((u) => fetch(u, { cache: "no-store" }).then((r) => r.json()).catch(() => null))
        );
        const valid = infos.filter((x) => x && x.ok && x.appId && x.userId && x.channelUrl) as Required<ConnectInfo>[];
        if (cancelled || valid.length === 0) return;

        // Init SB once
        const appId = valid[0].appId!;
        const userId = valid[0].userId!;
        const accessToken = valid[0].accessToken || undefined;
        const sb = sbRef.current || await SendbirdChat.init({ appId, modules: [new GroupChannelModule()] });
        sbRef.current = sb;
        credRef.current = { appId, userId, accessToken };
        if (!sb.currentUser) {
          try { await sb.connect(userId, accessToken); } catch {}
        }

        // Load channels and set handlers
        // Map connectUrl <-> channelUrl
        const toCh: Record<string, string> = {};
        const toConn: Record<string, string> = {};
        for (let i = 0; i < valid.length; i++) {
          const connUrl = connectUrls[i];
          const chUrl = valid[i].channelUrl!;
          toCh[connUrl] = chUrl;
          toConn[chUrl] = connUrl;
        }
        connectToChannelUrlRef.current = toCh;
        channelToConnectUrlRef.current = toConn;

        channelsRef.current = await Promise.all(valid.map(v => sb.groupChannel.getChannel(v.channelUrl!)));
        const nextCounts: Record<string, number> = {};
        channelsRef.current.forEach((ch: any) => {
          const cu = channelToConnectUrlRef.current[ch.url];
          if (cu) nextCounts[cu] = ch.unreadMessageCount || 0;
        });
        if (!cancelled) setCounts(nextCounts);

        // Handlers
        handlerIdsRef.current.forEach((id) => { try { sb.groupChannel.removeGroupChannelHandler(id); } catch {} });
        handlerIdsRef.current = [];
        channelsRef.current.forEach((ch: any) => {
          const id = `unread-many-${ch.url}-${Math.random().toString(36).slice(2)}`;
          const handler = new GroupChannelHandler({
            onMessageReceived: (channel) => {
              if (channel.url === ch.url) {
                const key = channelToConnectUrlRef.current[channel.url];
                if (key) setCounts((c) => ({ ...c, [key]: (channel as any).unreadMessageCount || 0 }));
              }
            },
            onUserMarkedRead: (channel) => {
              if (channel.url === ch.url) {
                const key = channelToConnectUrlRef.current[channel.url];
                if (key) setCounts((c) => ({ ...c, [key]: (channel as any).unreadMessageCount || 0 }));
              }
            },
            onUnreadMemberStatusUpdated: (channel) => {
              if (channel.url === ch.url) {
                const key = channelToConnectUrlRef.current[channel.url];
                if (key) setCounts((c) => ({ ...c, [key]: (channel as any).unreadMessageCount || 0 }));
              }
            },
            onChannelChanged: (channel) => {
              if (channel.url === ch.url) {
                const key = channelToConnectUrlRef.current[channel.url];
                if (key) setCounts((c) => ({ ...c, [key]: (channel as any).unreadMessageCount || 0 }));
              }
            },
          });
          sb.groupChannel.addGroupChannelHandler(id, handler);
          handlerIdsRef.current.push(id);
        });
      } catch {}
    })();
    return () => {
      cancelled = true;
      const sb = sbRef.current;
      if (sb && handlerIdsRef.current.length) {
        handlerIdsRef.current.forEach((id) => { try { sb.groupChannel.removeGroupChannelHandler(id); } catch {} });
      }
    };
  }, [JSON.stringify(connectUrls)]);

  // Mark only the active channel as read when chat opens or active tab changes
  useEffect(() => {
    if (!chatOpen) return;
    if (!activeConnectUrl) return;
    const run = async () => {
      const sb = sbRef.current;
      if (!sb) return;
      // ensure connection
      if (!sb.currentUser && credRef.current) {
        try { await sb.connect(credRef.current.userId, credRef.current.accessToken); } catch {}
      }
      const chUrl = connectToChannelUrlRef.current[activeConnectUrl];
      if (!chUrl) return;
      const ch = channelsRef.current.find((c: any) => c.url === chUrl);
      if (!ch) return;
      try { await ch.markAsRead(); } catch {}
      setCounts((c) => ({ ...c, [activeConnectUrl]: 0 }));
    };
    run();
  }, [chatOpen, activeConnectUrl]);

  const total = Object.values(counts).reduce((a, b) => a + (b || 0), 0);
  return { counts, total };
}
\n===== END FILE: hooks/useSendbirdUnreadMany.ts =====\n
===== FILE: lib/db/schema.ts =====
import {
  pgTable,
  serial,
  text,
  varchar,
  timestamp,
  integer,
  index,
  uniqueIndex,
  doublePrecision,
} from 'drizzle-orm/pg-core';
import { relations } from 'drizzle-orm';
import { jsonb } from 'drizzle-orm/pg-core';

// ---------- NOTIFICATIONS (Subscriptions & Deliveries) ----------
export const notificationSubscriptions = pgTable(
  'notification_subscriptions',
  {
    id: serial('id').primaryKey(),
    email: varchar('email', { length: 255 }),
    phone: varchar('phone', { length: 32 }),
    lat: doublePrecision('lat').notNull(),
    lng: doublePrecision('lng').notNull(),
    radiusKm: integer('radius_km').notNull().default(15),
    sourceFirms: integer('source_firms').notNull().default(1), // 1=true, 0=false (bool-like)
    sourceReports: integer('source_reports').notNull().default(1),
    createdAt: timestamp('created_at', { withTimezone: true }).defaultNow().notNull(),
    updatedAt: timestamp('updated_at', { withTimezone: true }).defaultNow().notNull(),
  },
  (t) => ({
    emailIdx: index('notif_sub_email_idx').on(t.email),
    phoneIdx: index('notif_sub_phone_idx').on(t.phone),
    coordIdx: index('notif_sub_coord_idx').on(t.lat, t.lng),
  })
);

export const notificationDeliveries = pgTable(
  'notification_deliveries',
  {
    id: serial('id').primaryKey(),
    subscriptionId: integer('subscription_id').notNull().references(() => notificationSubscriptions.id, { onDelete: 'cascade' }),
    eventKey: varchar('event_key', { length: 256 }).notNull(),
    deliveredAt: timestamp('delivered_at', { withTimezone: true }).defaultNow().notNull(),
    meta: jsonb('meta'),
  },
  (t) => ({
    uniqueDelivery: uniqueIndex('notif_delivery_sub_event_unique').on(t.subscriptionId, t.eventKey),
    subIdx: index('notif_delivery_sub_idx').on(t.subscriptionId),
  })
);

export const users = pgTable(
  'users',
  {
    id: serial('id').primaryKey(),
    email: varchar('email', { length: 255 }).notNull(),
    name: text('name'),
    createdAt: timestamp('created_at', { withTimezone: true })
      .defaultNow()
      .notNull(),
    updatedAt: timestamp('updated_at', { withTimezone: true })
      .defaultNow()
      .notNull(),
  },
  (t) => ({
    emailUnique: uniqueIndex('users_email_unique').on(t.email),
    createdAtIdx: index('users_created_at_idx').on(t.createdAt),
  }),
);

export const sessions = pgTable(
  'sessions',
  {
    id: serial('id').primaryKey(),
    userId: integer('user_id')
      .notNull()
      .references(() => users.id, { onDelete: 'cascade' }),
    sessionToken: text('session_token').notNull(),
    createdAt: timestamp('created_at', { withTimezone: true })
      .defaultNow()
      .notNull(),
  },
  (t) => ({
    tokenUnique: uniqueIndex('sessions_token_unique').on(t.sessionToken),
    userIdIdx: index('sessions_user_id_idx').on(t.userId),
  }),
);

export const usersRelations = relations(users, ({ many }) => ({
  sessions: many(sessions),
  fires: many(fires), // свързваме fires->users по-долу
}));

export const sessionsRelations = relations(sessions, ({ one }) => ({
  user: one(users, {
    fields: [sessions.userId],
    references: [users.id],
  }),
}));

// ---------- NEW: Fires ----------
export const fires = pgTable(
  'fires',
  {
    id: serial('id').primaryKey(),
    lat: doublePrecision('lat').notNull(),
    lng: doublePrecision('lng').notNull(),
    radiusM: integer('radius_m').notNull(),
    status: varchar('status', { length: 16 }).notNull().default('active'),
    createdBy: integer('created_by').references(() => users.id, { onDelete: 'set null' }),
    createdAt: timestamp('created_at', { withTimezone: true }).defaultNow().notNull(),
    updatedAt: timestamp('updated_at', { withTimezone: true }).defaultNow().notNull(),
    lastActivityAt: timestamp('last_activity_at', { withTimezone: true }).defaultNow().notNull(),
    deactivatedAt: timestamp('deactivated_at', { withTimezone: true }),
  },
  (t) => ({
    createdAtIdx: index('fires_created_at_idx').on(t.createdAt),
    coordsIdx: index('fires_coords_idx').on(t.lat, t.lng),
  })
);

export const firesRelations = relations(fires, ({ one }) => ({
  creator: one(users, {
    fields: [fires.createdBy],
    references: [users.id],
  }),
}));

export type Fire = {
  id: number;
  lat: number;
  lng: number;
  radiusM: number;
  status: string;
  createdBy: number | null;
  createdAt: Date;
  updatedAt: Date;
  lastActivityAt: Date;
  deactivatedAt: Date | null;
};

// ---------- NEW: Volunteers ----------
export const fireVolunteers = pgTable(
  'fire_volunteers',
  {
    id: serial('id').primaryKey(),
    fireId: integer('fire_id').notNull().references(() => fires.id, { onDelete: 'cascade' }),
    userId: integer('user_id').notNull().references(() => users.id, { onDelete: 'cascade' }),
    status: varchar('status', { length: 16 }).notNull().$type<'requested' | 'confirmed'>().default('requested'),
    createdAt: timestamp('created_at', { withTimezone: true }).defaultNow().notNull(),
    updatedAt: timestamp('updated_at', { withTimezone: true }).defaultNow().notNull(),
  },
  (t) => ({
    uniqueFireUser: uniqueIndex('fire_volunteers_fire_user_unique').on(t.fireId, t.userId),
    fireIdIdx: index('fire_volunteers_fire_id_idx').on(t.fireId),
    userIdIdx: index('fire_volunteers_user_id_idx').on(t.userId),
  })
);

export const fireVolunteersRelations = relations(fireVolunteers, ({ one }) => ({
  fire: one(fires, { fields: [fireVolunteers.fireId], references: [fires.id] }),
  user: one(users, { fields: [fireVolunteers.userId], references: [users.id] }),
}));

export const fireJoinTokens = pgTable(
  'fire_join_tokens',
  {
    id: serial('id').primaryKey(),
    fireId: integer('fire_id').notNull().references(() => fires.id, { onDelete: 'cascade' }),
    token: varchar('token', { length: 128 }).notNull(),
    createdBy: integer('created_by').notNull().references(() => users.id, { onDelete: 'cascade' }),
    createdAt: timestamp('created_at', { withTimezone: true }).defaultNow().notNull(),
    expiresAt: timestamp('expires_at', { withTimezone: true }).notNull(),
    revokedAt: timestamp('revoked_at', { withTimezone: true }),
  },
  (t) => ({
    tokenUnique: uniqueIndex('fire_join_tokens_token_unique').on(t.token),
    fireIdIdx: index('fire_join_tokens_fire_id_idx').on(t.fireId),
  })
);

export type FireVolunteer = {
  id: number;
  fireId: number;
  userId: number;
  status: 'requested' | 'confirmed';
  createdAt: Date;
  updatedAt: Date;
};

export type FireJoinToken = {
  id: number;
  fireId: number;
  token: string;
  createdBy: number;
  createdAt: Date;
  expiresAt: Date;
  revokedAt: Date | null;
};

// ---------- ZONES ----------
export const zones = pgTable(
  'zones',
  {
    id: serial('id').primaryKey(),
    fireId: integer('fire_id').notNull().references(() => fires.id, { onDelete: 'cascade' }),
    title: varchar('title', { length: 120 }),
    description: text('description'),
    geomType: varchar('geom_type', { length: 10 }).notNull(), // 'circle' | 'polygon'
    centerLat: doublePrecision('center_lat'),
    centerLng: doublePrecision('center_lng'),
    radiusM: integer('radius_m'),
    polygon: jsonb('polygon'),
    createdBy: integer('created_by').references(() => users.id, { onDelete: 'set null' }),
    createdAt: timestamp('created_at', { withTimezone: true }).defaultNow().notNull(),
    updatedAt: timestamp('updated_at', { withTimezone: true }).defaultNow().notNull(),
  },
  (t) => ({
    fireIdx: index('zones_fire_id_idx').on(t.fireId),
  })
);

export const zoneMembers = pgTable(
  'zone_members',
  {
    id: serial('id').primaryKey(),
    zoneId: integer('zone_id').notNull().references(() => zones.id, { onDelete: 'cascade' }),
    fireId: integer('fire_id').notNull().references(() => fires.id, { onDelete: 'cascade' }),
    userId: integer('user_id').notNull().references(() => users.id, { onDelete: 'cascade' }),
    createdAt: timestamp('created_at', { withTimezone: true }).defaultNow().notNull(),
  },
  (t) => ({
    oneZonePerFirePerUser: uniqueIndex('zone_members_fire_user_unique').on(t.fireId, t.userId),
    zoneIdx: index('zone_members_zone_id_idx').on(t.zoneId),
    fireIdx: index('zone_members_fire_id_idx').on(t.fireId),
    userIdx: index('zone_members_user_id_idx').on(t.userId),
  })
);

export const zoneGalleryImages = pgTable(
  'zone_gallery_images',
  {
    id: serial('id').primaryKey(),
    zoneId: integer('zone_id').notNull().references(() => zones.id, { onDelete: 'cascade' }),
    userId: integer('user_id').notNull().references(() => users.id, { onDelete: 'cascade' }),
    s3Key: varchar('s3_key', { length: 256 }).notNull(),
    url: text('url').notNull(),
    width: integer('width'),
    height: integer('height'),
    createdAt: timestamp('created_at', { withTimezone: true }).defaultNow().notNull(),
  },
  (t) => ({
    zoneIdx: index('zone_gallery_zone_idx').on(t.zoneId),
  })
);

export const zoneUpdates = pgTable(
  'zone_updates',
  {
    id: serial('id').primaryKey(),
    zoneId: integer('zone_id').notNull().references(() => zones.id, { onDelete: 'cascade' }),
    userId: integer('user_id').notNull().references(() => users.id, { onDelete: 'cascade' }),
    text: text('text'),
    createdAt: timestamp('created_at', { withTimezone: true }).defaultNow().notNull(),
  },
  (t) => ({
    zoneIdx: index('zone_updates_zone_idx').on(t.zoneId),
  })
);

export const zoneUpdateImages = pgTable(
  'zone_update_images',
  {
    id: serial('id').primaryKey(),
    updateId: integer('update_id').notNull().references(() => zoneUpdates.id, { onDelete: 'cascade' }),
    s3Key: varchar('s3_key', { length: 256 }).notNull(),
    url: text('url').notNull(),
    width: integer('width'),
    height: integer('height'),
  },
  (t) => ({
    updIdx: index('zone_update_images_update_idx').on(t.updateId),
  })
);

// ---------- CHATS ----------
export const chatMessages = pgTable(
  'chat_messages',
  {
    id: serial('id').primaryKey(),
    fireId: integer('fire_id').notNull().references(() => fires.id, { onDelete: 'cascade' }),
    zoneId: integer('zone_id').references(() => zones.id, { onDelete: 'cascade' }),
    userId: integer('user_id').notNull().references(() => users.id, { onDelete: 'cascade' }),
    message: text('message').notNull().default(''),
    createdAt: timestamp('created_at', { withTimezone: true }).defaultNow().notNull(),
    deletedAt: timestamp('deleted_at', { withTimezone: true }),
  },
  (t) => ({
    fireIdx: index('chat_fire_idx').on(t.fireId),
    zoneIdx: index('chat_zone_idx').on(t.zoneId),
    createdIdx: index('chat_created_idx').on(t.createdAt),
  })
);

export const chatBlocks = pgTable(
  'chat_blocks',
  {
    id: serial('id').primaryKey(),
    fireId: integer('fire_id').notNull().references(() => fires.id, { onDelete: 'cascade' }),
    blockedUserId: integer('blocked_user_id').notNull().references(() => users.id, { onDelete: 'cascade' }),
    blockedByUserId: integer('blocked_by_user_id').notNull().references(() => users.id, { onDelete: 'cascade' }),
    createdAt: timestamp('created_at', { withTimezone: true }).defaultNow().notNull(),
  },
  (t) => ({
    uniqueBlock: uniqueIndex('chat_blocks_fire_blocked_unique').on(t.fireId, t.blockedUserId),
    fireIdx: index('chat_blocks_fire_idx').on(t.fireId),
  })
);

// ---------- QR token uses ----------
export const fireJoinTokenUses = pgTable(
  'fire_join_token_uses',
  {
    id: serial('id').primaryKey(),
    tokenId: integer('token_id').notNull().references(() => fireJoinTokens.id, { onDelete: 'cascade' }),
    userId: integer('user_id').notNull().references(() => users.id, { onDelete: 'cascade' }),
    usedAt: timestamp('used_at', { withTimezone: true }).defaultNow().notNull(),
  },
  (t) => ({
    tokenIdx: index('fire_join_token_uses_token_idx').on(t.tokenId),
    userIdx: index('fire_join_token_uses_user_idx').on(t.userId),
  })
);

// ---------- Fire Deactivation Votes ----------
export const fireDeactivationVotes = pgTable(
  'fire_deactivation_votes',
  {
    id: serial('id').primaryKey(),
    fireId: integer('fire_id').notNull().references(() => fires.id, { onDelete: 'cascade' }),
    userId: integer('user_id').notNull().references(() => users.id, { onDelete: 'cascade' }),
    createdAt: timestamp('created_at', { withTimezone: true }).defaultNow().notNull(),
  },
  (t) => ({
    uniqueVote: uniqueIndex('fire_deactivation_votes_unique').on(t.fireId, t.userId),
    fireIdx: index('fire_deactivation_votes_fire_idx').on(t.fireId),
    userIdx: index('fire_deactivation_votes_user_idx').on(t.userId),
  })
);
\n===== END FILE: lib/db/schema.ts =====\n
===== FILE: lib/mapbox/provider.tsx =====
"use client";

import React, { useEffect, useRef, useState, useMemo } from "react";
import mapboxgl from "mapbox-gl";
import "mapbox-gl/dist/mapbox-gl.css";
import { MapContext } from "@/context/map-context";

const ACCESS_TOKEN = process.env.NEXT_PUBLIC_MAPBOX_TOKEN;

type MapProviderProps = {
  mapContainerRef: React.RefObject<HTMLDivElement | null>;
  initialViewState: {
    longitude: number;
    latitude: number;
    zoom: number;
  };
  styleUrl?: string;
  /** NEW: извиква се при `map.on("load")` */
  onMapLoad?: (map: mapboxgl.Map) => void;
  children?: React.ReactNode;
};

export default function MapProvider({
  mapContainerRef,
  initialViewState,
  styleUrl = "mapbox://styles/mapbox/streets-v12",
  onMapLoad,
  children,
}: MapProviderProps) {
  const mapRef = useRef<mapboxgl.Map | null>(null);
  const [ctxMap, setCtxMap] = useState<mapboxgl.Map | null>(null);
  const [loaded, setLoaded] = useState(false);
  const [error, setError] = useState<string | null>(null);
  // track load state in a ref for event handlers
  const loadedRef = useRef(false);
  // keep a stable ref to the callback to avoid re-creating the map
  const onLoadCbRef = useRef<MapProviderProps["onMapLoad"] | undefined>(undefined);
  useEffect(() => {
    onLoadCbRef.current = onMapLoad;
  }, [onMapLoad]);

  useEffect(() => {
    let cancelled = false;

    (async () => {
      try {
        if (mapRef.current || !mapContainerRef.current) return;

        if (!ACCESS_TOKEN) {
          setError("Липсва NEXT_PUBLIC_MAPBOX_TOKEN в .env.local");
          return;
        }
        if (ACCESS_TOKEN.startsWith("sk.")) {
          setError("Клиентът изисква публичен pk.* токен, не sk.*");
          return;
        }

        mapboxgl.accessToken = ACCESS_TOKEN;

        const map = new mapboxgl.Map({
          container: mapContainerRef.current,
          style: styleUrl,
          center: [initialViewState.longitude, initialViewState.latitude],
          zoom: initialViewState.zoom,
          attributionControl: false,
          logoPosition: "bottom-right",
        });

        mapRef.current = map;
        setCtxMap(map);

        const onError = (e: any) => {
          const msg =
            typeof e?.error?.message === "string"
              ? e.error.message
              : typeof e?.message === "string"
              ? e.message
              : null;
          const isBenign = typeof msg === "string" && /layer .* does not exist|source .* does not exist|cannot query|style( is)? not (done )?loading/i.test(msg);
          // After map is loaded, treat errors as non-fatal warnings to avoid noisy overlays
          if (loadedRef.current || isBenign) {
            console.warn("Mapbox warning:", msg || e);
            return;
          }
          console.error("Mapbox error:", msg || e);
          setError(msg || "Неуспешно зареждане на карта. Виж конзолата.");
        };

        map.on("error", onError);
        map.on("load", () => {
          if (cancelled) return;
          setLoaded(true);
          loadedRef.current = true;
          try {
            map.resize();
          } catch {}
          try {
            onLoadCbRef.current?.(map);
          } catch (e) {
            console.error(e);
          }
        });
      } catch (err: any) {
        console.error(err);
        setError(err?.message || "Грешка при инициализация на картата.");
      }
    })();

    return () => {
      cancelled = true;
      if (mapRef.current) {
        try {
          mapRef.current.remove();
        } catch {}
        mapRef.current = null;
        setCtxMap(null);
      }
      loadedRef.current = false;
    };
  }, [
    mapContainerRef,
    initialViewState.longitude,
    initialViewState.latitude,
    initialViewState.zoom,
    styleUrl,
  ]);

  // стабилизирана стойност за контекста (не създаваме нов обект на всеки ререндер)
  const contextValue = useMemo(() => ({ map: ctxMap }), [ctxMap]);

  return (
    <>
      <MapContext.Provider value={contextValue}>{children}</MapContext.Provider>

      {!loaded && !error && (
        <div className="absolute inset-0 flex items-center justify-center bg-background/60 z-[1000]">
          <div className="text-sm">Зареждане на карта…</div>
        </div>
      )}

      {error && (
        <div className="absolute inset-0 flex items-center justify-center bg-background/80 p-4 z-[1000]">
          <div className="max-w-md text-center text-sm text-destructive">{error}</div>
        </div>
      )}
    </>
  );
}
\n===== END FILE: lib/mapbox/provider.tsx =====\n
===== FILE: lib/notifications/job.ts =====
import { db } from "@/lib/db";
import { fires, notificationDeliveries, notificationSubscriptions } from "@/lib/db/schema";
import { and, eq, gte, lte } from "drizzle-orm";
import { haversineMeters } from "@/lib/geo";
import { buildReportEmail, buildReportSms, sendEmail, sendSms } from "@/lib/notify";

const DEFAULT_BASE_URL = process.env.APP_BASE_URL || 'https://firelinks.org';

function degRadius(lat: number, radiusM: number) {
  const latDeg = radiusM / 111_320;
  const lngDeg = radiusM / (111_320 * Math.max(0.2, Math.cos((lat * Math.PI) / 180)));
  return { latDeg, lngDeg };
}

async function fetchFirms(bbox: [number, number, number, number], baseUrl = DEFAULT_BASE_URL) {
  const [w, s, e, n] = bbox;
  const url = `${baseUrl}/api/firms?bbox=${w},${s},${e},${n}&days=1&minConfidence=35&dedupRadiusM=600&clusterRadiusM=650`;
  const res = await fetch(url, { cache: 'no-store' });
  if (!res.ok) {
    const txt = await res.text().catch(() => '');
    throw new Error(`FIRMS fetch ${res.status} ${res.statusText} ${txt?.slice(0,180)}`);
  }
  const data = await res.json();
  return Array.isArray(data?.hotspots) ? data.hotspots : [];
}

async function alreadyDelivered(subscriptionId: number, eventKey: string) {
  const rows = await db
    .select({ id: notificationDeliveries.id })
    .from(notificationDeliveries)
    .where(and(
      eq(notificationDeliveries.subscriptionId, subscriptionId),
      eq(notificationDeliveries.eventKey, eventKey)
    ))
    .limit(1);
  return rows.length > 0;
}

async function recordDelivery(subscriptionId: number, eventKey: string, meta: any) {
  try {
    await db.insert(notificationDeliveries).values({ subscriptionId, eventKey, meta });
  } catch {
    // unique violation is fine
  }
}

function sleep(ms: number) { return new Promise((r) => setTimeout(r, ms)); }

export async function runNotificationsJob({
  onlySubscriptionId,
  limitPerSource = 3,
  baseUrl = DEFAULT_BASE_URL,
}: {
  onlySubscriptionId?: number,
  limitPerSource?: number,
  baseUrl?: string,
}) {
  const subs = await (async () => {
    if (Number.isFinite(onlySubscriptionId as number)) {
      const [s] = await db.select().from(notificationSubscriptions).where(eq(notificationSubscriptions.id, Number(onlySubscriptionId))).limit(1);
      return s ? [s] : [];
    }
    return await db.select().from(notificationSubscriptions);
  })();

  let totalCandidates = 0;
  let totalDelivered = 0;

  for (const sub of subs) {
    const radiusM = Math.max(200, Math.min(120_000, (sub.radiusKm || 15) * 1000));
    const { latDeg, lngDeg } = degRadius(sub.lat, radiusM);
    const bbox: [number, number, number, number] = [
      sub.lng - lngDeg,
      sub.lat - latDeg,
      sub.lng + lngDeg,
      sub.lat + latDeg,
    ];

    // Reports (confirmed)
    if ((sub.sourceReports ?? 1) === 1) {
      const rows = await db
        .select()
        .from(fires)
        .where(and(
          gte(fires.lat, bbox[1]),
          lte(fires.lat, bbox[3]),
          gte(fires.lng, bbox[0]),
          lte(fires.lng, bbox[2]),
          eq(fires.status, 'active')
        ));
      let sent = 0;
      for (const f of rows) {
        const d = haversineMeters({ lat: sub.lat, lng: sub.lng }, { lat: f.lat, lng: f.lng });
        if (d > radiusM) continue;
        const eventKey = `report:${f.id}`;
        totalCandidates++;
        if (await alreadyDelivered(sub.id, eventKey)) continue;

        const { subject, html, text } = buildReportEmail({ lat: f.lat, lng: f.lng, radiusM: f.radiusM, fireId: f.id, baseUrl });
        const smsMsg = buildReportSms({ lat: f.lat, lng: f.lng, fireId: f.id, baseUrl });

        let delivered = false;
        if (sub.email) {
          const r = await sendEmail(sub.email, subject, html, text);
          delivered = delivered || r.ok;
        }
        if (sub.phone) {
          const r = await sendSms(sub.phone, smsMsg);
          delivered = delivered || r.ok;
          await sleep(500);
        }
        if (delivered) {
          await recordDelivery(sub.id, eventKey, { source: 'report', fireId: f.id, lat: f.lat, lng: f.lng });
          totalDelivered++;
          sent++;
          if (sent >= limitPerSource) break;
        }
      }
    }

    // FIRMS (unconfirmed)
    if ((sub.sourceFirms ?? 1) === 1) {
      let sent = 0;
      try {
        const hotspots = await fetchFirms(bbox, baseUrl);
        for (const h of hotspots) {
          const d = haversineMeters({ lat: sub.lat, lng: sub.lng }, { lat: h.lat, lng: h.lng });
          if (d > radiusM) continue;
          // Stable dedupe key for FIRMS: quantized cell (no time bucket)
          const qLat = Math.round(h.lat * 50) / 50; // ~0.02° ≈ 2.2 km
          const qLng = Math.round(h.lng * 50) / 50;
          const ts = h.acquiredAt ? Date.parse(h.acquiredAt) : NaN;
          const bucket6h = Number.isFinite(ts) ? Math.floor(ts / (6 * 3600 * 1000)) : undefined;
          // Previously we used a 6h time bucket which could resend
          // multiple notifications for the same location across runs.
          // Now we drop the time bucket so each location notifies once.
          const eventKey = `firms:${qLat.toFixed(2)},${qLng.toFixed(2)}`;
          totalCandidates++;
          if (await alreadyDelivered(sub.id, eventKey)) continue;

          const { subject, html, text } = buildReportEmail({ lat: h.lat, lng: h.lng, radiusM: h.radiusM, baseUrl });
          const smsMsg = buildReportSms({ lat: h.lat, lng: h.lng, baseUrl });

          let delivered = false;
          if (sub.email) {
            const r = await sendEmail(sub.email, subject, html, text);
            delivered = delivered || r.ok;
          }
          if (sub.phone) {
            const r = await sendSms(sub.phone, smsMsg);
            delivered = delivered || r.ok;
            await sleep(500);
          }
          if (delivered) {
            await recordDelivery(sub.id, eventKey, { source: 'firms', lat: h.lat, lng: h.lng });
            totalDelivered++;
            sent++;
            if (sent >= limitPerSource) break;
          }
        }
      } catch (e) {
        console.warn('[notifications job] FIRMS fetch failed', (e as any)?.message);
      }
    }
  }

  return { ok: true, totalSubscriptions: subs.length, totalCandidates, totalDelivered };
}
\n===== END FILE: lib/notifications/job.ts =====\n
===== FILE: lib/notify.ts =====
import { NextResponse } from 'next/server';

function env(name: string, fallback?: string) {
  const v = process.env[name];
  return v && v.length ? v : fallback;
}

// Email via Resend
const RESEND_API_KEY = env('RESEND_API_KEY', '');
const RESEND_FROM = env('NOTIFY_EMAIL_FROM', 'alerts@firelinks.org');

// SMS via QuadraMM
const QUADRA_BASE = env('QUADRA_SMS_GATEWAY_URL', 'http://gate.quadra-mm.com/feed/http.asp');
const QUADRA_USER = env('QUADRA_SMS_USER', 'archtag');
const QUADRA_PASS = env('QUADRA_SMS_PASS', 'Archtag@2024');
const QUADRA_ROUTE = env('QUADRA_SMS_ROUTE', 'eu');

export type DeliveryResult = { ok: boolean; id?: string; error?: string };

export function normalizeBgPhone(input: string): string | null {
  const raw = (input || '').replace(/\s+|\(|\)|-/g, '');
  if (!raw) return null;
  let n = raw.replace(/^\+/, '');
  if (n.startsWith('00')) n = n.slice(2);
  // If starts with 0 and has 9 or 10 digits, strip 0 and prefix 359
  if (n.startsWith('0')) {
    n = '359' + n.slice(1);
  }
  // If starts with 359 already, keep
  if (/^359\d{9}$/.test(n)) return n;
  // If looks like mobile without country code (e.g., 88xxxxxxxx)
  if (/^8\d{8}$/.test(n)) return '359' + n;
  return null;
}

export async function sendEmail(to: string, subject: string, html: string, text?: string): Promise<DeliveryResult> {
  try {
    if (!RESEND_API_KEY) return { ok: false, error: 'Missing RESEND_API_KEY' };
    const res = await fetch('https://api.resend.com/emails', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${RESEND_API_KEY}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        from: RESEND_FROM,
        to: [to],
        subject,
        html,
        text,
      }),
    });
    const data = await res.json().catch(() => ({}));
    if (!res.ok) {
      return { ok: false, error: data?.message || res.statusText };
    }
    return { ok: true, id: data?.id };
  } catch (e: any) {
    return { ok: false, error: e?.message || 'Email send failed' };
  }
}

export async function sendSms(phone: string, message: string): Promise<DeliveryResult> {
  try {
    const normalized = normalizeBgPhone(phone);
    if (!normalized) return { ok: false, error: 'Invalid phone format' };
    const params = new URLSearchParams({
      user: QUADRA_USER || '',
      pass: QUADRA_PASS || '',
      route: QUADRA_ROUTE || '',
      number: normalized,
      message: message,
    });
    // Quadra requires URL-encoded; URLSearchParams encodes with + for spaces
    const url = `${QUADRA_BASE}?${params.toString()}`;
    const res = await fetch(url, { method: 'GET' });
    const text = await res.text();
    if (text.startsWith('OK')) {
      const id = text.split(/\s+/)[1] || undefined;
      return { ok: true, id };
    }
    return { ok: false, error: text };
  } catch (e: any) {
    return { ok: false, error: e?.message || 'SMS send failed' };
  }
}

export function buildReportEmail({
  lat, lng, radiusM, fireId, baseUrl,
}: { lat: number; lng: number; radiusM?: number; fireId?: number; baseUrl: string }) {
  const link = fireId ? `${baseUrl}/fires/${fireId}` : `https://www.google.com/maps?q=${lat},${lng}`;
  const source = fireId ? 'Докладван пожар (потвърден източник)' : 'FIRMS (непотвърден източник)';
  const subject = fireId ? 'Докладван пожар близо до вас' : 'Потенциален пожар (FIRMS) близо до вас';
  const html = `
    <div style="font-family: Arial, sans-serif; line-height:1.5;">
      <p>Източник: <strong>${source}</strong></p>
      <p>Локация: <a href="${link}">${lat.toFixed(4)}, ${lng.toFixed(4)}</a></p>
      ${radiusM ? `<p>Приблизителен радиус: ${Math.round(radiusM)} м</p>` : ''}
      ${fireId ? `<p>Виж детайли: <a href="${link}">${link}</a></p>` : `<p>Карта: <a href="${link}">${link}</a></p>`}
      <hr />
      <p>firelinks.org — обществен мониторинг на пожари</p>
    </div>
  `;
  const text = `Източник: ${source}\nЛокация: ${lat.toFixed(4)}, ${lng.toFixed(4)}\nЛинк: ${link}`;
  return { subject, html, text };
}

export function buildReportSms({
  lat, lng, fireId, baseUrl,
}: { lat: number; lng: number; fireId?: number; baseUrl: string }) {
  const link = fireId ? `${baseUrl}/fires/${fireId}` : `https://www.google.com/maps?q=${lat},${lng}`;
  const prefix = fireId ? 'Докладван пожар:' : 'FIRMS (непотвърдено):';
  const msg = `${prefix} ${lat.toFixed(4)},${lng.toFixed(4)} ${link}`;
  return msg;
}
\n===== END FILE: lib/notify.ts =====\n
===== FILE: package.json =====
{
  "name": "ignis",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev --turbopack",
    "build": "next build",
    "start": "next start",
    "lint": "eslint",
    "db:generate": "drizzle-kit generate",
    "db:migrate": "drizzle-kit migrate",
    "db:apply-notifications": "node scripts/apply_notifications.mjs",
    "db:push": "drizzle-kit push",
    "db:studio": "drizzle-kit studio"
  },
  "dependencies": {
    "@auth0/nextjs-auth0": "^4.9.0",
    "@aws-sdk/client-s3": "^3.882.0",
    "@aws-sdk/s3-request-presigner": "^3.882.0",
    "@hookform/resolvers": "^5.2.1",
    "@mapbox/mapbox-gl-draw": "^1.5.0",
    "@neondatabase/serverless": "1.0.1",
    "@radix-ui/react-aspect-ratio": "^1.1.7",
    "@radix-ui/react-avatar": "^1.1.10",
    "@radix-ui/react-dialog": "^1.1.1",
    "@radix-ui/react-label": "^2.1.7",
    "@radix-ui/react-navigation-menu": "^1.2.14",
    "@radix-ui/react-separator": "^1.0.0",
    "@radix-ui/react-slot": "^1.2.3",
    "@radix-ui/react-tabs": "^1.0.0",
    "@sendbird/chat": "^4.19.8",
    "@sendbird/uikit-react": "^3.17.2",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "cmdk": "^1.1.1",
    "drizzle-orm": "0.44.5",
    "embla-carousel-react": "^8.6.0",
    "lucide-react": "^0.542.0",
    "mapbox-gl": "^3.14.0",
    "next": "15.5.2",
    "next-themes": "^0.4.6",
    "qrcode": "^1.5.3",
    "react": "19.1.0",
    "react-dom": "19.1.0",
    "react-hook-form": "^7.62.0",
    "tailwind-merge": "^3.3.1",
    "uuid": "^11.1.0",
    "zod": "^4.1.5"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3",
    "@tailwindcss/postcss": "^4",
    "@types/mapbox__mapbox-gl-draw": "^1.4.9",
    "@types/node": "^20",
    "@types/qrcode": "^1.5.5",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "dotenv": "17.2.2",
    "drizzle-kit": "0.31.4",
    "eslint": "^9",
    "eslint-config-next": "15.5.2",
    "tailwindcss": "^4",
    "tw-animate-css": "^1.3.8",
    "typescript": "^5"
  }
}
\n===== END FILE: package.json =====\n
===== FILE: scripts/apply_notifications.mjs =====
import 'dotenv/config';
import { neon } from '@neondatabase/serverless';

const sql = neon(process.env.DATABASE_URL);

async function run() {
  // Create subscriptions table
  await sql`CREATE TABLE IF NOT EXISTS "notification_subscriptions" (
    "id" serial PRIMARY KEY NOT NULL,
    "email" varchar(255),
    "phone" varchar(32),
    "lat" double precision NOT NULL,
    "lng" double precision NOT NULL,
    "radius_km" integer DEFAULT 15 NOT NULL,
    "source_firms" integer DEFAULT 1 NOT NULL,
    "source_reports" integer DEFAULT 1 NOT NULL,
    "created_at" timestamp with time zone DEFAULT now() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT now() NOT NULL
  )`;

  // Indexes for subscriptions
  await sql`CREATE INDEX IF NOT EXISTS "notif_sub_email_idx" ON "notification_subscriptions" USING btree ("email")`;
  await sql`CREATE INDEX IF NOT EXISTS "notif_sub_phone_idx" ON "notification_subscriptions" USING btree ("phone")`;
  await sql`CREATE INDEX IF NOT EXISTS "notif_sub_coord_idx" ON "notification_subscriptions" USING btree ("lat","lng")`;

  // Create deliveries table
  await sql`CREATE TABLE IF NOT EXISTS "notification_deliveries" (
    "id" serial PRIMARY KEY NOT NULL,
    "subscription_id" integer NOT NULL,
    "event_key" varchar(256) NOT NULL,
    "delivered_at" timestamp with time zone DEFAULT now() NOT NULL,
    "meta" jsonb
  )`;

  // FK for deliveries (add if not exists)
  await sql`DO $$ BEGIN
    IF NOT EXISTS (
      SELECT 1 FROM information_schema.table_constraints
      WHERE constraint_name = 'notification_deliveries_subscription_id_notification_subscriptions_id_fk'
    ) THEN
      ALTER TABLE "notification_deliveries" ADD CONSTRAINT "notification_deliveries_subscription_id_notification_subscriptions_id_fk"
        FOREIGN KEY ("subscription_id") REFERENCES "public"."notification_subscriptions"("id") ON DELETE cascade ON UPDATE no action;
    END IF;
  END $$;`;

  // Indexes and unique constraint for deliveries
  await sql`CREATE UNIQUE INDEX IF NOT EXISTS "notif_delivery_sub_event_unique" ON "notification_deliveries" USING btree ("subscription_id","event_key")`;
  await sql`CREATE INDEX IF NOT EXISTS "notif_delivery_sub_idx" ON "notification_deliveries" USING btree ("subscription_id")`;
}

run().then(() => {
  console.log('Applied notifications schema.');
}).catch((e) => {
  console.error('Failed:', e?.message || e);
  process.exit(1);
});

\n===== END FILE: scripts/apply_notifications.mjs =====\n
===== FILE: scripts/check_tables.mjs =====
import 'dotenv/config';
import { neon } from '@neondatabase/serverless';

const sql = neon(process.env.DATABASE_URL);
const tables = ['zones','zone_members','zone_updates','zone_update_images','chat_messages','chat_blocks','fire_join_token_uses'];
for (const t of tables) {
  const rows = await sql`select to_regclass(${`public.${t}`}) as exists`;
  console.log(t, rows[0].exists);
}
\n===== END FILE: scripts/check_tables.mjs =====\n
